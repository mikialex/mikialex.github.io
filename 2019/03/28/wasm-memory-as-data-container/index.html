<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><title>WebAssembly零拷贝批量数据交换和计算 | mikialex</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="最近在尝试将wasm用以webgl渲染引擎加速，有2个问题比较担心，1是据说js call wasm overhead很高，难以做函数级别的优化，最好批量处理，虽然mozila后来优化了相关问题，但是目前还没有bench过，包括其他浏览器也不是很确定，2是担心批量处理，需要从js端copy数据，再copy回来，这个开销比较难受。所以做了一翻调研。假设我有一个很大的array需要传给webassem"><meta property="og:type" content="article"><meta property="og:title" content="WebAssembly零拷贝批量数据交换和计算"><meta property="og:url" content="http://mikialex.github.io/2019/03/28/wasm-memory-as-data-container/index.html"><meta property="og:site_name" content="mikialex"><meta property="og:description" content="最近在尝试将wasm用以webgl渲染引擎加速，有2个问题比较担心，1是据说js call wasm overhead很高，难以做函数级别的优化，最好批量处理，虽然mozila后来优化了相关问题，但是目前还没有bench过，包括其他浏览器也不是很确定，2是担心批量处理，需要从js端copy数据，再copy回来，这个开销比较难受。所以做了一翻调研。假设我有一个很大的array需要传给webassem"><meta property="og:locale" content="default"><meta property="og:updated_time" content="2020-08-23T07:00:50.630Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="WebAssembly零拷贝批量数据交换和计算"><meta name="twitter:description" content="最近在尝试将wasm用以webgl渲染引擎加速，有2个问题比较担心，1是据说js call wasm overhead很高，难以做函数级别的优化，最好批量处理，虽然mozila后来优化了相关问题，但是目前还没有bench过，包括其他浏览器也不是很确定，2是担心批量处理，需要从js端copy数据，再copy回来，这个开销比较难受。所以做了一翻调研。假设我有一个很大的array需要传给webassem"><link rel="icon" href="/favicon.png"><link href="https://fonts.googleapis.com/css?family=Crimson+Text:400,700|Inconsolata|Oswald" rel="stylesheet"><link rel="stylesheet" href="/icomoon/style.css"><link rel="stylesheet" href="/style.css"></head><body><div class="site-wrapper is_post_page"><div id="loading-bar-wrapper"><div id="loading-bar"></div></div><script>document.getElementById("loading-bar").style.width="20%"</script><header id="header" class="site-header clearfix"><a class="logo square clearfix" href="/"><span class="b">A</span> <span class="b">R</span> <span class="b">T</span> <span class="w">I</span> <span class="w">F</span> <span class="b">A</span> <span class="b">C</span> <span class="b">T</span> </a><a class="me square site-nav-switch clearfix"><span class="b"><span class="icon icon-menu"></span></span></a></header><script>document.getElementById("loading-bar").style.width="40%"</script><main id="main" class="clearfix"><article id="post-wasm-memory-as-data-container" class="article white-box article-type-post" itemscope itemprop="blogPost"><header class="article-header"><h1 class="article-title" itemprop="name">WebAssembly零拷贝批量数据交换和计算</h1><div class="article-meta">Posted on <time class="article-time" datetime="2019-03-27T16:00:00.000Z" itemprop="datePublished">Mar 28, 2019</time></div></header><div class="article-entry" itemprop="articleBody"><p>最近在尝试将wasm用以webgl渲染引擎加速，有2个问题比较担心，1是据说js call wasm overhead很高，难以做函数级别的优化，最好批量处理，虽然mozila后来优化了相关问题，但是目前还没有bench过，包括其他浏览器也不是很确定，2是担心批量处理，需要从js端copy数据，再copy回来，这个开销比较难受。所以做了一翻调研。</p><p>假设我有一个很大的array需要传给webassembly，wasm-bindgen 可以生成 number slice的<a href="https://rustwasm.github.io/docs/wasm-bindgen/reference/types/number-slices.html" target="_blank" rel="noopener">接口</a>, 大概类似这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">take_number_slice_by_shared_ref(<span class="keyword">new</span> <span class="built_in">Float64Array</span>(<span class="number">100</span>));</span><br><span class="line">take_number_slice_by_exclusive_ref(<span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="number">100</span>));</span><br></pre></td></tr></table></figure><p>大致是用户需要new一个typedarray来作为输入，需要在js端完成一次copy，临时内存分配和销毁带来的overhead并不合理，所以wasm能够真正应用得当需要寻找更合理的方式</p><p><a href="https://github.com/rustwasm/wasm-bindgen/issues/270" target="_blank" rel="noopener">这个issue</a>，以及<a href="https://stackoverflow.com/questions/41875728/pass-a-javascript-array-as-argument-to-a-webassembly-function" target="_blank" rel="noopener">这个</a> 看到比较合理的从js端传送批量数据到webassembly进行处理的方案。</p><p>大致流程是：</p><p>1 调用wasm的方法，在wasm内存中分配空间，返回指针位置<br>2 js端在wasm的memory arraybuffer上，按指针位置和数据量建立view，把数据写入<br>3 调用wasm方法完成计算， 返回计算好的批量结果的指针位置和大小<br>4 js端在wasm的memory arraybuffer上，按指针位置和数据量建立view，把数据读出</p><p>主要情况是： wasm模块会有一个线性的内存，js端看就是一个arraybuffer，js端可以自由的读写。所以批量的数据写入可以通过直接在这个memory的arraybuffer上建立view来实现。甚至说，<strong>我们可以直接将wasm的memory当作js部分的紧凑数据容器</strong>，某些批量的数据处理和计算，可以直接调用wasm的方法来实现，js端可以直接在结果的读容器中获得。</p><p>在 rust 的webassembly的官方 game of life 的例子中我们可以看到这个<a href="https://rustwasm.github.io/docs/book/game-of-life/implementing.html" target="_blank" rel="noopener">实现</a>, 直接访问wasm memory的数据</p><p>我自己测试了一下这种使用模式，似乎没有什么问题</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[wasm_bindgen]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Batcher</span></span> &#123;</span><br><span class="line">    data: <span class="built_in">Vec</span>&lt;<span class="built_in">f32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[wasm_bindgen]</span></span><br><span class="line"><span class="keyword">impl</span> Batcher &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; Batcher&#123;</span><br><span class="line">        Batcher &#123;</span><br><span class="line">            data:<span class="built_in">Vec</span>::with_capacity(<span class="number">100</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">allocate</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, capacity: <span class="built_in">u32</span>) -&gt; *<span class="keyword">const</span> <span class="built_in">f32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.data = <span class="built_in">vec!</span>[<span class="number">0.0</span>; capacity <span class="keyword">as</span> <span class="built_in">usize</span>];</span><br><span class="line">        <span class="keyword">self</span>.data.as_ptr()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">batch</span></span>(&amp;<span class="keyword">self</span>, batchLength: <span class="built_in">u32</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> &amp;<span class="keyword">self</span>.data &#123;</span><br><span class="line">            log_f32(*d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dataLength = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> batcher = wasm.Batcher.new();</span><br><span class="line"><span class="built_in">console</span>.log(batcher)</span><br><span class="line"><span class="keyword">const</span> ptr = batcher.allocate(dataLength);</span><br><span class="line"><span class="keyword">const</span> dataview = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(memory.buffer, ptr, dataLength);</span><br><span class="line"></span><br><span class="line">dataview[<span class="number">0</span>] = <span class="number">1.5</span>;</span><br><span class="line">dataview[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">dataview[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">dataview[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">batcher.batch(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>这个原型大致可以推测出一种使用wasm memory作为数据容器以实现前端零拷贝高性能计算的模式： 将wasm的memory直接存储js数据。当然，我们在不考虑性能的情况下可以wrap一群js对象，通过getter setter，或者其他数据同步的设施，使得用户可以直接操作普通对象的方式操作wasm中的数据。在某些情况下，wasm可以直接对存储的数据进行重计算的操作，然后零拷贝的暴露出计算结果。这可能是wasm用法的一个比较好的实践。</p><p>实际的应用其实渲染引擎的确可以作为不错的尝试的例子，场景树，节点的js对象直接读写数据到wasm中，在每一帧渲染时，wasm模块自身负责高性能的渲染数据生成／同步，包括优化，排序，最后的renderlist直接暴露在memory中，js外层再一个batch读结果，完成gl调用。 在这个过程中js和wasm之间0数据拷贝，最小化直接交互调用，似乎没什么问题。</p><p>by the way, rust相关的wasm工具链包括rust自身的使用体验非常优秀。值得推荐。</p></div><div class="article-tags"></div></article><script>document.getElementById("loading-bar").style.width="60%"</script></main><footer id="footer" class="clearfix"><div>&copy; mikialex Theme by <a href="http://artifact.me/" target="_blank">Art Chen</a>.</div><div>Powered by <a href="https://hexo.io/" rel="external">Hexo</a>.</div></footer><script>document.getElementById("loading-bar").style.width="80%"</script><div class="overlay"></div></div><div class="site-sidebar"><div class="sidebar-switch clearfix" style="display:none"><a class="dark-btn active" data-toggle="toc"><span class="icon icon-list"></span> <span class="text">Index</span> </a><a class="dark-btn" data-toggle="bio"><span class="icon icon-person"></span> <span class="text">Bio</span></a></div><div class="site-toc" style="display:none"><div class="no-index">No Index</div></div><div class="site-bio show" style="display:block"><div class="about-me clearfix"><div class="avatar"><img src="/img/avatar.png"></div><div class="info"><a class="name dark-btn" href="/about">miki alex</a></div><div class="info"><span class="item desc"></span></div></div><div class="social clearfix"><a href="/atom.xml" class="feed" target="_blank" rel="external"><span class="icon icon-feed"></span> </a><a href="https://github.com/mikialex" class="github" target="_blank" rel="external"><span class="icon icon-github"></span></a></div></div><div class="shortcuts"><a href="#header" class="top window-nav dark-btn" id="go-top"><span class="icon icon-chevron-thin-up"></span> </a><a class="close dark-btn" id="sidebar-close"><span class="icon icon-close"></span> </a><a href="#footer" class="top window-nav dark-btn" id="go-bottom"><span class="icon icon-chevron-thin-down"></span></a></div></div><script type="text/javascript">var GOOGLE_CUSTOM_SEARCH_API_KEY="",GOOGLE_CUSTOM_SEARCH_ENGINE_ID="",ALGOLIA_API_KEY="",ALGOLIA_APP_ID="",ALGOLIA_INDEX_NAME="",AZURE_SERVICE_NAME="",AZURE_INDEX_NAME="",AZURE_QUERY_KEY="",BAIDU_API_ID="",SEARCH_SERVICE="google",universalSearchConfig={};"google"===SEARCH_SERVICE?universalSearchConfig={searchService:SEARCH_SERVICE,apiKey:GOOGLE_CUSTOM_SEARCH_API_KEY,engineId:GOOGLE_CUSTOM_SEARCH_ENGINE_ID,imagePath:"/img/"}:"algolia"===SEARCH_SERVICE?universalSearchConfig={searchService:SEARCH_SERVICE,apiKey:ALGOLIA_API_KEY,appId:ALGOLIA_APP_ID,indexName:ALGOLIA_INDEX_NAME,imagePath:"/img/"}:"azure"===SEARCH_SERVICE&&(universalSearchConfig={searchService:SEARCH_SERVICE,serviceName:AZURE_SERVICE_NAME,indexName:AZURE_INDEX_NAME,apiKey:AZURE_QUERY_KEY,imagePath:"/img/"})</script><script src="https://code.jquery.com/jquery-2.1.4.min.js"></script><script>window.jQuery||document.write('<script src="/js/jquery.js"><\/script>')</script><script src="/js/search.js"></script><script src="/js/app.js"></script><script>document.getElementById("loading-bar").style.width="100%"</script></body></html>