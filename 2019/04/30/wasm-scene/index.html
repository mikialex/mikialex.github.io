<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><title>WebAssembly 3D 场景树加速原型验证 | mikialex</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="继上次 「WebAssembly零拷贝批量数据交换和计算」 一文中的想法，我在我的webgl引擎项目中进行了初步实践。相应的代码可以在 artgl 中找到。基本验证了上次的设想（使用wasm加速渲染数据生成更新并batch drawcall）是可行的。TLDR主要实现了一些基本的场景数据和渲染数据存储在wasm 的memory中，场景节点提供普通的 js api。实测使用6层6叉的超大场景树，约6"><meta property="og:type" content="article"><meta property="og:title" content="WebAssembly 3D 场景树加速原型验证"><meta property="og:url" content="http://yoursite.com/2019/04/30/wasm-scene/index.html"><meta property="og:site_name" content="mikialex"><meta property="og:description" content="继上次 「WebAssembly零拷贝批量数据交换和计算」 一文中的想法，我在我的webgl引擎项目中进行了初步实践。相应的代码可以在 artgl 中找到。基本验证了上次的设想（使用wasm加速渲染数据生成更新并batch drawcall）是可行的。TLDR主要实现了一些基本的场景数据和渲染数据存储在wasm 的memory中，场景节点提供普通的 js api。实测使用6层6叉的超大场景树，约6"><meta property="og:locale" content="default"><meta property="og:updated_time" content="2020-08-23T07:00:50.631Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="WebAssembly 3D 场景树加速原型验证"><meta name="twitter:description" content="继上次 「WebAssembly零拷贝批量数据交换和计算」 一文中的想法，我在我的webgl引擎项目中进行了初步实践。相应的代码可以在 artgl 中找到。基本验证了上次的设想（使用wasm加速渲染数据生成更新并batch drawcall）是可行的。TLDR主要实现了一些基本的场景数据和渲染数据存储在wasm 的memory中，场景节点提供普通的 js api。实测使用6层6叉的超大场景树，约6"><link rel="icon" href="/favicon.png"><link href="https://fonts.googleapis.com/css?family=Crimson+Text:400,700|Inconsolata|Oswald" rel="stylesheet"><link rel="stylesheet" href="/icomoon/style.css"><link rel="stylesheet" href="/style.css"></head><body><div class="site-wrapper is_post_page"><div id="loading-bar-wrapper"><div id="loading-bar"></div></div><script>document.getElementById("loading-bar").style.width="20%"</script><header id="header" class="site-header clearfix"><a class="logo square clearfix" href="/"><span class="b">A</span> <span class="b">R</span> <span class="b">T</span> <span class="w">I</span> <span class="w">F</span> <span class="b">A</span> <span class="b">C</span> <span class="b">T</span> </a><a class="me square site-nav-switch clearfix"><span class="b"><span class="icon icon-menu"></span></span></a></header><script>document.getElementById("loading-bar").style.width="40%"</script><main id="main" class="clearfix"><article id="post-wasm-scene" class="article white-box article-type-post" itemscope itemprop="blogPost"><header class="article-header"><h1 class="article-title" itemprop="name">WebAssembly 3D 场景树加速原型验证</h1><div class="article-meta">Posted on <time class="article-time" datetime="2019-04-29T16:00:00.000Z" itemprop="datePublished">Apr 30, 2019</time></div></header><div class="article-entry" itemprop="articleBody"><p>继上次 「WebAssembly零拷贝批量数据交换和计算」 一文中的想法，我在我的webgl引擎项目中进行了初步实践。相应的代码可以在 <a href="https://github.com/mikialex/artgl" target="_blank" rel="noopener">artgl</a> 中找到。基本验证了上次的设想（使用wasm加速渲染数据生成更新并batch drawcall）是可行的。</p><h2 id="TLDR"><a href="#TLDR" class="headerlink" title="TLDR"></a>TLDR</h2><p>主要实现了一些基本的场景数据和渲染数据存储在wasm 的memory中，场景节点提供普通的 js api。</p><p><strong>实测使用6层6叉的超大场景树，约6w节点，全部计算更新世界矩阵，耗时是threejs的不到一半。</strong>（～6ms ／ ～14ms）</p><p>这基本证明了其性能优势是无法忽视的。</p><p>local矩阵的更新，世界bounding信息的更新，以及这些的按需行为，视锥剔除 细节剔除 drawcall排序 基数排序 这些将在后续完成实现</p><h2 id="基本设计"><a href="#基本设计" class="headerlink" title="基本设计"></a>基本设计</h2><p>scene对象负责管理用户描述场景的sceneNode节点，以及渲染数据的更新。</p><p>实际的数据存储在多个float32array／ int32array 中，这些array的视图建立在wasm内存arraybuffer上，初始化和扩容时调用scene对应的wasmscene的扩容方法，完成wasm内的扩容，返回这些array的ptr，用以更新typearray的视图。sceneNode上的场景数据，会以getter和setter的形式直接访问wasm内存中的数据。例如用户设置了某个节点的position， 数据会直接通过typedarray写入wasm内存中。</p><p>比如目前就已经实现了下列数据的包装：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">local_transform_array: <span class="built_in">Vec</span>&lt;<span class="built_in">f32</span>&gt;,</span><br><span class="line">local_position_array: <span class="built_in">Vec</span>&lt;<span class="built_in">f32</span>&gt;,</span><br><span class="line">local_rotation_array: <span class="built_in">Vec</span>&lt;<span class="built_in">f32</span>&gt;,</span><br><span class="line">local_scale_array: <span class="built_in">Vec</span>&lt;<span class="built_in">f32</span>&gt;,</span><br><span class="line">world_transform_array: <span class="built_in">Vec</span>&lt;<span class="built_in">f32</span>&gt;，</span><br><span class="line"></span><br><span class="line">local_aabb_array: <span class="built_in">Vec</span>&lt;<span class="built_in">f32</span>&gt;,</span><br><span class="line">world_aabb_array: <span class="built_in">Vec</span>&lt;<span class="built_in">f32</span>&gt;,</span><br><span class="line">local_bsphere_array: <span class="built_in">Vec</span>&lt;<span class="built_in">f32</span>&gt;,</span><br><span class="line">world_bsphere_array: <span class="built_in">Vec</span>&lt;<span class="built_in">f32</span>&gt;,</span><br><span class="line"></span><br><span class="line">empty_array: <span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt;,</span><br><span class="line">empty_list_array: <span class="built_in">Vec</span>&lt;<span class="built_in">u16</span>&gt;,</span><br><span class="line">empty_count: <span class="built_in">u16</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// [parent, left brother, right brother, first child]</span></span><br><span class="line">nodes_indexs: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;,</span><br></pre></td></tr></table></figure><p>为了实现将tree存储于array中，tree的children使用双链表实现，每一个node存储前后一个兄弟，父亲，第一个child的索引位置。由于用户几乎没有随机访问某一个节点的children的需求，查询操作基本不受影响。sceneNode的js api 暴露add和remove方法会自动维护相关的索引。</p><p>empty_array和empty_list_array用以做标记删除</p><p>在后续会加入：</p><p>一个uint32的array使用位信息来表示每一个数据的change情况用以按需优化。</p><p>一个f32表示距离，一个f32表示屏幕投影大小。 一个uint32表示gl状态，包括shader／blend／culling ／visibility。这些可以组合起来做基数排序。</p><p>每次渲染时，scene通知wasmscene batch drawcall， 在wasm中完成所有计算，生成一个index list ，返回这个result indexlist的ptr和count， 然后js renderer加个接口直接读取就可以。 另外可以考虑的是直接使用wasm webgl的bindgen 这方面没有了解，可能需要调研和测试。</p><h2 id="遇到的坑·已知风险·考虑："><a href="#遇到的坑·已知风险·考虑：" class="headerlink" title="遇到的坑·已知风险·考虑："></a>遇到的坑·已知风险·考虑：</h2><p>wasm 的部分在chrome pref测量会导致性能问题。对实际运行无影响。</p><p>rust要开o3编译。</p><p>需要考虑asmjs的fallback，uc qq浏览器支持不好。</p><p>wasm scene和其他的比如three的scene有一个区别是，sceneNode 有attach状态并且只能属于一个scene，这个可能会引起上层设计改动。</p></div><div class="article-tags"></div></article><script>document.getElementById("loading-bar").style.width="60%"</script></main><footer id="footer" class="clearfix"><div>&copy; mikialex Theme by <a href="http://artifact.me/" target="_blank">Art Chen</a>.</div><div>Powered by <a href="https://hexo.io/" rel="external">Hexo</a>.</div></footer><script>document.getElementById("loading-bar").style.width="80%"</script><div class="overlay"></div></div><div class="site-sidebar"><div class="sidebar-switch clearfix" style="display:none"><a class="dark-btn active" data-toggle="toc"><span class="icon icon-list"></span> <span class="text">Index</span> </a><a class="dark-btn" data-toggle="bio"><span class="icon icon-person"></span> <span class="text">Bio</span></a></div><div class="site-toc" style="display:none"><div class="no-index">No Index</div></div><div class="site-bio show" style="display:block"><div class="about-me clearfix"><div class="avatar"><img src="/img/avatar.png"></div><div class="info"><a class="name dark-btn" href="/about">miki alex</a></div><div class="info"><span class="item desc"></span></div></div><div class="social clearfix"><a href="/atom.xml" class="feed" target="_blank" rel="external"><span class="icon icon-feed"></span> </a><a href="https://github.com/mikialex" class="github" target="_blank" rel="external"><span class="icon icon-github"></span></a></div></div><div class="shortcuts"><a href="#header" class="top window-nav dark-btn" id="go-top"><span class="icon icon-chevron-thin-up"></span> </a><a class="close dark-btn" id="sidebar-close"><span class="icon icon-close"></span> </a><a href="#footer" class="top window-nav dark-btn" id="go-bottom"><span class="icon icon-chevron-thin-down"></span></a></div></div><script type="text/javascript">var GOOGLE_CUSTOM_SEARCH_API_KEY="",GOOGLE_CUSTOM_SEARCH_ENGINE_ID="",ALGOLIA_API_KEY="",ALGOLIA_APP_ID="",ALGOLIA_INDEX_NAME="",AZURE_SERVICE_NAME="",AZURE_INDEX_NAME="",AZURE_QUERY_KEY="",BAIDU_API_ID="",SEARCH_SERVICE="google",universalSearchConfig={};"google"===SEARCH_SERVICE?universalSearchConfig={searchService:SEARCH_SERVICE,apiKey:GOOGLE_CUSTOM_SEARCH_API_KEY,engineId:GOOGLE_CUSTOM_SEARCH_ENGINE_ID,imagePath:"/img/"}:"algolia"===SEARCH_SERVICE?universalSearchConfig={searchService:SEARCH_SERVICE,apiKey:ALGOLIA_API_KEY,appId:ALGOLIA_APP_ID,indexName:ALGOLIA_INDEX_NAME,imagePath:"/img/"}:"azure"===SEARCH_SERVICE&&(universalSearchConfig={searchService:SEARCH_SERVICE,serviceName:AZURE_SERVICE_NAME,indexName:AZURE_INDEX_NAME,apiKey:AZURE_QUERY_KEY,imagePath:"/img/"})</script><script src="https://code.jquery.com/jquery-2.1.4.min.js"></script><script>window.jQuery||document.write('<script src="/js/jquery.js"><\/script>')</script><script src="/js/search.js"></script><script src="/js/app.js"></script><script>document.getElementById("loading-bar").style.width="100%"</script></body></html>