<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mikialex</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-09-09T11:39:37.903Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>miki alex</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ECS的一些理解</title>
    <link href="http://yoursite.com/2020/08/25/ecs-2020/"/>
    <id>http://yoursite.com/2020/08/25/ecs-2020/</id>
    <published>2020-08-24T16:00:00.000Z</published>
    <updated>2020-09-09T11:39:37.903Z</updated>
    
    <content type="html"><![CDATA[<p>我不认为ECS是专门为了解决游戏逻辑而存在的架构思想，而是一种全新的，一般的，普适的建模方法。游戏领域更容易暴露出传统面向对象体系下的各种问题而prefer ECS，但这并不是将这种架构思想限制于游戏的理由。ECS我认为是一种比面向对象更加一般，更加优秀的建模方法。</p><p>在面向对象中，当我们描述世界中某个概念，某个实体，就会写新的class，或者继承某些已有的class，我要继承某个对象，往往为的是往上面添加某些新的行为/方法，或者数据。继承结构是编译期确定的，在运行时，每一种类的能力都不能发生变化。</p><p>但ECS中，我们的做法是，组合一些component，或者添加新的component类型并组合，组合的结果是entity。任何概念和实体都是entity。原先用类描述一个物体，现在我们用entity。如果我要给某个entity添加新的数据/能力，那么我就添加它需要的component。相比面向对象，由于entity只是component的组合，所以任何物体，在运行时可以动态增加/删除 行为和能力，这个相比编译期的类非常非常灵活。面向对象的类，其能力和行为都是通过静态的继承树/图（多继承）完成的，不可变的。但在ECS中，一个实体，具体有什么能力/行为，这个东西本身就被数据化了，数据化的结果就是可以让我们在运行时能够添加修改删除查询任意实体的能力和行为。我想这是一种建模思想和建模能力的飞跃。</p><p>我想，很多架构上的改进，或者说设计模式，其实本质上就是将原先写死在代码里的逻辑，数据化，使得原先不灵活的东西，变成灵活的可操控的东西，以应对需求变化/演进，甚至你可以针对数据化的逻辑写代码。举一些例子比如观察者模式，如果没有观察者模式，那么对象之间的依赖，通信，都只能是写死在各个类上的方法，这个类call另一个类，在代码里写死调用，写死依赖。而观察者模式本质上把这种依赖数据化了，原先写死的方法调用依赖，变成统一装载在eventdispatcher里回调函数，变成了一个function的array，每一个function都是原先的依赖，数据化的结果就是对象直接可以动态的建立联系，on off emit，而不是写死在代码里。 又比如我们实现的rendergraph框架，也是把整个复杂的多变的渲染流程描述变成了数据，正因为完成了数据化，我们才能实现针对这种数据的逻辑，即自动依赖分析等。所以我一直觉得，架构改进，就是数据化的过程，而数据化的终极形态，就是ecs，ecs里我们都不会为了世界中的实体写类了，任何东西都是组合出来的，任何东西都是数据的组合。everthing is about data.</p><p>在ecs中，你的所有东西，或者说你的世界，你的场景，你的业务数据，事实上全部都在一个database中。entity就是这个database的index，你可以想想一个巨大的table，每一列是一种component类型，每一行是entity，里边单元格装着component的实例。 你的everything都在这里边，无比的simple，整齐，统一，只有数据。这是EC</p><p>那么数据都在这里整齐的放置着，我的业务逻辑呢，这就是S， System。逻辑其实就是处理数据的过程，system就是一个处理过程的单元，具体怎么处理数据呢，很简单，我们有个database，那么你在这个database上运行某些查询条件，读取你关心的数据，做处理，再写入你指定的地方。仿佛就是写web后端一样，模式高度简单统一。我们实际的逻辑其实比较复杂，应该拆分成若干小的sysytem，这些小的system就实现了处理逻辑的复用（对应的数据字段的复用体现在component组合上）。每一个system可能依赖其他system，那么事实上整个system构成了有向无环图，和rendergraph一样。这下，事实上正如同我们解决渲染pass间的依赖关系一样，逻辑之间的依赖关系也被自动解决了。。更amazing的是，由于依赖关系变成数据（图），多线程瞬间就支持了，systemgraph的执行器完全可以搞threadpool发任务。我们知道多线程很恶心数据竞争的问题，事实上这个也瞬间被解决了，因为你声明system的时候，system要运行的EC数据库查询条件，无论是写还是读，都是确定的，所以执行器完全可以判断某个时刻EC数据库的哪些部分正在被哪些sysytem进行访问，避免同时写就ok了。更amazing的是由于ec的存储基本都是array，稍加考虑缓存命中都相对随机访问很好，性能会有额外的好处，在我看到的ecs的实现中，有的甚至有在budget时间内整理内存的接口来优化这个事情。</p><p>下面，我简单设想一下如果将ecs作为场景层架构，具体的形态可能是怎么样的：</p><p>matrix, worldMatrix, modelViewMatrix，或者说，所有的uniformLike的数据 全部都是独立的component，这样，只有拥有这些component的物体才会被更新这些数据，而不是像现在一样统一更新（毕竟可能有些物体的绘制不需要matrix）同理，任意一种uniformlike的数据，也都是按需被组合在entity上，会有具体的system完成他们的更新，不会有额外的数据，不会有额外的逻辑。</p><p>层次结构： 层次结构是个component，具体的数据是parent和children的entityID.</p><p>如何完成变化监测：我能想到有两种思路： 1 事实上任意一种component，我们可以统一支持其额外的state，就是自上一次同步前，哪些change，add，delete，sysytem在查询数据库时，可以为某些component的查询附加额外的查询条件，比如我只想查询所有上次同步前所有新加的的 A component ，另一种思路2，是component对应的change信息也是数据，也是component，我们提供一个封装良好的结构，可以让用户包装某些component，使其实际变成多个component并实现change的功能</p><p>场景更新流程：每一种场景内容相关的component，都应当实现上面提到的watchable的装饰。所以更新的系统们可以完整知道整个场景数据的change情况，便可以执行更新逻辑。以我们现有的更新逻辑同步举例：</p><p>step0 业务逻辑完成场景更新</p><p>这部分是业务逻辑，不属于引擎范畴，如果业务逻辑也是ecs，那么这里放的是业务逻辑的sysytem</p><p>step1 完成层次结构的更新（matrix，visible等受层次结构影响的数据）</p><p>查询所有 （有层次结构组件，所有可能有（任意受层次结构影响 且 发生变更）的若干组件），<br>system逻辑触发所有子tree change，change标记在层次结构组件上<br>forach所有发生变更的组件，完成更新，其中，各种component各自从parent更新的方法使用一个统一的特殊trait约束，其中更新方法对数据需求都是optional的，因为更新的组件这时候也是optional的</p><p>step2 完成GPU数据更新</p><p>查询所有ubo，vao，vbo，ibo，texture，sample，所有的GPU资源的变更组件，各种sysytem完成更新操作</p><p>step3 drawcalllist 生成和剔除</p><p>查询所有renderobject（drawcall）这个也是component，但这个component里其实是其他component的ID，表现上看起来是entity）且具有Bounding的component。走剔除system得到rawlist多pass，每个节点依赖的camera是不一样的，所以这个system会被调用多次，生成的list本身也是component。其他drawcalllist 过滤，分叉，变换都是各个实现好的sysytem，读写listcomponent数据</p><p>step4 rendergraph execution</p><p>因为rendergraph和system dispatch graph本质是一样的，所以新的系统会使用一套实现，你可以理解成，整个ECS系统的dispatch部分，就是rendergraph。 每个pass是system，每个pass前的小更新操作也是system。整个引擎使用一整套Systemgraph作为流程抽象和逻辑组织，整个场景使用一个Entity Component数据库存储所有绘制信息</p><p>最后我对ecs还有一些疑虑之处比如：</p><p>前文我提到某些component事实上有些数据是其他的component的reference（ID）。所以事实上我们是通过typed id来完成引用关系的数据化，那么数据删除的话，id失效怎么办，难道runtime check and panic吗。所以我们针对这种reference的data，需要提供引用计数回收吗？ 如果你认为entity本身也是一个component，事实上为什么不呢？所以最后的概念模型就是我有一堆的component，这些component以id的形式相互引用，这感觉就像是一堆heap一样，每个id就是某个heap内的指针（地址），感觉就是自己维护了堆。。如果从这个角度想，那要真的正确回收component，引用计数能work，似乎再搞个garbage collection 也没什么问题？</p><p>将数据拆分成多个component，我的另一个疑虑是是否会增加额外的遍历次数和成本，在没有ecs的情况下，我要的数据的访问往往可以集中在一次循环中完成，而且不需要动态的根据条件来过滤component组合，这其实也是额外的开销。当然我也知道基于原型的ecs可以解决这个问题，但也会引入其他问题，总觉得还是有tradeoff存在</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我不认为ECS是专门为了解决游戏逻辑而存在的架构思想，而是一种全新的，一般的，普适的建模方法。游戏领域更容易暴露出传统面向对象体系下的各种问题而prefer ECS，但这并不是将这种架构思想限制于游戏的理由。ECS我认为是一种比面向对象更加一般，更加优秀的建模方法。&lt;/p&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用Rust trait 抽象三维几何数据类型</title>
    <link href="http://yoursite.com/2020/08/23/abs-geometry/"/>
    <id>http://yoursite.com/2020/08/23/abs-geometry/</id>
    <published>2020-08-22T16:00:00.000Z</published>
    <updated>2020-08-23T07:02:29.757Z</updated>
    
    <content type="html"><![CDATA[<p>在对rust的trait， generics等概念有了一定理解后，我尝试集中编写一些三维几何数据的容器类作为渲染引擎的基础库。</p><p>如果你对three.js比较了解的话，我这里做的，其实就是使用rust编写Geometry，BufferGeometry等容器类，three的geometry写的是很挫的，寄希望于rust这门优秀的语言，我试图提升一下自我要求，比如：</p><ul><li>尝试将拓扑信息编码在类型之中，这样假设我有一个描述以triangleList为布局的几何数据，不应该赋值给一个以trianglestrip为布局的几何数据。</li><li>可以使用任何用户自定义的顶点数据结构</li><li>提供一个统一的图元迭代器，图元的类型由拓扑类型决定</li><li>同时支持index/无index， interleaved/非interleaved的buffer数据</li></ul><h2 id="统一interleaved和非interleaved的数据"><a href="#统一interleaved和非interleaved的数据" class="headerlink" title="统一interleaved和非interleaved的数据"></a>统一interleaved和非interleaved的数据</h2><p>我们正常在opengl/webgl中使用的数据都是非interleaved的，比如一般来说position是一个单独的buffer，normal也是一个单独的buffer，uv也是。而interleaved版本是position + normal + uv交替存储，只使用一个buffer。</p><p>虽然我一般都是使用非interleave版本，但事实上interleaved才是较为原始的数据存储，假设你如下定义一个struct，标记内存布局使用C语言标准。对于一个<code>Vec&lt;Vertex&gt;</code>, 它的内存事实上完全就是interleaving的，你可以直接transmute一下上传，没有多余的拷贝。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="meta">#[derive(Clone, Copy, soa_derive::StructOfArray)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span></span> &#123;</span><br><span class="line">  <span class="keyword">pub</span> position: Vec3&lt;<span class="built_in">f32</span>&gt;,</span><br><span class="line">  <span class="keyword">pub</span> normal: Vec3&lt;<span class="built_in">f32</span>&gt;,</span><br><span class="line">  <span class="keyword">pub</span> uv: Vec2&lt;<span class="built_in">f32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> my_geometry_data: <span class="built_in">Vec</span>&lt;Vertex&gt;;</span><br></pre></td></tr></table></figure><p>而我们常用的非interleave版本本质上是这个：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">VertexArray</span></span> &#123;</span><br><span class="line">  <span class="keyword">pub</span> position: <span class="built_in">Vec</span>&lt;Vec3&lt;<span class="built_in">f32</span>&gt;&gt;,</span><br><span class="line">  <span class="keyword">pub</span> normal: <span class="built_in">Vec</span>&lt;Vec3&lt;<span class="built_in">f32</span>&gt;&gt;,</span><br><span class="line">  <span class="keyword">pub</span> uv: <span class="built_in">Vec</span>&lt;Vec2&lt;<span class="built_in">f32</span>&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> my_geometry_data: VertexArray;</span><br></pre></td></tr></table></figure><p>本质上就是struct of array 和 array of struct 的区别。你也看到，我在Vertex上标记<code>soa_derive::StructOfArray</code>, 这个库可以为我们自动生成 struct of array版本的类型，并实现<code>As&lt;[T]&gt; + Index&lt;usize&gt;</code>这两个trait, 这使得两种容器类型在使用上一模一样。</p><p>所以和这个抹平差异的思想一致。实际数据的存储上，容器要满足的trait是：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">GeometryDataContainer</span></span>&lt;T&gt;:</span><br><span class="line">  <span class="built_in">AsRef</span>&lt;[T]&gt; + <span class="built_in">Clone</span> + Index&lt;<span class="built_in">usize</span>, Output = T&gt; + FromIterator&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为普通vec实现</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: <span class="built_in">Clone</span>&gt; GeometryDataContainer&lt;T&gt; <span class="keyword">for</span> <span class="built_in">Vec</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="comment">// 为自动的soa derive实现</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: StructOfArray, A: T::ArrayType&gt; GeometryDataContainer&lt;T&gt; <span class="keyword">for</span> A &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="顶点，拓扑，和图元的trait约束"><a href="#顶点，拓扑，和图元的trait约束" class="headerlink" title="顶点，拓扑，和图元的trait约束"></a>顶点，拓扑，和图元的trait约束</h2><p>一个几何由很多顶点构成，先不考虑有没有index，这些顶点每一个/两个/三个 形成一个三角形/线段/点，如果再考虑是list还是strip，又可分为每过一个图元步进几个顶点数据。这些如何使用trait来抽象呢？</p><p>先看顶点，这里我们把问题再放窄一点，要求顶点必须是能提供3d空间点的信息， 3d空间点也不再加一层泛型，就f32吧，所以所有顶点应该实现这个trait：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Positioned3D</span></span>: <span class="built_in">Copy</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">position</span></span>(&amp;<span class="keyword">self</span>) -&gt; Vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顶点构成图元， 图元的约束可以是这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">PrimitiveData</span></span>&lt;T: Positioned3D&gt; &#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">IndexIndicator</span></span>;</span><br><span class="line">  <span class="keyword">const</span> DATA_STRIDE: <span class="built_in">usize</span>;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">from_indexed_data</span></span>(index: &amp;[<span class="built_in">u16</span>], data: &amp;[T], offset: <span class="built_in">usize</span>) -&gt; <span class="keyword">Self</span>;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">create_index_indicator</span></span>(index: &amp;[<span class="built_in">u16</span>], offset: <span class="built_in">usize</span>) -&gt; Self::IndexIndicator;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">from_data</span></span>(data: &amp;[T], offset: <span class="built_in">usize</span>) -&gt; <span class="keyword">Self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看几个impl可能会更清楚：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: Positioned3D&gt; PrimitiveData&lt;T&gt; <span class="keyword">for</span> Triangle&lt;T&gt; &#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">IndexIndicator</span></span> = Triangle&lt;<span class="built_in">u16</span>&gt;;</span><br><span class="line">  <span class="keyword">const</span> DATA_STRIDE: <span class="built_in">usize</span> = <span class="number">3</span>;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">from_indexed_data</span></span>(index: &amp;[<span class="built_in">u16</span>], data: &amp;[T], offset: <span class="built_in">usize</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> a = data[index[offset] <span class="keyword">as</span> <span class="built_in">usize</span>];</span><br><span class="line">    <span class="keyword">let</span> b = data[index[offset + <span class="number">1</span>] <span class="keyword">as</span> <span class="built_in">usize</span>];</span><br><span class="line">    <span class="keyword">let</span> c = data[index[offset + <span class="number">2</span>] <span class="keyword">as</span> <span class="built_in">usize</span>];</span><br><span class="line">    Triangle &#123; a, b, c &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">create_index_indicator</span></span>(index: &amp;[<span class="built_in">u16</span>], offset: <span class="built_in">usize</span>) -&gt; Self::IndexIndicator &#123;</span><br><span class="line">    <span class="keyword">let</span> a = index[offset];</span><br><span class="line">    <span class="keyword">let</span> b = index[offset + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> c = index[offset + <span class="number">2</span>];</span><br><span class="line">    Triangle &#123; a, b, c &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">from_data</span></span>(data: &amp;[T], offset: <span class="built_in">usize</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> a = data[offset];</span><br><span class="line">    <span class="keyword">let</span> b = data[offset + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> c = data[offset + <span class="number">2</span>];</span><br><span class="line">    Triangle &#123; a, b, c &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Positioned3D&gt; PrimitiveData&lt;T&gt; <span class="keyword">for</span> LineSegment&lt;T&gt; &#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">IndexIndicator</span></span> = LineSegment&lt;<span class="built_in">u16</span>&gt;;</span><br><span class="line">  <span class="keyword">const</span> DATA_STRIDE: <span class="built_in">usize</span> = <span class="number">2</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DATA_STRIDE</code>就是上文提到的数据宽度，三个方法就是具体从一个slice里读取并构造出图元的实现，IndexIndicator辅助支持indexgeometry。这个trait配合上面的容器抽象，我们就可以在容器的指定位置读取图元。</p><p>基于顶点和图元，我们还需要描述拓扑的信息，显然，拓扑可以使用零尺寸类型表达</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">PrimitiveTopology</span></span>&lt;T: Positioned3D&gt; &#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Primitive</span></span>: PrimitiveData&lt;T&gt;;</span><br><span class="line">  <span class="keyword">const</span> STRIDE: <span class="built_in">usize</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里不多举例，可以看到拓扑这个trait同时link了对顶点的约束，以及对应的图元类型，和步进长度</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TriangleList</span></span>;</span><br><span class="line"><span class="keyword">impl</span>&lt;T: Positioned3D&gt; PrimitiveTopology&lt;T&gt; <span class="keyword">for</span> TriangleList &#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Primitive</span></span> = Triangle&lt;T&gt;;</span><br><span class="line">  <span class="keyword">const</span> STRIDE: <span class="built_in">usize</span> = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TriangleStrip</span></span>;</span><br><span class="line"><span class="keyword">impl</span>&lt;T: Positioned3D&gt; PrimitiveTopology&lt;T&gt; <span class="keyword">for</span> TriangleStrip &#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Primitive</span></span> = Triangle&lt;T&gt;;</span><br><span class="line">  <span class="keyword">const</span> STRIDE: <span class="built_in">usize</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造我们的几何类型"><a href="#构造我们的几何类型" class="headerlink" title="构造我们的几何类型"></a>构造我们的几何类型</h2><p>Index和非Index版本的数据结构如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">IndexedGeometry</span></span>&lt;</span><br><span class="line">  V: Positioned3D = Vertex,</span><br><span class="line">  T: PrimitiveTopology&lt;V&gt; = TriangleList,</span><br><span class="line">  U: GeometryDataContainer&lt;V&gt; = <span class="built_in">Vec</span>&lt;V&gt;,</span><br><span class="line">&gt; &#123;</span><br><span class="line">  <span class="keyword">pub</span> data: U,</span><br><span class="line">  <span class="keyword">pub</span> index: <span class="built_in">Vec</span>&lt;<span class="built_in">u16</span>&gt;,</span><br><span class="line">  _v_phantom: PhantomData&lt;V&gt;,</span><br><span class="line">  _phantom: PhantomData&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">NoneIndexedGeometry</span></span>&lt;</span><br><span class="line">  V: Positioned3D = Vertex,</span><br><span class="line">  T: PrimitiveTopology&lt;V&gt; = TriangleList,</span><br><span class="line">  U: GeometryDataContainer&lt;V&gt; = <span class="built_in">Vec</span>&lt;V&gt;,</span><br><span class="line">&gt; &#123;</span><br><span class="line">  <span class="keyword">pub</span> data: U,</span><br><span class="line">  _v_phantom: PhantomData&lt;V&gt;,</span><br><span class="line">  _phantom: PhantomData&lt;T&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于这两种geometry，配合上面的一些内容，可以直接实现出图元的迭代器，包括ExactSizeIterator。很简单，这里就不放出实现了。</p><p>可以看到我们有两个geometry，有index的和无index的，这应该需要统一一下。他们应该要实现同一个trait，这个trait应该是几何数据最基础的trait。 从抽象的角度来看，我们只关心图元，应该是要能返回图元的ExactSizeIterator，以及图元的随机访问能力。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">AbstractGeometry</span></span>: <span class="built_in">Sized</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Vertex</span></span>: Positioned3D;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Topology</span></span>: PrimitiveTopology&lt;Self::Vertex&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">wrap</span></span>&lt;<span class="symbol">'a</span>&gt;(&amp;<span class="symbol">'a</span> <span class="keyword">self</span>) -&gt; AbstractGeometryRef&lt;<span class="symbol">'a</span>, <span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">    AbstractGeometryRef &#123; wrapped: <span class="keyword">self</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">primitive_iter</span></span>&lt;<span class="symbol">'a</span>&gt;(&amp;<span class="symbol">'a</span> <span class="keyword">self</span>) -&gt; AbstractPrimitiveIter&lt;<span class="symbol">'a</span>, <span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">    AbstractPrimitiveIter(<span class="keyword">self</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">primitive_at</span></span>(</span><br><span class="line">    &amp;<span class="keyword">self</span>,</span><br><span class="line">    primitive_index: <span class="built_in">usize</span>,</span><br><span class="line">  ) -&gt; <span class="built_in">Option</span>&lt;&lt;Self::Topology <span class="keyword">as</span> PrimitiveTopology&lt;Self::Vertex&gt;&gt;::Primitive&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为返回的迭代器势必要对源数据保持一个借用关系，如果我要把这个迭代器的类型写进AbstractGeometry的关联类型的话，会有个生命周期参数要填。为了解决这个问题我参考了一些做法做了一些尝试，最后做法是再间接return中间的迭代器结构，让这个中间的迭代器实现IntoIterator，而这个实现我们在为AbstractGeometry实现一些通用方法的时候加上这个trait约束即可，其中生命周期参数通过HRTB注入。比如下面这个为<strong>所有几何类型实现获得光线相交点的列表</strong>的实现：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">'a</span>, V, P, T, G&gt; IntersectAble&lt;AbstractGeometryRef&lt;<span class="symbol">'a</span>, G&gt;, IntersectionList3D, Config&gt; <span class="keyword">for</span> Ray3</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">  V: Positioned3D,</span><br><span class="line">  P: IntersectAble&lt;Ray3, NearestPoint3D, Config&gt; + PrimitiveData&lt;V&gt;,</span><br><span class="line">  T: PrimitiveTopology&lt;V, Primitive = P&gt;,</span><br><span class="line">  G: AbstractGeometry&lt;Vertex = V, Topology = T&gt;,</span><br><span class="line">  <span class="keyword">for</span>&lt;<span class="symbol">'b</span>&gt; AbstractPrimitiveIter&lt;<span class="symbol">'b</span>, G&gt;: <span class="built_in">IntoIterator</span>&lt;Item = T::Primitive&gt;,</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">intersect</span></span>(&amp;<span class="keyword">self</span>, geometry: &amp;AbstractGeometryRef&lt;<span class="symbol">'a</span>, G&gt;, conf: &amp;Config) -&gt; IntersectionList3D &#123;</span><br><span class="line">    IntersectionList3D(</span><br><span class="line">      geometry</span><br><span class="line">        .primitive_iter()</span><br><span class="line">        .into_iter()</span><br><span class="line">        .filter_map(|p| p.intersect(<span class="keyword">self</span>, conf).<span class="number">0</span>)</span><br><span class="line">        .collect(),</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个实现等价于threejs分散在各个class内的raycast方法，在我们的抽象体系下只有短短这么一点。从类型上可以看到，除了为了支持AbstractGeometry的trait约束，我只要要求图元实现了和光线相交的trait，那么任意满足这组约束的几何就可以直接支持这个行为。而由于完全是静态的trait的分发，编译时rust会根据你实际使用到的所有可能的图元/顶点/拓扑/几何/类型的组合生成代码，然后再层层内联高度优化，而这些代码原先都是手写的，科学技术真是第一生产力。</p><p>通用渲染用的mesh几何数据的实现还在开发中，实际实现可参考：<br><a href="https://github.com/mikialex/rendiation/tree/master/mesh-buffer/src/geometry" target="_blank" rel="noopener">https://github.com/mikialex/rendiation/tree/master/mesh-buffer/src/geometry</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在对rust的trait， generics等概念有了一定理解后，我尝试集中编写一些三维几何数据的容器类作为渲染引擎的基础库。&lt;/p&gt;&lt;p&gt;如果你对three.js比较了解的话，我这里做的，其实就是使用rust编写Geometry，BufferGeometry等容器类，th
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RenderGraph review</title>
    <link href="http://yoursite.com/2020/08/14/render-graph-2020/"/>
    <id>http://yoursite.com/2020/08/14/render-graph-2020/</id>
    <published>2020-08-13T16:00:00.000Z</published>
    <updated>2020-09-09T11:45:01.077Z</updated>
    
    <content type="html"><![CDATA[<p>一个图形框架主要分为两部分，描述画什么以及怎么画，前者往往抽象为场景，而后者就是我们要讨论的主题。</p><p>我们目前见到的绝大多数渲染框架，都主要集中在资源的角度来进行抽象，比如geometry， material，这些抽象为库的使用者减少和抹去了管理创建资源，以及渲染的实现的负担。但是这些库并没有在如何组织渲染流程上提供太多的抽象。在面对复杂的后处理，多个pass间的依赖关系时，这些依赖一般都是手工维护，rendertarget的复用也是需要手工维护，当这些依赖关系需要由多项配置决定时，整个事情就非常难做了，以至于变成工程上不可能的事情。</p><p>去年我在artgl里通过一些业余实践实现了一套渲染流程上的框架，称之为rendergraph： 用户通过一套声明式的api构建pass/target依赖的有向无环图，框架完成依赖解析，fbo重用，等工作。最后可以说解决的非常干净漂亮。这套体系经过定制修改目前已经集成于实际工程项目，一举解决了诸多维护性上的问题。</p><p>现在回想整个设计过程和解决方案，给我带来几个关键的认识：</p><h3 id="尽可能从data-flow的角度思考解决问题，而不是传统的control-flow。"><a href="#尽可能从data-flow的角度思考解决问题，而不是传统的control-flow。" class="headerlink" title="尽可能从data flow的角度思考解决问题，而不是传统的control flow。"></a>尽可能从data flow的角度思考解决问题，而不是传统的control flow。</h3><p>如果没有graph，所有的数据依赖处理，都是分散在各个pass的类里，由大量的配合外部配置项的if else所决定，通过控制流来决定一步一步该做什么，控制流的代码是写死的，写死在各个类的方法里。</p><p>在graph下，核心其实变成了数据流，api直接描述数据间的依赖关系，框架来组织什么数据在什么时候需要给谁。而原本的控制流即实际的依赖关系，或者说流程，是通过运行时计算出的，而不是靠控制流写死在代码里。</p><h3 id="流程即是数据，数据即是流程"><a href="#流程即是数据，数据即是流程" class="headerlink" title="流程即是数据，数据即是流程"></a>流程即是数据，数据即是流程</h3><p>这个基本上就是代码即是数据，数据即是代码的一个小的体现。</p><p>前面说到 原本的控制流即实际的依赖关系，或者说流程，是通过运行时计算出的。这个计算结果简单说比如就是拓扑排序的结果，这个结果就包含了这个流程完整的内容，不多不少。就是一个array，就是数据。这个数据，这个实际的流程，我们也是直接cache的。对于任意一个能影响图结构的配置项，直接计算出流程或者从cache得到。将代码/算法/流程直接变成数据。</p><p>理论上如果我们知道会用到的配置组合，那么从这个数据直接生成流程的代码也是可行的，不过没什么意义。只是计算到底是编译期还是运行期的问题。</p><p>没有graph，执行流程是写死在代码里超集，通过配置和控制流代码来决定哪些部分真的要执行，直接造成了实现上的灾难</p><h3 id="graph这个设计是通用做法，正常做法"><a href="#graph这个设计是通用做法，正常做法" class="headerlink" title="graph这个设计是通用做法，正常做法"></a>graph这个设计是通用做法，正常做法</h3><p>我后来了解到很多桌面端的引擎，都采取了graph结构。我觉得他们不得不用，为什么，因为比如vulkan，要是不用图我觉得代码就没法写了。vulkan 是要你自己完全控制各个pass间的依赖的，这包括但不仅限于你要在target和pass依赖的点，各种数据的依赖点自己加semaphore，内存屏障，各种同步源语，不然你根本不知道什么时候gpu真正执行到哪个pass，不知道什么时候可以拿到正确的数据。</p><p>事实上，在有的游戏引擎中，整个流程，不仅是渲染部分也使用了graph的架构，rendergraph，解决的是渲染数据流的问题，而相同的思想用来解决gameplay部分的数据依赖完全是没有问题的，整个游戏引擎，整个世界更新逻辑就是一个超大的graph，渲染只是其中一部分。</p><h3 id="基于graph，我们还能做更多优化"><a href="#基于graph，我们还能做更多优化" class="headerlink" title="基于graph，我们还能做更多优化"></a>基于graph，我们还能做更多优化</h3><p>为了解决依赖问题，拓扑排序就够了。但是有了graph我们能做更多事情。</p><p>就 fbo 重用来说，目前很简单就是按需重用，没有主动优化。什么意思呢：一个graph，满足拓扑顺序的结果有很多，如果真的要好的fbo重用，我们应该找到这个解的集合中fbo并行量最小的一个。所以fbo重用就变成了一个图优化的问题。</p><p>又比如，现在对于每个effect，假设需要depth，那么我自己做图构建的时候，还是要手工的重用depth对应pass的node，比如从外层传入这个node。ok，事情变复杂了以后我怎么保证我能靠人肉充分复用某些pass的计算呢。从理想的角度，我希望我不要考虑这些事情，让框架自动找到可复用的pass计算。这种重用本质上是流程的重用，而本质上是另一个图优化的问题，如何识别和复用图中的子结构的问题。</p><p>那么state切换方面的优化是不是图的问题呢，我想过其实也使得，不过这个是scenegraph，就不展开了。</p><h3 id="Rendering-engines-are-becoming-compilers"><a href="#Rendering-engines-are-becoming-compilers" class="headerlink" title="Rendering engines are becoming compilers"></a>Rendering engines are becoming compilers</h3><p>比如你手工的提取出可以复用的depth pass计算，和本质上你在一个函数里手工提出重复计算并无不同。而事实上编译器的确是能优化重复计算的，优化重复计算也是把代码转化成计算图解决图优化的问题。</p><p>如果说整个3d框架，渲染引擎，流程上本质就是生成，优化，执行一个数据流图，那和一个compiler后端有什么区别呢？</p><p>我现在搞了套很漂亮的api来做图构建，本质上也太低级，那似乎搞一套dsl也是没啥问题的，正好对应compiler前端，设计一套更高层次的流程描述出来？</p><p>其实如果将renderengine视为compiler的，那不是那种静态的AOT的，而是JIT的，意思是对于执行结果，其实是有feedback的，既然有feedback，那就可以做优化的。我认为render engine as complier最终极的方向，就是compiler能根据实际的场景数据执行情况，分析出场景特点，分析出绘制瓶颈，动态实现各种优化行为。比如配合其他子系统比如场景，动态优化调整输入。配合降级体系，自动挑选最优的效果降级方案，这种降级不是关掉某个pass那么简单，而是能实时获得底层gpu情况，精确的调整某些sample count，size这类。</p><p>当然这个脑洞目前很大，工程上做出来也很有挑战，我相信一些成熟引擎已经开始这个方向的转变了，很有意思。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个图形框架主要分为两部分，描述画什么以及怎么画，前者往往抽象为场景，而后者就是我们要讨论的主题。&lt;/p&gt;&lt;p&gt;我们目前见到的绝大多数渲染框架，都主要集中在资源的角度来进行抽象，比如geometry， material，这些抽象为库的使用者减少和抹去了管理创建资源，以及渲染
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>跨平台着色组件实现思考</title>
    <link href="http://yoursite.com/2020/06/25/shading-component/"/>
    <id>http://yoursite.com/2020/06/25/shading-component/</id>
    <published>2020-06-24T16:00:00.000Z</published>
    <updated>2020-08-23T07:00:50.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>去年在artgl中实践了一种以着色组件(Shading component)的材质系统实现，用户通过编写独立的组件并组合这些组件形成完整的shader材质， 每个组件持有自己的材质数据，实现uniform等输入数据的上传，实现shader着色逻辑的注入。 今年年中，就是现在，我在做rendiation的跨平台渲染的场景描述层实现，其中材质的中间层系统被称之为着色抽象层，我认为基于着色组件的材质系统应该是一个非常好的材质框架设计方向，所以我尝试在rust中复刻及重新思考和打磨这一块的API设计，作为rendiation的着色抽象层的框架实现。</p><p>现在我还拿不出一个合理的令人兴奋的设计上的大幅优化方案，但是其中的思考值得记录</p><h3 id="显式计算图还是着色语言？"><a href="#显式计算图还是着色语言？" class="headerlink" title="显式计算图还是着色语言？"></a>显式计算图还是着色语言？</h3><p>在编写跨平台渲染引擎时，由于各个平台使用的着色语言不同，所以这一块是个麻烦。</p><p>第一种做法是自己设计一套着色语言，比如unity，自己再把它编译到各个不同平台的着色语言上。</p><p>第二种是自己使用任意的语言，但是统一编译到底层中间格式，比如spirv，然后只要支持spirv的平台就都可运行。</p><p>第三种是直接将引擎开发语言或其子集直接编译到各个不同平台的着色语言或中间格式。</p><p>第四种是用引擎开发语言实现一套计算图表示，使用开发语言完成计算过程描述，然后编译到各个不同平台的着色语言上。</p><p>这四种各有优劣：</p><p>第一种做法，需要自己设计语言，实现编译器前端和各个target的emitter，实现难度高成本大。用户学习成本高。但是毕竟语言都是自己发明的，定制能力强，很酷。</p><p>第二种做法，不是所有平台都有spirv的支持的，（看向webgl）。而各个语言到spirv等于一堆编译器前端，虽然都是有现成的，但是你只能编译期就确定shader，失去了运行时动态新加shader的能力，除非运行时把你要用的语言的编译器带上，局限大，通用性不佳。 好处就是实现简单。</p><p>第三种做法，额外好处1是不想引入新语言的学习成本，2是希望能复用引擎本身某些代码，另外实现上会容易一些（一般语言都会提供自己的parser）。但是也是局限性的问题，肯定是子集，但是万一有不能表达的东西呢？万一你本身语言就是没类型的呢（看向js）。</p><p>前三种都是基于着色语言的方案，第四种是计算图的方案。</p><p>我在artgl中，做的就是一个简单的计算图方案， 着色组件的对shader逻辑的扩展方式是直接对计算图进行扩展和修改，最后将图编译成shader。我曾经和我的室友开玩笑说我是搞不定编译器只能被迫做计算图，因为本质上，编译器从字符串搞出语法树，后一步的代码生成和优化也是转计算图的。但是后来我一想觉得事情没这么简单，计算图的方案虽然看起来不是那么高明但可能有额外的优势。</p><p>相比显示的计算图描述，语言方案本质上是计算图的字符串隐式描述，从语言得到计算图的实现成本是很高的（编译器前端+图生成）。 而为什么我们需要计算图呢，有了计算图能做什么呢，在我看来计算图才真的是核心。如果引擎层搞不到计算图，那么就很难将着色过程组件化，材质框架事实上是无从谈起的。 着色过程组件化中，每一个组件肯定是要可以依赖其他组件的输入的，这个依赖本质上是外部的输入或者某个计算的结果，除了计算图，没有其他更好的对这些依赖进行描述和定位的方式了。想象一下假设我们没有显式的计算图，而是shader的字符串代码，我们就很难描述我们这一段代码具体依赖另一段代码的中某个变量的依赖关系，难道用变量名吗？</p><p>所以我对最佳方案的思考是hybrid的：</p><p>1 用户可以在封闭的单元（atomic？）来使用任意的着色语言进行编写，比如一个function，input group，这个封闭单元的概念是单元的输入输出是确定的和暴露的，外部不会依赖单元的内部内容。<br>2 引擎层能将单元parse成计算图，得到单元内部对外部单元依赖<br>3 用户可以组装单元形成子图形成新的单元，或者直接完成计算图组织</p><p>几个设计点：<br>1 用户可以有选择/发明 着色语言的自由，但是要能转成引擎内的计算图表示<br>2 引擎内的计算图可以自由反向输出着色语言，是IR<br>3 计算图只本质上描述计算的依赖关系，本质只是对计算单元做link，不设计具体着色能力/feature/语言设计<br>4 材质框架本质基于计算图依赖/link的能力完成组件化，组合能力，重用，抽象</p><h3 id="shader是应该编译期生成还是运行期生成？"><a href="#shader是应该编译期生成还是运行期生成？" class="headerlink" title="shader是应该编译期生成还是运行期生成？"></a>shader是应该编译期生成还是运行期生成？</h3><p>这里的shader指最终交给驱动的东西，可以是spirv，也可是代码。一种看法认为这些东西属于产品的asset，相当于图片等资源，是编译构建时就应该制作完成的，而也不乏能看到实现是所有shader全部是运行时生成的情况。</p><p>运行时生成是必不可少的能力，如果缺少这个则无法支持用户自定义着色。但大部分或者全部的运行时生成一方面会引入额外的overhead，（虽然生成pso开销会更高），另一方面， 我新看到的重要一点是纯的依赖运行时生成的方法不太稳定可靠，说明白就是缺少编译期的检查，使得shader生成逻辑完全依赖外部的运行时测试（虽然事实上这个是起码要有的事情）。</p><p>所以我概括为着色框架最好能支持在编译期支持有限的检查机制以防止运行时shader编译失败的可能，这个是为生产力上锦上添花。</p><p>实现这一特性，两种approach，工程性的和技术性的。工程性的很简单，本质就是测试工作，这个不用讨论，而技术性的方案倒是有些意思。</p><p>回到上一个topic，假设你是全盘使用语言描述，那么本质上你实现这个语言的language server就能完整解决。假设使用的是全盘计算图的方案，那么就很有挑战了。如果框架的语言是动态语言，那么这个需求就搞不定了。如果是静态语言，也非常难做。要实现这一功能，核心是要为每一个node做输出输出的类型标记，这个直接导致写起来非常不ergonomic，更麻烦的是这些node很难使用统一容器存储，不然又涉及不安全的类型转化。这个目前做了一些尝试并没有太好的进展。退而求其次，每一个着色组件是存在外部依赖的，但是这个外部依赖能否做静态类型检查呢？这个我的确尝试出了一个方案，但是也不ergonomic。主要做法类似于Iterator的思想：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BaseShading</span></span> &#123;</span><br><span class="line">  graph: ShaderGraph,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">PositionAttributeInput</span></span>&lt;T&gt; &#123;</span><br><span class="line">  before: T,</span><br><span class="line">  attribute_input_node: Node,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; PositionAttributeInput&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(before: T) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">    todo!()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">MVPTransformInput</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">position</span></span>(&amp;<span class="keyword">self</span>) -&gt; Node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// deref into inner type</span></span><br><span class="line"><span class="keyword">impl</span> MVPTransformInput <span class="keyword">for</span> PositionAttributeInput&lt;BaseShading&gt;&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">position</span></span>(&amp;<span class="keyword">self</span>) -&gt; Node &#123;</span><br><span class="line">        todo!()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">MVPTransform</span></span>&lt;T: MVPTransformInput&gt; &#123;</span><br><span class="line">  before: T,</span><br><span class="line">  mvp_uniform: Node,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: MVPTransformInput&gt; MVPTransform&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(before: <span class="keyword">impl</span> MVPTransformInput) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">    todo!()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> base = BaseShading::new();</span><br><span class="line">  <span class="keyword">let</span> base_with_position = PositionAttributeInput::new(base);</span><br><span class="line">  <span class="keyword">let</span> mvp_trans_formed = MVPTransform::new(base_with_position);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种做法其实是使用泛型容器反复嵌套来合成一个struct，每一个容器都是一个component，component的节点依赖使用trait定义，用户再通过impl trait的方式实现依赖链接。这个解法其实已经非常好了，但是不ergonomic的原因在于如果着色组件切分很细，那么嵌套会非常多，实现链接的代码会写的很丑陋，类型也会很长。</p><p>我们其实需要的是一种做法，就是能在编译期随机组合几个struct成为新的struct，这种需求估计要使用marco来解。我暂时没想到什么写法能够糅合指定任意的class，但是退而求其次还是可以搞泛型是数组的容器：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Combine2</span></span>&lt;A, B&gt;&#123;...&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Combine3</span></span>&lt;A, B, C&gt;&#123;...&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Combine4</span></span>&lt;A, B, C, D&gt;&#123;...&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其中链接的约束可以这样搞？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Combine4</span></span>&lt;A, B, C, D&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">B: Link&lt;B, (&amp;A)&gt;,</span><br><span class="line">C: Link&lt;C, (&amp;A, &amp;B)&gt;,</span><br><span class="line">D: Link&lt;D, (&amp;A, &amp;B, &amp;C)&gt;</span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure><p>如果要涉及到实际shader生成和编译，那似乎要依赖const function等编译期计算相关的东西了/</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;去年在artgl中实践了一种以着色组件(Shading component)的材质系统实现，用户通过编写独立的组件并组合这些组件形成完整的s
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>QEM 网格模型简化算法</title>
    <link href="http://yoursite.com/2020/04/04/mesh-simplification/"/>
    <id>http://yoursite.com/2020/04/04/mesh-simplification/</id>
    <published>2020-04-03T16:00:00.000Z</published>
    <updated>2020-08-23T07:00:50.628Z</updated>
    
    <content type="html"><![CDATA[<p>QEM 是一种常见和流行的网格简化算法。在阅读了一些源码和文章后特此笔记。</p><p>网格的简化是一个复杂的问题，与其全局的想怎么去简化不如从细节入手分而治之。从人的角度而言，手工简化其实也是针对基本图元的简单操作，即每次从网格上删除一个基本图元，一直迭代至满足要求。具体方法有：</p><p>顶点删除：从网格上一次移除一个顶点。移除后，网格上该顶点相关的面被删除，形成新的洞，再重新对这个洞三角化来补面。</p><p>边删除：从网格上一次移除一条边，塌陷这条边的两个顶点为一个。塌陷后再重新连接其他的面。</p><p>顶点合并：从网格上一次选择两个顶点进行塌陷，这两个顶点不一定需要构成边。塌陷后再重新连接其他的面。</p><p>QEM的方法适用于边删除和顶点合并的两种情况：都是把两个顶点合并成一个。后续只是连接性重建的问题。我的理解是边删除的方法能避免拓扑关系被破坏，而有些场景下，拓扑关系不是很重要，比如单纯用于渲染的mesh。而使用边删除因为拓扑的约束所以简模效果没有单纯的顶点合并来的理想。</p><h2 id="什么是QEM"><a href="#什么是QEM" class="headerlink" title="什么是QEM"></a>什么是QEM</h2><p>QEM是 Quadric Error Metrics的缩写。我先不直接解释这个东西是什么，先回归我们面对的具体问题：我们现在要从一个mesh上删除一条边。我们要选择哪一条边？我们选择的这条边，合并后的新顶点位置是什么？</p><p>我们其实只需要考虑后一个问题，因为我们在某个边上能找到的最佳点的质量就决定了这条边的质量，有了所有边的质量我们只需找到最好的就可以了，这就是边的选择的解法。</p><p>既然是网格简化，所以我们要尽可能保证每一步简化和原网格形状差别不大。考虑我们具体的操作是一个图元，所以这是个非常局部性的问题：当我们把一条边从网格上塌陷掉，在形状上的影响就是这条边原先所在的几个面的换成了新的几个面。具体而言就是：当合并前，我们有原先的两个顶点的位置，以及这些顶点周围的若干三角面。当合并后，我们有新的顶点位置，以及新的顶点周围若干三角面。</p><p>QEM方法的原则：<strong>就是合并后的这个顶点，应当到原先合并前两个顶点周围若干三角形所在平面的距离的平方和最小</strong>。有了这个原则，我们就可以计算给定网格上一条边，这个最优点在哪里，以及它有多优秀。</p><p>“到原先合并前两个顶点周围若干三角形所在平面的距离的平方和”，其实就是个函数 <code>d = f(x, y, z)</code>。这个函数在哪个xyz坐标取到最小值，这个坐标就是最优点的位置，这个最小值就是优秀的程度。</p><p>相信讲到这里，网格简化问题已经被说透彻了。而QEM本质上只是解决上面这个问题的数学工具。</p><p>对于一个三角面，其所在平面的方程有 <code>ax + by + cz + d = 0</code>。不难记得高中的几何知识：对于这种平面方程, 空间中任意一点到这个平面的距离就是直接把xyz代入就是，那么距离的平方的函数就是 <code>d = (ax + by + cz + d)^2</code>。那么所有平面的距离平方和就是把所有三角面的这个函数相加就是。然后再求个最小值就ok了。</p><p>Quadric 在数学上叫<a href="https://www.zhihu.com/question/38902714" target="_blank" rel="noopener">二次型</a>。 <code>d = (ax + by + cz + d)^2</code>就是个二次型，所以我们就有展开后写成二次型矩阵的版本：</p><p><img src="/images/mesh-simplification/matrix.png" alt></p><p>一旦这么写了以后，我们原先的这些平方和的函数，就变成的一堆矩阵的和，所以，对于某个顶点周围的三角面，我们只要用这个二次型矩阵就能表达空间中任一点到这些三角面距离平方和的函数。而这个矩阵，就是这个顶点的QEM。而对于我们上面讲到的“到原先合并前两个顶点周围若干三角形所在平面的距离的平方和”，那就是两个顶点的QEM矩阵和。</p><p>我的理解是用QEM存粹是工程上的考量，即便我不懂什么Quadric，我实际上也会实现上把平方和展开然后逐项存储，逐项求和。更有种用矩阵是为了简化运算的表示的意味。</p><p>不过在求最小值方面的确是不清楚不用二次型矩阵有什么更好的办法。</p><p><img src="/images/mesh-simplification/matrix2.png" alt></p><p>我不是很懂矩阵的微积分, 这个求导的推导需要再看看其他资料。只不过这么搞答案立刻就有。</p><h2 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a>流程梳理</h2><p>1计算mesh上每一顶点的QEM。</p><p>2对于每一个可以合法坍缩的顶点对/边，根据QEM计算最佳坍缩位置和最佳坍缩位置下的平方和最小值作为error</p><p>3通过error最小堆来维护可以合法坍缩的顶点对/边</p><p>4反复迭代从堆中pop出最小的error边进行坍缩，并更新所有收影响边/点/新边的QEM和error以及堆，直到符合简化量预期</p><h2 id="Links"><a href="#Links" class="headerlink" title="Links"></a>Links</h2><p>Paper</p><p><a href="https://www.cs.cmu.edu/~./garland/Papers/quadrics.pdf" target="_blank" rel="noopener">https://www.cs.cmu.edu/~./garland/Papers/quadrics.pdf</a></p><p>开源参考实现：</p><p><a href="https://github.com/sp4cerat/Fast-Quadric-Mesh-Simplification/blob/master/src.cmd/Simplify.h" target="_blank" rel="noopener">https://github.com/sp4cerat/Fast-Quadric-Mesh-Simplification/blob/master/src.cmd/Simplify.h</a></p><p><a href="https://github.com/hhoppe/Mesh-processing-library/blob/master/MeshSimplify/MeshSimplify.cpp" target="_blank" rel="noopener">https://github.com/hhoppe/Mesh-processing-library/blob/master/MeshSimplify/MeshSimplify.cpp</a></p><p>二次型，数学相关</p><p><a href="https://www.zhihu.com/question/38902714" target="_blank" rel="noopener">https://www.zhihu.com/question/38902714</a></p><p><a href="https://www.zhihu.com/question/22455493" target="_blank" rel="noopener">https://www.zhihu.com/question/22455493</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;QEM 是一种常见和流行的网格简化算法。在阅读了一些源码和文章后特此笔记。&lt;/p&gt;&lt;p&gt;网格的简化是一个复杂的问题，与其全局的想怎么去简化不如从细节入手分而治之。从人的角度而言，手工简化其实也是针对基本图元的简单操作，即每次从网格上删除一个基本图元，一直迭代至满足要求。具体
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Side project retro in 2019 and future plan</title>
    <link href="http://yoursite.com/2019/12/28/side-project-in-2019/"/>
    <id>http://yoursite.com/2019/12/28/side-project-in-2019/</id>
    <published>2019-12-27T16:00:00.000Z</published>
    <updated>2020-08-23T07:00:50.629Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/side-project-in-2019/github.png" style="width:100%"></p><h2 id="artgl"><a href="#artgl" class="headerlink" title="artgl"></a>artgl</h2><p>今年的side project主要是这个 <a href="https://github.com/mikialex/artgl" target="_blank" rel="noopener">https://github.com/mikialex/artgl</a> 这个项目基本占据了我今年主要的业余编程时间。 <del>我写坑过许多项目，从目前的发展来看，ARTGL应该是不会坑掉了。</del> 今年完成了主要的api设计和开发，主要的关于场景和渲染流程构建方面的API已经成熟。我对目前的整体架构还是较为满意的：经过年底的一番调整，目前整个repo已经完成了模块化的迁移，不同的功能被分割在不同的package里，并使用lerna进行管理。在模块化的迁移中，为了拆解不必要的依赖和耦合关系，做出了不少设计上的变动。这些变动提升了架构上的质量。现在整个项目中，每一个package，每一个类的的职责，界限，已经非常明确，干净。</p><p>详细来说：</p><ul><li><p>实现了一个独立的WebGL封装库： @artgl/webgl。 包装原始api，对webgl状态切换做diff，记录，调试，以及提供了功能级别的webgl1/2的自动降级（比如使用此layer提供的instance draw/VAO，可以无缝切换webgl1/2）。独立性非常高，可以被用于任何其他的项目</p></li><li><p>数学库，@artgl/math, 这里主要是three的数学库，ts化。但还有很多没有完成迁移，基本上是需要什么迁移什么。</p></li><li><p>utils， @artgl/shared， 工具util</p></li><li><p>@artgl/shader-graph, a shader linker。主要是用户可以包装任意glsl字符串函数，我们会简单提取输入输出，以节点的形式，抽象shader中的计算。用户可以使用builder style的API，构建一个完整shader的计算图，两个计算图合在一起，配合一些特殊的IO节点，便可以描述一个program的所有信息。shader graph提供面向 @artgl/webgl的完整program的代码生成。</p></li><li><p>@artgl/core 核心模块。 提供了engine的实现，renderable的抽象。其中renderable中描述shading方式的部分使用的就是 @artgl/shader-graph。当然还引入了构筑于此的更上层的概念，比如shader graph的装饰器，和shader graph uniform的提供器。这部分的抽象我个人认为比较精彩，甚至light， camera等抽象是构建于次的。 当然除了shading，还有其他的诸如geometry。这一模块基本上定义了在artgl里，如何描述一个绘制的物体，以及实际上去进行绘制的实现。</p></li><li><p>@artgl/lib-geometry 和 @artgl/lib-shading 主要是核心实现和库实现的分离。前者放各种geometry， 后者放各种shading decorator，以及glsl片段。</p></li><li><p>@artgl/scene-graph。 当然就是场景图了，将各种renderable以层次结构组合在一起，实现典型的场景整体描述。初次之外还有IO的一些东西，I可以有各种controller loader，O可以有各种exporter。因为现在就没写几种，就没有必要再独立成包了。</p></li><li><p>@artgl/render-graph。 同样是builder style的API，以声明式的方式构建后处理pass graph。</p></li></ul><p>除了这些主要模块之外，还有若干实际应用测试分别是：</p><ul><li><p>@artgl/example， 会有各种小example，兼顾回归测试，可能可以以后codegen出文档，网站。</p></li><li><p>@artgl/viewer， 会是一个比较完善的场景编辑器。</p></li></ul><p>再除了这些，还有些高度实验性质的部分：</p><ul><li><p>wasm-scene， 测试和发掘 Webassembly Rust 潜力，包括框架集成的可能性。</p></li><li><p>parser, 目前有个简单的lr1 parser，主要是想解决shading language在框架集成方面的问题，以及更多可能性的探索。</p></li></ul><h3 id="目前的不足"><a href="#目前的不足" class="headerlink" title="目前的不足"></a>目前的不足</h3><h4 id="性能一般"><a href="#性能一般" class="headerlink" title="性能一般"></a>性能一般</h4><p>目前简单的benchmark下来是不如three的。主要可能是这些原因： 1 过于灵活和丰富的抽象，这导致在three里功能是用代码写死的，直接被JIT了，而我这里要用代码自己走各种数据结构。 2 使用了不利于JIT的特性，在chrome下某些情况相较于three可能慢一倍，然而去fireFox，这个差距就远远没有这么多，至于为什么，那就很难说得清了，总之就是没有走到什么fast path上。 3 细节上没有使用高性能js的最佳实践，比如我就是要用instance of，而不是硬判断标志属性，这样ts会立刻收窄类型。 又比如我没有为了性能而特意替换foreach为普通循环，这些其实都是影响性能表现的。</p><h4 id="测试和用例不足，-完善程度低"><a href="#测试和用例不足，-完善程度低" class="headerlink" title="测试和用例不足， 完善程度低"></a>测试和用例不足， 完善程度低</h4><p>由于时间精力有限的原因，几乎没有什么单元测试，毕竟没法全职搞这个。example太少，不利于找到设计上的缺陷。搜索一下todo，就知道在各个角落都有各种case没有处理全，有些甚至涉及基本功能。只要我自己example没有写到那里我就不会补的那种。其实也主要是上述原因。</p><hr><h3 id="2020-计划"><a href="#2020-计划" class="headerlink" title="2020 计划"></a>2020 计划</h3><p>我最早的考虑是整个项目用rust/wasm 重写，以及first class WebGPU支持。后来经过具体的一番操作和研究，我认为这个几乎是另一个项目了。但是，我依然觉得如果提供js/ts良好的支持，依然是有价值的。这一点比较矛盾。wasm之前也是调研许久，只不过是scope的问题。最早是计划用于加速场景树drawcall生成的。后来发现render的js也很慢，所以engine，renderable也得做进去。 那么webgl也没必要是ts了，所以需要全部重写。</p><p>目前的考虑是，artgl会依然是一个ts项目，不会有任何wasm的东西存在。目前只会维持一个对渲染最基本的东西的轻量级抽象，而不再提供更多的实质性实现。简而言之，如果没有实际应用的话，我在明年不会有太多精力投入到这个项目中来，短期之内不会再开发新的功能。</p><h2 id="rendiation"><a href="#rendiation" class="headerlink" title="rendiation"></a>rendiation</h2><p>取而代之，明年主要focus的side project会是这个 <a href="https://github.com/mikialex/rendiation" target="_blank" rel="noopener">https://github.com/mikialex/rendiation</a>。这会是一个跨平台的rust的图形渲染库，后端是WebGPU，会支持所有常用桌面端移动端平台以及web。</p><p>语言上是的，我现在决定all in rust了。选择一门语言是非常重要的，就像决定在哪里买房子一样。1，我彻底受够了脚本语言的低效，2，我需要极致的性能，所以任何GC的语言都再见了，那么似乎只有c/c++/rust三者可选。经过我一年多的观察和学习，我几乎认定，如果我之后要做特别care性能的项目，都会尽可能的选择rust。我暂时不想写很多内容安利这门语言，懂的人自然懂。 另一个考虑是 rust的跨平台图形的基础设施还不错，即便不完善也是蓬勃发展，特别是会主要使用到的wgpu这个crate，会直接作为firefox自己的webgpu实现。在后端支持上，选择webgpu是为了在使用最现代的图形API且保持最大化的跨平台支持。</p><p>这个项目很大程度更像是在重做我今年做的东西，只不过将会有<strong>极致的性能</strong>，将会使用<strong>最先进的图形API</strong>，将具备<strong>卓越的跨平台能力</strong>。我以后的任何业务图形积累都会使用这个作为底层平台，比如GUI，可视化，等等。</p><p>当然，这其中会遇到很大的挑战，一方面主要是这应该是比较底层的体验，关心内存，关心缓存命中，和编译器做斗争，摸索dod（是的oop不是很work），全新的工具链，等等。另一方面是适应新一代的图形API的挑战，各种耳目一新的概念。明年这个时候，不求能有什么成果，只要是能沉下心琢磨一番，想必也是收获良多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/side-project-in-2019/github.png&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;artgl&quot;&gt;&lt;a href=&quot;#artgl&quot; class=&quot;headerlink&quot; title=&quot;artgl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>FBO reuse in artgl rendergraph</title>
    <link href="http://yoursite.com/2019/08/11/fbo-reuse-in-rendergraph-artgl/"/>
    <id>http://yoursite.com/2019/08/11/fbo-reuse-in-rendergraph-artgl/</id>
    <published>2019-08-10T16:00:00.000Z</published>
    <updated>2020-08-23T07:00:50.627Z</updated>
    
    <content type="html"><![CDATA[<p>这周末做了基于RenderGraph的Framebuffer重用。借此机会撰写一些关于reuse fbo的设计。</p><p>当我们在写后处理的时候，我们会写很多pass， 有的pass单纯的使用场景的shader画场景，更多的使用特殊的shader覆盖场景的shader进行绘制，有的pass处理之前pass绘制的结果，还有的pass处理多个之前pass的结果。你构建整个后处理的工作，事实上就是给这些pass分配绘制的target，并把这些target再提供给后续依赖的pass，来组合这些pass得到最终的屏幕效果。</p><p>很显然，整个后处理流程可以使用有向无环图进行抽象， RenderGraph就是我在artgl里完成的实现。</p><p>记得当时在我从前端转职到图形的时候，我最大的感慨是，没有一个顺手的webgl框架可用，对于之前vue什么写惯了的前端来说，组件化的模块化的抽象是深入人心的。市面上很难找到一个webgl框架，提供合理的针对渲染这个行为的模块化抽象。这大概是最早的一些想法。</p><p>后来，公司的项目里开始有一些后处理要做，这些后处理流程越来越多，充斥着大量非常丑陋的实现。于是我看不下去了，设计了一个graph的系统，通过声明式的api模块化后处理管线，希望能重构公司项目里整个后处理流程，我保证说整个后处理管线代码量下降一半，开发效率翻倍，但是我并没有得到机会做这个事情。于是乎我只能在artgl里做了。</p><p>为什么这周末突然做了fbo重用的实现呢？因为上周同事反馈移动端因为fbo大量申请导致崩溃的问题，这显然原因就是fbo没有复用的后果。我不敢想象在公司的项目里，没有graph的抽象，去人肉分辨出用到的十个fbo，谁在什么时候可以释放，谁可以给谁用，和动态配置如何配合，这种代码实在是不敢写，也没法写。</p><p>而这时我想到正因为artgl做了graph的后处理，整个graph，这个pass依赖哪个pass的结果，那个pass的结果在哪一步再也不需要保留内容了，这些优化信息全部可以自动收集，所以基于graph做fbo的自动reuse是很简单的事情。</p><p>如果所有fbo都是一个格式和大小，那么大概是这个效果：</p><p><img src="/images/fbo-reuse-in-rendergraph-artgl/fbo-reuse.png" style="width:100%;max-height:600px"></p><p>具体的做法是三部分：</p><p>1 每个 renderTargetNode 不再有一一对应的fbo，这些fbo也不在图构建的时候直接申请，取而代之，向一个fbo pool请求，fbo pool会根据 renderTargetNode 上的格式信息，比如长宽等，生成formatKey字符串，pool持有一个formatKey -&gt; fbo[] 的map，取一个就pop一个，如果没有符合格式的直接向gl申请，这是取的过程。还有一个还回来的接口表示这个fbo我用完了，上面的内容后续没有依赖了，可以继续重用， push到对应的map里的array里。</p><p>2 每个renderPass不再向对应的output target和dependency的nodes索取fbo，而是 rendergraph的执行器，effectComposer， 在执行pass前完成相应的工作。 composer自己会持有一份targetName到fbo的map， 表示当前哪些fbo的内容需要keep。composer会在renderPass执行前，获取所需的fbo，如果这个是之前keep住的，那么就取keep的fbo，如果没有就问pool申请，并在pass结束后，按需归还不再使用的fbo。</p><p>3 composer需要知道这个pass结束后，哪些kept的fbo可以return给pool，那么在构建图的时候，拓扑排序完，得到的renderPass array，需要计算一个droplist array， 就是走到哪一个pass，哪些之前用的fbo再也不需要保留内容了。根据这个list，composer便可以实现按需归还fbo。</p><p>在某些情况下，某个pass的结果即便后续没有任何引用，依然需要一直keep住。比如temporal的ping pong buffer， 需要让这个target隔帧的进行reuse。 又比如 如果你需要某个target在render之外能支持readPixel， 那么你也需要一直keep。为了支持这种情况， renderGraph api在声明target节点时，提供了 keepContent的 getter， 默认永远返回false</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> RenderTargetDefine &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  <span class="keyword">from</span>: <span class="function"><span class="params">()</span> =&gt;</span> Nullable&lt;<span class="built_in">string</span>&gt;</span><br><span class="line">  keepContent?: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">boolean</span></span><br><span class="line">  format?: &#123;</span><br><span class="line">    pixelFormat?: PixelFormat,</span><br><span class="line">    dimensionType?: DimensionType,</span><br><span class="line">    width?: <span class="built_in">number</span>,</span><br><span class="line">    height?: <span class="built_in">number</span>,</span><br><span class="line">    enableDepthBuffer?: <span class="built_in">boolean</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是目前的带两个temporal的demo，你可以看到跨帧交替释放是如何支持的，我现在已经可以放心的继续往后叠ao的blur和glow的效果，不用担心要多出四个屏幕大小的fbo了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">graph.defineGraph(&#123;</span><br><span class="line">    renderTargets: [</span><br><span class="line">    &#123;</span><br><span class="line">        name: RenderGraph.screenRoot,</span><br><span class="line">        <span class="keyword">from</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'CopyToScreen'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">'sceneResult'</span>,</span><br><span class="line">        format: &#123;</span><br><span class="line">        enableDepthBuffer: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">from</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'SceneOrigin'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">'depthResult'</span>,</span><br><span class="line">        format: &#123;</span><br><span class="line">        enableDepthBuffer: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">from</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'Depth'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">'TAAHistoryA'</span>,</span><br><span class="line">        keepContent: <span class="function"><span class="params">()</span> =&gt;</span> !<span class="keyword">this</span>.isEvenTick,</span><br><span class="line">        <span class="keyword">from</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.isEvenTick ? <span class="literal">null</span> : <span class="string">'TAA'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">'TAAHistoryB'</span>,</span><br><span class="line">        keepContent: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.isEvenTick,</span><br><span class="line">        <span class="keyword">from</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.isEvenTick ? <span class="string">'TAA'</span> : <span class="literal">null</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">'TSSAOHistoryA'</span>,</span><br><span class="line">        keepContent: <span class="function"><span class="params">()</span> =&gt;</span> !<span class="keyword">this</span>.isEvenTick,</span><br><span class="line">        <span class="keyword">from</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.isEvenTick ? <span class="literal">null</span> : <span class="string">'TSSAO'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">'TSSAOHistoryB'</span>,</span><br><span class="line">        keepContent: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.isEvenTick,</span><br><span class="line">        <span class="keyword">from</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.isEvenTick ? <span class="string">'TSSAO'</span> : <span class="literal">null</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    ],</span><br><span class="line">    passes: [</span><br><span class="line">    &#123; <span class="comment">// general scene origin</span></span><br><span class="line">        name: <span class="string">"SceneOrigin"</span>,</span><br><span class="line">        source: [scene],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; <span class="comment">// depth</span></span><br><span class="line">        name: <span class="string">"Depth"</span>,</span><br><span class="line">        shading: <span class="keyword">this</span>.depthShader,</span><br><span class="line">        source: [scene],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; <span class="comment">// mix new render and old samples</span></span><br><span class="line">        name: <span class="string">"TAA"</span>,</span><br><span class="line">        inputs: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            sceneResult: <span class="string">"sceneResult"</span>,</span><br><span class="line">            depthResult: <span class="string">"depthResult"</span>,</span><br><span class="line">            TAAHistoryOld: <span class="keyword">this</span>.isEvenTick ? <span class="string">"TAAHistoryA"</span> : <span class="string">"TAAHistoryB"</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        shading: <span class="keyword">this</span>.taaShader,</span><br><span class="line">        source: [RenderGraph.quadSource],</span><br><span class="line">        enableColorClear: <span class="literal">false</span>,</span><br><span class="line">        beforePassExecute: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.engine.unJit();</span><br><span class="line">        <span class="keyword">const</span> VP: Matrix4 = <span class="keyword">this</span>.engine.getGlobalUniform(InnerSupportUniform.VPMatrix).value</span><br><span class="line">        <span class="keyword">this</span>.taaShading.VPMatrixInverse = <span class="keyword">this</span>.taaShading.VPMatrixInverse.getInverse(VP, <span class="literal">true</span>); <span class="comment">// TODO maybe add watch</span></span><br><span class="line">        <span class="keyword">this</span>.taaShading.sampleCount = <span class="keyword">this</span>.sampleCount;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">"TSSAO"</span>,</span><br><span class="line">        inputs: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            depthResult: <span class="string">"depthResult"</span>,</span><br><span class="line">            AOAcc: <span class="keyword">this</span>.isEvenTick ? <span class="string">"TSSAOHistoryA"</span> : <span class="string">"TSSAOHistoryB"</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        shading: <span class="keyword">this</span>.tssaoShader,</span><br><span class="line">        source: [RenderGraph.quadSource],</span><br><span class="line">        enableColorClear: <span class="literal">false</span>,</span><br><span class="line">        beforePassExecute: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> VP: Matrix4 = <span class="keyword">this</span>.engine.getGlobalUniform(InnerSupportUniform.VPMatrix).value</span><br><span class="line">        <span class="keyword">this</span>.tssaoShading.VPMatrixInverse = <span class="keyword">this</span>.tssaoShading.VPMatrixInverse.getInverse(VP, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.tssaoShading.sampleCount = <span class="keyword">this</span>.sampleCount;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; <span class="comment">// copy to screen</span></span><br><span class="line">        name: <span class="string">"CopyToScreen"</span>,</span><br><span class="line">        enableColorClear: <span class="literal">false</span>,</span><br><span class="line">        inputs: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> basic: <span class="built_in">string</span>;</span><br><span class="line">        <span class="keyword">let</span> tssao: <span class="built_in">string</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.enableTAA) &#123;</span><br><span class="line">            basic = <span class="keyword">this</span>.isEvenTick ? <span class="string">"TAAHistoryB"</span> : <span class="string">"TAAHistoryA"</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            basic = <span class="string">"sceneResult"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.enableTSSAO) &#123;</span><br><span class="line">            tssao = <span class="keyword">this</span>.isEvenTick ? <span class="string">"TSSAOHistoryB"</span> : <span class="string">"TSSAOHistoryA"</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tssao = <span class="string">"sceneResult"</span> <span class="comment">// TODO consider design a way to bind default empty source? or recompile shader?</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123; basic, tssao &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        beforePassExecute: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.composeShading.sampleCount = <span class="keyword">this</span>.sampleCount;</span><br><span class="line">        &#125;,</span><br><span class="line">        afterPassExecute: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.sampleCount++;<span class="string">``</span></span><br><span class="line">        &#125;,</span><br><span class="line">        shading: <span class="keyword">this</span>.composeShader,</span><br><span class="line">        source: [RenderGraph.quadSource],</span><br><span class="line">    &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这周末做了基于RenderGraph的Framebuffer重用。借此机会撰写一些关于reuse fbo的设计。&lt;/p&gt;&lt;p&gt;当我们在写后处理的时候，我们会写很多pass， 有的pass单纯的使用场景的shader画场景，更多的使用特殊的shader覆盖场景的shader进
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Uniform upload optimization and UBO support in Artgl</title>
    <link href="http://yoursite.com/2019/08/03/uniform-upload-design/"/>
    <id>http://yoursite.com/2019/08/03/uniform-upload-design/</id>
    <published>2019-08-02T16:00:00.000Z</published>
    <updated>2020-08-23T07:00:50.630Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要讨论和介绍一下artgl的uniform上传优化，到如何支持ubo的设计。 以及，因为ubo的优化，shadergraph的api和其概念模型的调整。</p><h2 id="Uniform-Upload"><a href="#Uniform-Upload" class="headerlink" title="Uniform Upload"></a>Uniform Upload</h2><p>一个经典的图形框架设计问题是:如何减少 uniform 上传?</p><p>在最简单的实现中，⽤户在绘制某个物体前，需要对当前uniform进⾏更新。这些通过调用gl.uniformXXX 等接⼝来完成。当⼀个场景drawcall ⾮常多，draw的东西也⽐较复杂，需要调⽤这个接⼝进行上传的次数也⾮常多，这里会造成cpu端的性能瓶颈。 即便当前gl状态机中的uniform值已经是正确的，并不需要调⽤这个接⼝进⾏更新，但如果不加判断的调⽤，经过实测，依然会造成额外成本。原因可能是浏览器的实现或者驱动的实现，需要对js端传来的数据做额外的检查和同步，但出于某些原因，并没有cache机制。所以，WebGL框架应当提供相应的cache，在上传之前，进⾏diff，如果判断出当前并不需要上传，那么直接略过。引⼊diff机制会带来额外性能成本，⼀般⽽言，这个成本会小于直接调⽤接⼝的成本，但不排除会有⼀些情况不能产⽣优化效果。</p><p>具体的diff的机制是这样的: 如果当前要draw的东⻄，没有切换过program， 且cache的新的数值，和cache的旧数值一致，则不进⾏上传。如果不一致，则copy更新cache旧的数值，进⾏上传。当切换了program，⽆论如何都要进⾏上传。</p><p>如此即可做到：不会上传不需要更新的uniform。但上⾯提到，uniform diff和copy是有成本的，can we do better? 我们能想办法避免⼀部分uniform diff的成本吗? 想想看似乎是可能。⽐如:在⼀批的绘制过程 中，camera的VP matrix 从来都没有变过，我们是知道的，所以可以不⽤diff。⼜⽐如:在⼀批的绘制过程中，light的参数假设也是没有变过的，那么我们也可以提前跳过。这些情况都可以被识别出来，然后在renderer⾥特殊处理掉。</p><p>但是，我认为这样做是糟糕的，即便three.js就是这样做的。原因是:</p><p>1 这样做破坏了引擎设计的⼀致性， 只有被你认可的case才能得到优化。</p><p>2 为了实现这样的优化，渲染逻辑和场景对象强耦合在⼀起， renderer⾥存在⼤量的针对处理这种特殊情况的代码。</p><p>3 为了实现这样的优化，在你使⽤场景的api时，你又必须非常了解这些假设，如果不了解，要么优化不会起作用，要么你期望的API调⽤却竟然没有效果。</p><p>所以， how can we do better than that? 我们应该找到⼀个通⽤的解法。如果从本质上来看这个问题，⼀般⽽⾔，判断数据变化就两种⽅案:</p><p>1 diff，这种⽅案，⽤户在修改和访问数据时，不会有成本，但是在获取数据是否变更时需要付出成本。</p><p>2 watch，这种⽅案，⽤户在修改和访问数据时，会有成本，但是在获取数据变更时没有成本。</p><p>上⽂提到的three的这种特殊的做法，其实还是diff，只不过通过约定来省略⼀部分diff。</p><p>我的解决⽅案是通过结合前⼀种做法，尽可能的减少diff的发⽣。</p><p>⼀处优化是: 假设对于⼀个vector，或者matrix，我们对这个值添加⼀个容器进行包装，实现watch机制，知道了它有没有被change，我们就可以通过diff boolean值，其实就是判断有没有change，来节约逐个数据的diff成本。</p><p>renderer对于⼀个draw的若⼲uniform，会先拿到需要set对应uniform的容器，还会从⼀个cache的Set⾥里里 拿到上⼀个对应该uniform且set过值的容器，如果两个容器本身不是⼀个引⽤，这时候我就知道，这个uniform数值的提供者发⽣了改变，那这种情况下，我需要做diff，容器上⾯的可变标记就⽆效了。如果两个容器是同⼀个引用，那么如果容器上的change标记显示已经发⽣了变化，那么我就可以不diff，直接进行上传，如果标记显示没有发⽣变化，那么我也可以跳过diff，直接不上传。⼀旦发⽣了上传，则更新 change标记false。如果program发⽣生了切换，那我就清空上⼀个draw的容器Set缓存，如果拿不到上⼀个draw的对应uniform的cache容器，那我也可以跳过diff，直接上传。</p><p>这个解法可以缓解⼤部分不需要的diff，⽽而对于watch的成本，在图形开发的常⽤环境下⽽而⾔言，不变的东⻄<br>往往⼤⼤多于变的东⻄，所以是⾮常合算的!</p><h2 id="Uniform-Block-amp-ShaderGraph-decorator-API"><a href="#Uniform-Block-amp-ShaderGraph-decorator-API" class="headerlink" title="Uniform Block &amp; ShaderGraph decorator API"></a>Uniform Block &amp; ShaderGraph decorator API</h2><p>WebGL2⽀持了UBO，UBO可以让⽤户将多个uniform合并成⼀个进⾏绑定，减少了gl调⽤次数，同时也能作为整体在多个WebGL program之间进⾏复⽤。对性能的提升影响很⼤。 我们怎么⽤好这个api呢，can we do better?</p><p>从字⾯意义上讲，既然要UBO，我们需要把⼀个shader中几个相关联的的uniform看成⼀个整体，或者知道他们是有联系的。把它们group起来。如果你⽐较贪，想把它们全部group起来，这样是不合适的，这样没有办法进⾏组合，只能draw⼀个死的东⻄。所以我的想法是把它们之前有关系的东⻄进⾏group:⽐ 如light的位置，颜色，就是⼀个整体，⼀个block。很显然的是，这些需要group的uniform的提供者，似乎都是⼀个对象，所以这个设计就⽐较明确了:</p><p>在artgl的设计中:每个这种可以提供uniform的对象，需要实现uniform provider的接⼝，其中包含⼀个 uniform-key to uniform-watch容器的map， 和⼀个标示uniform block是否change的字段。对象⾃身的⼀些属性，可以被装饰器进⾏装饰，使得⾃动转化成getter和setter， setter会⾃动向uniform-watch容器进⾏更新，以及和block change字段进⾏更新。由此，⽤户可以⾮常⾮常⽅便的接⼊uniform的优化系统。只要对原先的字段添加装饰器并继承⼀个实现了这个接⼝的类就可!</p><p><img src="/images/uniform-upload-design/provider.png" style="max-width:500px"></p><p>在之前的⼀篇⽂章，介绍了artgl的shadergraph的设计，在artgl中，shader是通过graph api显示的构建出来的，shader的uniform依赖，其实就是graph上的uniform input node，所以 can we do better on api design?</p><p>对于那些作为uniform provider的对象，它们之所以能作为uniform的 provider，是因为shader中有需要它们提供的uniform，所以，它们其实是和shader息息相关的。在此，介绍⼀下artgl shadergraph decorator的API，它很好的解决的这⼀层的抽象。本质上uniform provider声明了某个shader需要这些 uniform，所以，provider需要亲⾃修改shadergraph，⾃⼰添加⾃⼰provide的uniform input和⾃身 shader实现的计算逻辑。API上，uniform provider需要实现 decorate接⼝，decorate接⼝输⼊需要装饰 的shadergraph，实现装饰逻辑。</p><p><img src="/images/uniform-upload-design/decorate.png" style="max-width:500px"></p><p>在graph上添加⼀个uniform的input node， 需要名字和类型，默认值等参数，这些显然和provider⾃身的字段声明是冗余的，所以我在provider的基类实现了⼀个util函数，可以直接运⾏时读取属性值，根据数据类型和数据，return你需要的uniform input node，同时，利⽤ts的key of，可以实现静态的字段检查，防止你引⽤⼀个不存在字段。</p><p>比如这个简单的点光源的实现：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> PointLight <span class="keyword">extends</span> Light&lt;PointLight&gt; &#123;</span><br><span class="line"></span><br><span class="line">  decorate(decorated: ShaderGraph) &#123;</span><br><span class="line">    decorated</span><br><span class="line">      .setFragmentRoot(</span><br><span class="line">        AddCompose.make()</span><br><span class="line">          .input(<span class="string">"base"</span>, decorated.getFragRoot())</span><br><span class="line">          .input(<span class="string">"light"</span>, pointLightShading.make()</span><br><span class="line">            .input(<span class="string">"fragPosition"</span>, decorated.getVary(WorldPositionFragVary))</span><br><span class="line">            .input(<span class="string">"FragNormal"</span>, decorated.getVary(NormalFragVary))</span><br><span class="line">            .input(<span class="string">"lightPosition"</span>, <span class="keyword">this</span>.getPropertyUniform(<span class="string">'position'</span>))</span><br><span class="line">            .input(<span class="string">"color"</span>, <span class="keyword">this</span>.getPropertyUniform(<span class="string">'color'</span>))</span><br><span class="line">            .input(<span class="string">"radius"</span>, <span class="keyword">this</span>.getPropertyUniform(<span class="string">'radius'</span>))</span><br><span class="line">          )</span><br><span class="line">      )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@MapUniform</span>(<span class="string">"lightColor"</span>)</span><br><span class="line">  color: Vector3 = <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="meta">@MapUniform</span>(<span class="string">"lightPosition"</span>)</span><br><span class="line">  position: Vector3 = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="meta">@MapUniform</span>(<span class="string">"lightRadius"</span>)</span><br><span class="line">  radius: <span class="built_in">number</span> = <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实不止光照系统，camera， 渲染曝光参数，等等，如果你想要引擎内置的这些功能，那就让他们装饰你的shadergraph吧，他们依赖的uniform，ubo，shader的逻辑，直接全都有了～ 所以shadergraph的api现在将全部以decorator的形式提供：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> PureShading <span class="keyword">extends</span> BaseEffectShading&lt;PureShading&gt; &#123;</span><br><span class="line"></span><br><span class="line">  decorate(graph: ShaderGraph) &#123;</span><br><span class="line">    graph</span><br><span class="line">      .setVertexRoot(MVPWorld())</span><br><span class="line">      .setFragmentRoot(uniform(<span class="string">"baseColor"</span>, GLDataType.floatVec4))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在api的另⼀侧，场景接⼝的⽤户，现在构造某个绘制所需要的shading对象，则需要⼿⼯的进⾏依赖的装饰，虽然使⽤上繁琐了⼀些。但是本质上其实就是把更多的⾃由度开给了⽤户，让⽤户更清楚的看到这个draw依赖哪些对象，如何能更好的在数据层⾯上优化绘制。在过去，这样的逻辑是写死在渲染引擎内部的，对于使⽤者的理理解其实也是⼀层不便。</p><p>通过 uniform provider的 API， ⼀⽅⾯，对UBO的引擎层⾯有了很好的抽象，直接⽀持是件易如反掌的事情。另⼀⽅⾯，进⼀步减少了上传时check的成本，毕竟你有了⼀个group的change标记可以略略过⼀整个group的check过程。更重要的是和shadergraph的结合使得在设计上，开发上，概念模型上达成了不错的⼀致和统⼀。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要讨论和介绍一下artgl的uniform上传优化，到如何支持ubo的设计。 以及，因为ubo的优化，shadergraph的api和其概念模型的调整。&lt;/p&gt;&lt;h2 id=&quot;Uniform-Upload&quot;&gt;&lt;a href=&quot;#Uniform-Upload&quot; clas
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Graph based shader source management in artgl</title>
    <link href="http://yoursite.com/2019/07/16/graph-based-shadersource-management/"/>
    <id>http://yoursite.com/2019/07/16/graph-based-shadersource-management/</id>
    <published>2019-07-15T16:00:00.000Z</published>
    <updated>2020-08-23T07:00:50.628Z</updated>
    
    <content type="html"><![CDATA[<p>目前绝大多数的webgl库都使用字符串替换，并使用预编译指令来控制shader行为。</p><p>这种一般的基于字符串替换的方案存在以下缺陷：</p><ul><li>没有可组合性，只是复用代码，抽象能力弱</li><li>代码包含大量不需要的实现，使用 #include #define 等做区分，调试和阅读困难， 开发效率低</li><li>问题定位只依赖最后编译报错，排错效率低</li><li>修改代码需要在浏览器运行所有依赖的shader，代码难维护</li></ul><p>这些缺陷导致的各自难受之处之前也深有体会, 所以在设计artgl的shader体系时，我一直想要解决这个问题：</p><p><strong>如何找到更好的方案来管理一个webgl框架内的shader代码？</strong></p><p><a href="https://github.com/glslify/glslify" target="_blank" rel="noopener">glslify</a> 可能是一个好的解决方案，但我个人并不是很喜欢这种方式： 在shader里写require, transform shader code。 这种方式是以shader code作为核心，而我希望以框架code为核心，这样做1是ts代码能做更多的事情，而shader只是字符串，即便使用了完整的shader parser，能做的事情还是比较有限，扩展起来也不方便。 最好是使用ts代码，框架的代码，对着色流程进行抽象，shader只是这种抽象的target。2是，glslify太重了，我还是倾向于暂时把事情看的简单一些。</p><p>正常我们写shader，大多数写的是一些function，然后组合起来，执行出结果。所以我设计的组合单元是、ShaderFunction： 比如下面这个shader function，pack float depth到 四通道 rgba中</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> depthPackFunction = <span class="keyword">new</span> ShaderFunction(&#123;</span><br><span class="line">  description: <span class="string">'pack depth to RGBA output'</span>,</span><br><span class="line">  source: <span class="string">`</span></span><br><span class="line"><span class="string">    vec4 depthPack(float frag_depth)&#123;</span></span><br><span class="line"><span class="string">      vec4 bitSh = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);</span></span><br><span class="line"><span class="string">      vec4 bitMsk = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);</span></span><br><span class="line"><span class="string">      vec4 enc = fract(frag_depth * bitSh);</span></span><br><span class="line"><span class="string">      enc -= enc.xxyz * bitMsk;</span></span><br><span class="line"><span class="string">      return enc;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>ShaderFunction 只是描述这个shader的function，一个shader可能会调用多次shaderFunction进行计算，所以某个使用ShaderFunction的计算我们用 ShaderFunctionNode 来表示：ShaderFunction 事实上是 ShaderFunctionNode 的 factory。！</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> packedDepth = depthPackFunction.make()</span><br></pre></td></tr></table></figure><p>function的调用总归要传参吧：参数从哪里来呢？ 要么是来自shader外部，比如uniform，attribute，texture，对于片元着色器还有vary，要么来自其他function调用的结果。</p><p>我们先看外部的参数可以如何如何构造：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 这是一个引擎内置支持的全局uniform</span></span><br><span class="line"><span class="keyword">const</span> VPMatrix = innerUniform(InnerSupportUniform.VPMatrix)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这时一个用户自定义的shader uniform</span></span><br><span class="line"><span class="keyword">const</span> sampleCount = uniform(<span class="string">"u_sampleCount"</span>, GLDataType.float).default(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同理一个position attribute</span></span><br><span class="line"><span class="keyword">const</span> position = attribute(<span class="string">"position"</span>, GLDataType.floatVec3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同理一个depth vary</span></span><br><span class="line"><span class="keyword">const</span> depth = vary(<span class="string">"depth"</span>, GLDataType.float);</span><br></pre></td></tr></table></figure><p>然后我们可以给 packedDepth 喂数据了</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">packedDepth = depthPackFunction.make().input(</span><br><span class="line">  vary(<span class="string">"depth"</span>, GLDataType.float)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>当然，链式调用，我们可以一个一个input， 栗子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> worldPosition = MVPTransform.make()</span><br><span class="line">  .input(<span class="string">"VPMatrix"</span>, innerUniform(InnerSupportUniform.VPMatrix))</span><br><span class="line">  .input(<span class="string">"MMatrix"</span>, innerUniform(InnerSupportUniform.MMatrix))</span><br><span class="line">  .input(<span class="string">"position"</span>, attribute(<span class="string">"position"</span>, GLDataType.floatVec3))</span><br></pre></td></tr></table></figure><p>如果 ShaderFunctionNode 依赖其他 ShaderFunctionNode 的计算结果，这也是可以的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比如 先生成一个动态的2d平面上的随机数</span></span><br><span class="line"><span class="keyword">const</span> Random2D1 = rand2DT.make()</span><br><span class="line">  .input(<span class="string">"cood"</span>, vUV)</span><br><span class="line">  .input(<span class="string">"t"</span>, sampleCount)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再拿它去搞出另一个维度的随机数</span></span><br><span class="line"><span class="keyword">const</span> Random2D2 = rand.make()</span><br><span class="line">.input(<span class="string">"n"</span>, Random2D1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后在拿这两个随机数生成随机方向</span></span><br><span class="line"><span class="keyword">const</span> randDir = dir3D.make()</span><br><span class="line">  .input(<span class="string">"x"</span>, Random2D1)</span><br><span class="line">  .input(<span class="string">"y"</span>, Random2D2)</span><br></pre></td></tr></table></figure><p>通过这些node的连接，我们构造了一个graph，现在有了这个graph，我们要把shader搞出来。</p><p>OK， 我们再回过头来看shader，我们需要的是shader，webgl shader，两个着色器：</p><p>对于顶点着色器，总归有个 gl_Position ，或者 vary 这些。很简单，我们只要指定说：哪个node作为gl_Position，或者哪个node最为 叫什么名字的 vary就可以了。</p><p>对于顶点着色器，总归有个 gl_FragColor ，或者 mrt的输出 这些。很简单，我们只要指定说：哪个node作为 gl_FragColor ，mrt就先从简不考虑了，虽然挺对称的。</p><p>因为其实我们 vary 是构建顶点着色器指定的，所以前面vary也应该从整个graph get，api要改一下。</p><p>这是个画normal颜色的shader，应该好理解：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> graph = <span class="keyword">new</span> ShaderGraph();</span><br><span class="line"></span><br><span class="line">graph.reset()</span><br><span class="line">  .setVertexRoot(</span><br><span class="line">    MVPTransform.make()</span><br><span class="line">      .input(<span class="string">"VPMatrix"</span>, innerUniform(InnerSupportUniform.VPMatrix))</span><br><span class="line">      .input(<span class="string">"MMatrix"</span>, innerUniform(InnerSupportUniform.MMatrix))</span><br><span class="line">      .input(<span class="string">"position"</span>, attribute(</span><br><span class="line">        &#123; name: <span class="string">'position'</span>, <span class="keyword">type</span>: GLDataType.floatVec3, usage: AttributeUsage.position &#125;</span><br><span class="line">      ))</span><br><span class="line">  )</span><br><span class="line">  .setVary(<span class="string">"color"</span>, attribute(</span><br><span class="line">    &#123; name: <span class="string">'normal'</span>, <span class="keyword">type</span>: GLDataType.floatVec3, usage: AttributeUsage.normal &#125;</span><br><span class="line">  ))</span><br><span class="line">  .setFragmentRoot(</span><br><span class="line">    normalShading.make().input(<span class="string">"color"</span>, <span class="keyword">this</span>.graph.getVary(<span class="string">"color"</span>))</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>为了开发方便，很多小功能也被加入进来，比如你可以这么写：而不用自己包装function</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> node1 = vec4(attribute(<span class="string">"position"</span>, GLDataType.floatVec3), constValue(<span class="number">1</span>))</span><br><span class="line"><span class="keyword">const</span> node2 = node1.swizzling(<span class="string">"zyx"</span>)</span><br></pre></td></tr></table></figure><p>这就是 artgl ShaderGraph API的核心接口啦，目前这么写，已经可以work了！</p><p>在通过这些接口构建graph的过程中，每一步都有运行时参数类型的检查。link错的地方很早就能发现，解决了： 「问题定位只依赖最后编译报错，排错效率低」 的问题</p><p>虽然不是静态的检查，至少可以保证只要function写的不错，能link就能运行。所以你可以直接把每个shader构建加在单测里，单测没挂shader就没挂，不用起浏览器环境。解决了： 「修改代码需要在浏览器运行所有依赖的shader，代码难维护」 的问题</p><p>在编译shader的过程中，linker只会收集使用到的function和input依赖，没有任何预处理指令干扰视线，所以不存在： 「代码包含大量不需要的实现，使用 #include #define 等做区分，调试和阅读困难， 开发效率低」 的问题</p><p>shader graph 每一个node其实就是一个有类型的数值节点，所以可组合性非常强。不同的node类型实现不同的功能，易于扩展，比字符串拼接水平高多了。graph更是提供了整个shader的抽象，解决了「没有可组合性，只是复用代码，抽象能力弱」的问题</p><p>框架内置提供了常用的function供用户使用，也可以从独立的package import，shader 代码也正式成为框架的可扩展实现之一。 基于这样的抽象，甚至能解决不同shader version 编译的问题，这个就不展开了//</p><p>基于动态link，使用这种api，构造一个shader，类似于使用react，构造一个view，其实是相似的，有很多想象空间。基本上是我认为是实现框架抽象shader代码的一个好的方向。当然目前的解法还有一些限制，一些问题还有待解决，一些特性还有待设计和支持，如果有反馈和建议欢迎在 <a href="https://github.com/mikialex/artgl" target="_blank" rel="noopener">https://github.com/mikialex/artgl</a> 反馈和交流。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> TSSAOShading <span class="keyword">extends</span> Shading &#123;</span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="keyword">const</span> VPMatrix = innerUniform(InnerSupportUniform.VPMatrix);</span><br><span class="line">    <span class="keyword">const</span> sampleCount = uniform(<span class="string">"u_sampleCount"</span>, GLDataType.float).default(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> depthTex = texture(<span class="string">"depthResult"</span>);</span><br><span class="line">    <span class="keyword">this</span>.graph.reset()</span><br><span class="line">      .setVertexRoot(</span><br><span class="line">        vec4(attribute(</span><br><span class="line">        &#123; name: <span class="string">'position'</span>, <span class="keyword">type</span>: GLDataType.floatVec3, usage: AttributeUsage.position &#125;</span><br><span class="line">      ), constValue(<span class="number">1</span>)))</span><br><span class="line">      .setVary(<span class="string">"v_uv"</span>, attribute(</span><br><span class="line">        &#123; name: <span class="string">'uv'</span>, <span class="keyword">type</span>: GLDataType.floatVec2, usage: AttributeUsage.uv &#125;</span><br><span class="line">      ))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> vUV = <span class="keyword">this</span>.graph.getVary(<span class="string">"v_uv"</span>);</span><br><span class="line">    <span class="keyword">const</span> depth = unPackDepth.make().input(<span class="string">"enc"</span>, depthTex.fetch(vUV))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> worldPosition = getWorldPosition.make()</span><br><span class="line">      .input(<span class="string">"uv"</span>, vUV)</span><br><span class="line">      .input(<span class="string">"depth"</span>, depth)</span><br><span class="line">      .input(<span class="string">"VPMatrix"</span>, VPMatrix)</span><br><span class="line">      .input(<span class="string">"VPMatrixInverse"</span>, uniform(<span class="string">"VPMatrixInverse"</span>, GLDataType.Mat4).default(<span class="keyword">new</span> Matrix4()))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Random2D1 = rand2DT.make()</span><br><span class="line">      .input(<span class="string">"cood"</span>, vUV)</span><br><span class="line">      .input(<span class="string">"t"</span>, sampleCount)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> Random2D2 = rand.make()</span><br><span class="line">    .input(<span class="string">"n"</span>, Random2D1)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> randDir = dir3D.make()</span><br><span class="line">      .input(<span class="string">"x"</span>, Random2D1)</span><br><span class="line">      .input(<span class="string">"y"</span>, Random2D2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> newPositionRand = newSamplePosition.make()</span><br><span class="line">      .input(<span class="string">"positionOld"</span>, worldPosition.swizzling(<span class="string">"xyz"</span>))</span><br><span class="line">      .input(<span class="string">"distance"</span>, uniform(<span class="string">"u_aoRadius"</span>, GLDataType.float).default(<span class="number">1</span>))</span><br><span class="line">      .input(<span class="string">"dir"</span>, randDir)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> newDepth = unPackDepth.make()</span><br><span class="line">      .input(<span class="string">"enc"</span>,</span><br><span class="line">        depthTex.fetch(</span><br><span class="line">          NDCxyToUV.make()</span><br><span class="line">            .input(</span><br><span class="line">              <span class="string">"ndc"</span>, NDCFromWorldPositionAndVPMatrix.make()</span><br><span class="line">                .input(</span><br><span class="line">                  <span class="string">"position"</span>, newPositionRand</span><br><span class="line">                ).input(</span><br><span class="line">                  <span class="string">"matrix"</span>, VPMatrix</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.graph.setFragmentRoot(</span><br><span class="line">      tssaoMix.make()</span><br><span class="line">        .input(<span class="string">"oldColor"</span>, texture(<span class="string">"AOAcc"</span>).fetch(vUV).swizzling(<span class="string">"xyz"</span>))</span><br><span class="line">        .input(<span class="string">"newColor"</span>,</span><br><span class="line">          sampleAO.make()</span><br><span class="line">            .input(<span class="string">"depth"</span>, depth)</span><br><span class="line">            .input(<span class="string">"newDepth"</span>, newDepth)</span><br><span class="line">        )</span><br><span class="line">        .input(<span class="string">"sampleCount"</span>, sampleCount)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目前绝大多数的webgl库都使用字符串替换，并使用预编译指令来控制shader行为。&lt;/p&gt;&lt;p&gt;这种一般的基于字符串替换的方案存在以下缺陷：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;没有可组合性，只是复用代码，抽象能力弱&lt;/li&gt;&lt;li&gt;代码包含大量不需要的实现，使用 #include #
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>开源项目的思考</title>
    <link href="http://yoursite.com/2019/07/07/opensource2019/"/>
    <id>http://yoursite.com/2019/07/07/opensource2019/</id>
    <published>2019-07-06T16:00:00.000Z</published>
    <updated>2020-08-23T07:00:50.629Z</updated>
    
    <content type="html"><![CDATA[<p>GitHub是我使用的最频繁的网站之一，我有几个属于自己的长期经营的开源项目，在这些项目上工作了很多时间。我也向著名的大型项目提交过pr，有些也成功合并了。我是一个开源爱好者。</p><p>早些时候，我喜欢将自己写的代码公开出来出于很简单的理由：我写的程序是我的作品，我想要把这些公开出来以期望得到别人的认可。正如我会撰写博客一样。如果我是一个计算机专业的学生，我肯定会把我的所有作业，课程设计，读书笔记都会以开源的方式分享出去。因为公开，所以这些材料是我要认真面对认真思考的，这有助于防止浑浑噩噩的度过枯燥的日子，也有助于帮助所有其他有志于此的同学。而更因为可以进行版本控制的原因，所以也为知识网络的构建提供了写作的平台。这些公开的资料也同时能够证明我在某一个领域是有所投入和产出的。如果你熟悉web开发，如果你了解机器学习，如果你在精通编译原理，那么通过你有公开的仓库里你自己开发的网站，自己写的算法，自己写的parser，都可以完美的证明和佐证你在这些领域的能力和实际水平。从这个角度而言，开源项目，其实是长期在开发领域自我学习，自我驱动，自我进行投入和产出的平台。</p><p>我认识的一些朋友，他们持有这这样的一种观点：只有做的非常完善非常拿得出手的东西才有资格开源，否则就是献丑。开源事业在他们眼中是一种“事业”，是一种非常宏大的东西，和平时的软件开发工作相去甚远。我认为这种观点是狭隘的，因为一方面：我们不能 「因为害怕被批评而拒绝公开作品 」而放弃提升自我的机会。另一方面，开源并不是什么高大上的东西，可以肯定的是，99.99的仓库对于别人而言没有任何价值。99的仓库是彻底的垃圾，但这又如何呢？ 一个软件开发者，把自己的代码，share到github上，和一个视觉设计师，把自己的作品，发布到behance上，有什么本质上的区别吗？ 反过来，如果一个程序员不关注开源社区，正如一个设计师，从来不去关注优秀作品，有多大可能是一个优秀的设计师呢？</p><p>可能你解决了一个小的问题，你也有机会把它公开出来，但是你会觉得这个问题太冷门，别人不大可能用的到，自己的解法也说不上好，完全没有这个开源的必要。但我认为即便是这种情况，也是有价值的。我今年在工作中遇到了不少棘手的问题，在看了一些一些无人问津的代码，问了一些至关重要的问题之后才得以解决。这件事情给我一个感觉是：你公开的代码和信息，事实上是汇入了文明的集体智慧中，这些领域的可以被感兴趣的人检索到。写开源代码正如写博客一样，是件很cool的事情。在互联网的时代，我们不必把所有的心得，领悟，落于纸上，收藏在厚重的笔记中，而是变成可以分享传播的数据。互联网是印刷术般对于历史进程有着革命性影响的东西，这个道理是不言自明的。</p><p>去年圣诞节，著名的开源ui，antdesign因为彩蛋翻车了。。 这件事情又让我对开源又了新的认识。就是github不仅仅是behance，这仅仅是他的展示的分享的属性的。但其实最最重要的，是程序，是代码的发布平台。成熟的开源项目，是产品，「是产品，就要对用户负责」。对于产品级别的开源项目，我们要有足够的敬畏，如果用户因为我们的无谓随意，业余和失误，而造成损失，那么这个产品就是失败的。这无关开不开源，只是开源意味着公益，意味着免费，但公益和免费，并不意味着质量低下。很多人认为，开源的软件产品不如商业产品，这个说法不对，应该是，开源产品中好的比例远远低于商业产品。毕竟因为没有利益的保障。但是因为用户群是如此之广，优秀的开源软件，生命力和质量往往无可匹敌。所以理论上，其实成熟的开源产品质量是不错的。antd的问题是，少部分owner并没有质量的意识，这个问题别的开发者也看到了，但项目写的怎么样，准备怎么搞，话语权都是在owener里的，这同时决定了质量。而具体的问题最后也会反过来形成反馈的机制，这和商业软件并无二致。只是这个antd太过出名，自然是轩然大波。</p><p>最后我想说的是，我们几乎都是开源软件的受益者，记得要饮水思源。公司的项目主要是在一个著名的开源项目上进行定制的，虽然我们经常吐槽这个库的质量，但当我们发现新的缺陷都会尽快的提出issues和pr，帮助开发者进行解决。我们也会提出设计上的建议。我自己使用的一些库，当缺少了我想要的功能，热心的开发者竟然很快的加入了实现。伟大的软件就是这样建造出来的，能参与其中是件美妙的事情。不过去年，一些来自我国的低素质软件开发者在deno的仓库中随意调侃和发泄，这种事情是很不光彩的。如果你没有资格讲话，就应该闭嘴，如果不能添砖加瓦，就别浪费别人的时间。</p><p>都是一些很简单的道理，希望你能和我一样，热爱软件开发，乐于分享，乐于付出和收获，和我一起参与到 构建 自由开放优秀软件的 美好事业中来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;GitHub是我使用的最频繁的网站之一，我有几个属于自己的长期经营的开源项目，在这些项目上工作了很多时间。我也向著名的大型项目提交过pr，有些也成功合并了。我是一个开源爱好者。&lt;/p&gt;&lt;p&gt;早些时候，我喜欢将自己写的代码公开出来出于很简单的理由：我写的程序是我的作品，我想要
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计工具的框选实现</title>
    <link href="http://yoursite.com/2019/06/04/cpu-area-pick/"/>
    <id>http://yoursite.com/2019/06/04/cpu-area-pick/</id>
    <published>2019-06-03T16:00:00.000Z</published>
    <updated>2020-08-23T07:00:50.627Z</updated>
    
    <content type="html"><![CDATA[<p>做设计的朋友们对设计软件中的框选是非常熟悉的。整理一下最近在产品中调研的cpu框选的技术实现。</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>所谓框选，就是用户交互式的拖出一个屏幕上的矩形区域用来选择场景对象。这里根据不同的业务存在几种不同的需求：</p><p>比如：遮挡情况：是否需要只选中最前面的物体，而排除那些完全被遮挡住的物体， 还是即便是被完全遮挡住的物体也要选中？ 某些在空间上完全处于被遮挡的情况，在某些渲染模式下（比如线框），被遮挡的物体依然完全可见，这种情况下又如何处理？某些情况下，物体没有被完全遮挡，只有一个像素暴露在外，甚至因为渲染的原因，只有半个像素糊在边界上，这种情况用户似乎又不是需要选中的，那实现上又如何应该处理呢？ 当我们实现点选，选择最前面的，是很好实现和分辨的，因为总归是一个ray的事情，而对于框选来说，遮挡/最前面，从实现的角度而言，这个需求就显得复杂和含糊。从我过去作为一个设计出身的经历而言，我已经很适应在一个mesh上框出一堆face，但是反面也会被框住的事情。事实上因为这些种种的原因，这设计软件中，灵巧的调整各种视图，使用不同的工具，快速的选中需要的东西其实也是关于生产力的技巧。</p><p>又比如：相交还是包含？ 相交是指框选框和物体相接触就认为选中，包含是指框选框完整包含物体才认为选中。设计软件一般这两种模式都会提供，某些情况下，使用相交会使得选择变得容易，不过又容易多选，在我看来是更符合我的直觉的，当然，这其实是使用习惯上的分别</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在不考虑遮挡关系，考虑如何实现一个cpu版的框选。</p><p>由于我们的实现是在threejs的基础上，three的场景数据种类比较丰富，对象的类型mesh？ line？ points？几何的类型，Geometry？ BufferGeometry？ BufferGeometry里有没有index， Material是array还是一个，Attributes是interleaved怎么办？各种事情导致code写起来非常复杂。three也没有提供一个简单的针对drawable的东西foreach primitive的通用方法，这些因素归结于codebase提供的复杂性我们不必深究。 核心还是mesh， line， points三种不同的primitive的讨论。</p><p>通过屏幕空间范围和相机的参数，可以确定出一个世界空间的frustum。</p><p>bounding的提前退出：如果一个物体的bounding完全处于这个frustum之外，那么肯定是选不中的，提前退出。 如果一个物体的bounding完全处于这个frustum之内，在包含模式下，肯定是选中了，提前退出。这里需要额外考虑，bounding需要使用数据的，而不是渲染的，因为shadow之类的会产生影响。</p><p>如果frustum和box相交，那么计算就变得额外的多，简而言之：</p><p>相交模式：foreach primitive，依次测试和frustum是否相交， 相交则提前退出，该物体框选成功。否则失败。<br>包含模式：foreach primitive，依次测试和frustum是否包含， 不包含则提前退出，该物体框选不成功。否则成功。<br>以上的 primitive 需要根据情况做面序剔除。</p><p>在使用BVH的情况下，利用空间结构我们可以做更多的提前退出：</p><p>相交模式：traverse bvh tree每一个tree节点， 如果node被frustum contain，且该node的所有的pimitives中至少有一个可见，则bvh提前退出框选成功。<br>包含模式：traverse bvh tree每一个tree节点， 如果node被frustum contain，那么此node被剪枝。</p><p>性能评估：</p><p>框选的成本比点选高很多，估计可能在5-10倍。contain模式可能开销会高。</p><p>frustum有6个面要判断。每个面和primitive和位置关系判断似乎都比ray要开销高。需要深入进入mesh内进行判断的情况也比raycast多很多。</p><p>其他社区实现或者讨论：</p><p>有用的：</p><p><a href="https://cesiumjs.org/Cesium/Build/Documentation/Scene.html#pick" target="_blank" rel="noopener">https://cesiumjs.org/Cesium/Build/Documentation/Scene.html#pick</a></p><p><a href="https://cesiumjs.org/Cesium/Build/Documentation/Scene.html#drillPick" target="_blank" rel="noopener">https://cesiumjs.org/Cesium/Build/Documentation/Scene.html#drillPick</a></p><p><a href="https://github.com/AnalyticalGraphicsInc/cesium/blob/1.57/Source/Scene/PickFramebuffer.js" target="_blank" rel="noopener">https://github.com/AnalyticalGraphicsInc/cesium/blob/1.57/Source/Scene/PickFramebuffer.js</a></p><p>cesium主要是应该gpu实现的， gpu做不到遮挡后面的pick</p><p>osg intersector, 抽象了普通的多面体求交， 使用kd tree</p><p><a href="https://github.com/openscenegraph/OpenSceneGraph/blob/master/src/osgUtil/PolytopeIntersector.cpp" target="_blank" rel="noopener">https://github.com/openscenegraph/OpenSceneGraph/blob/master/src/osgUtil/PolytopeIntersector.cpp</a></p><p>其他：</p><p><a href="https://github.com/mrdoob/three.js/issues/1826" target="_blank" rel="noopener">https://github.com/mrdoob/three.js/issues/1826</a></p><p><a href="https://github.com/vasturiano/react-force-graph/issues/43" target="_blank" rel="noopener">https://github.com/vasturiano/react-force-graph/issues/43</a> 2d的，简单，没有太多可比性</p><p><a href="http://output.jsbin.com/tamoce/3/" target="_blank" rel="noopener">http://output.jsbin.com/tamoce/3/</a> three的，实现不是很正确？</p><p><a href="https://community.khronos.org/t/intersecting-a-3d-segment-with-perspective-frustum/59537/3" target="_blank" rel="noopener">https://community.khronos.org/t/intersecting-a-3d-segment-with-perspective-frustum/59537/3</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;做设计的朋友们对设计软件中的框选是非常熟悉的。整理一下最近在产品中调研的cpu框选的技术实现。&lt;/p&gt;&lt;h2 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h2&gt;&lt;p&gt;所谓框选，就是用户交互式的拖出一
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>WebAssembly 3D 场景树加速原型验证</title>
    <link href="http://yoursite.com/2019/04/30/wasm-scene/"/>
    <id>http://yoursite.com/2019/04/30/wasm-scene/</id>
    <published>2019-04-29T16:00:00.000Z</published>
    <updated>2020-08-23T07:00:50.631Z</updated>
    
    <content type="html"><![CDATA[<p>继上次 「WebAssembly零拷贝批量数据交换和计算」 一文中的想法，我在我的webgl引擎项目中进行了初步实践。相应的代码可以在 <a href="https://github.com/mikialex/artgl" target="_blank" rel="noopener">artgl</a> 中找到。基本验证了上次的设想（使用wasm加速渲染数据生成更新并batch drawcall）是可行的。</p><h2 id="TLDR"><a href="#TLDR" class="headerlink" title="TLDR"></a>TLDR</h2><p>主要实现了一些基本的场景数据和渲染数据存储在wasm 的memory中，场景节点提供普通的 js api。</p><p><strong>实测使用6层6叉的超大场景树，约6w节点，全部计算更新世界矩阵，耗时是threejs的不到一半。</strong>（～6ms ／ ～14ms）</p><p>这基本证明了其性能优势是无法忽视的。</p><p>local矩阵的更新，世界bounding信息的更新，以及这些的按需行为，视锥剔除 细节剔除 drawcall排序 基数排序 这些将在后续完成实现</p><h2 id="基本设计"><a href="#基本设计" class="headerlink" title="基本设计"></a>基本设计</h2><p>scene对象负责管理用户描述场景的sceneNode节点，以及渲染数据的更新。</p><p>实际的数据存储在多个float32array／ int32array 中，这些array的视图建立在wasm内存arraybuffer上，初始化和扩容时调用scene对应的wasmscene的扩容方法，完成wasm内的扩容，返回这些array的ptr，用以更新typearray的视图。sceneNode上的场景数据，会以getter和setter的形式直接访问wasm内存中的数据。例如用户设置了某个节点的position， 数据会直接通过typedarray写入wasm内存中。</p><p>比如目前就已经实现了下列数据的包装：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">local_transform_array: <span class="built_in">Vec</span>&lt;<span class="built_in">f32</span>&gt;,</span><br><span class="line">local_position_array: <span class="built_in">Vec</span>&lt;<span class="built_in">f32</span>&gt;,</span><br><span class="line">local_rotation_array: <span class="built_in">Vec</span>&lt;<span class="built_in">f32</span>&gt;,</span><br><span class="line">local_scale_array: <span class="built_in">Vec</span>&lt;<span class="built_in">f32</span>&gt;,</span><br><span class="line">world_transform_array: <span class="built_in">Vec</span>&lt;<span class="built_in">f32</span>&gt;，</span><br><span class="line"></span><br><span class="line">local_aabb_array: <span class="built_in">Vec</span>&lt;<span class="built_in">f32</span>&gt;,</span><br><span class="line">world_aabb_array: <span class="built_in">Vec</span>&lt;<span class="built_in">f32</span>&gt;,</span><br><span class="line">local_bsphere_array: <span class="built_in">Vec</span>&lt;<span class="built_in">f32</span>&gt;,</span><br><span class="line">world_bsphere_array: <span class="built_in">Vec</span>&lt;<span class="built_in">f32</span>&gt;,</span><br><span class="line"></span><br><span class="line">empty_array: <span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt;,</span><br><span class="line">empty_list_array: <span class="built_in">Vec</span>&lt;<span class="built_in">u16</span>&gt;,</span><br><span class="line">empty_count: <span class="built_in">u16</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// [parent, left brother, right brother, first child]</span></span><br><span class="line">nodes_indexs: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;,</span><br></pre></td></tr></table></figure><p>为了实现将tree存储于array中，tree的children使用双链表实现，每一个node存储前后一个兄弟，父亲，第一个child的索引位置。由于用户几乎没有随机访问某一个节点的children的需求，查询操作基本不受影响。sceneNode的js api 暴露add和remove方法会自动维护相关的索引。</p><p>empty_array和empty_list_array用以做标记删除</p><p>在后续会加入：</p><p>一个uint32的array使用位信息来表示每一个数据的change情况用以按需优化。</p><p>一个f32表示距离，一个f32表示屏幕投影大小。 一个uint32表示gl状态，包括shader／blend／culling ／visibility。这些可以组合起来做基数排序。</p><p>每次渲染时，scene通知wasmscene batch drawcall， 在wasm中完成所有计算，生成一个index list ，返回这个result indexlist的ptr和count， 然后js renderer加个接口直接读取就可以。 另外可以考虑的是直接使用wasm webgl的bindgen 这方面没有了解，可能需要调研和测试。</p><h2 id="遇到的坑·已知风险·考虑："><a href="#遇到的坑·已知风险·考虑：" class="headerlink" title="遇到的坑·已知风险·考虑："></a>遇到的坑·已知风险·考虑：</h2><p>wasm 的部分在chrome pref测量会导致性能问题。对实际运行无影响。</p><p>rust要开o3编译。</p><p>需要考虑asmjs的fallback，uc qq浏览器支持不好。</p><p>wasm scene和其他的比如three的scene有一个区别是，sceneNode 有attach状态并且只能属于一个scene，这个可能会引起上层设计改动。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;继上次 「WebAssembly零拷贝批量数据交换和计算」 一文中的想法，我在我的webgl引擎项目中进行了初步实践。相应的代码可以在 &lt;a href=&quot;https://github.com/mikialex/artgl&quot; target=&quot;_blank&quot; rel=&quot;noop
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>WebAssembly零拷贝批量数据交换和计算</title>
    <link href="http://yoursite.com/2019/03/28/wasm-memory-as-data-container/"/>
    <id>http://yoursite.com/2019/03/28/wasm-memory-as-data-container/</id>
    <published>2019-03-27T16:00:00.000Z</published>
    <updated>2020-08-23T07:00:50.630Z</updated>
    
    <content type="html"><![CDATA[<p>最近在尝试将wasm用以webgl渲染引擎加速，有2个问题比较担心，1是据说js call wasm overhead很高，难以做函数级别的优化，最好批量处理，虽然mozila后来优化了相关问题，但是目前还没有bench过，包括其他浏览器也不是很确定，2是担心批量处理，需要从js端copy数据，再copy回来，这个开销比较难受。所以做了一翻调研。</p><p>假设我有一个很大的array需要传给webassembly，wasm-bindgen 可以生成 number slice的<a href="https://rustwasm.github.io/docs/wasm-bindgen/reference/types/number-slices.html" target="_blank" rel="noopener">接口</a>, 大概类似这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">take_number_slice_by_shared_ref(<span class="keyword">new</span> <span class="built_in">Float64Array</span>(<span class="number">100</span>));</span><br><span class="line">take_number_slice_by_exclusive_ref(<span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="number">100</span>));</span><br></pre></td></tr></table></figure><p>大致是用户需要new一个typedarray来作为输入，需要在js端完成一次copy，临时内存分配和销毁带来的overhead并不合理，所以wasm能够真正应用得当需要寻找更合理的方式</p><p><a href="https://github.com/rustwasm/wasm-bindgen/issues/270" target="_blank" rel="noopener">这个issue</a>，以及<a href="https://stackoverflow.com/questions/41875728/pass-a-javascript-array-as-argument-to-a-webassembly-function" target="_blank" rel="noopener">这个</a> 看到比较合理的从js端传送批量数据到webassembly进行处理的方案。</p><p>大致流程是：</p><p>1 调用wasm的方法，在wasm内存中分配空间，返回指针位置<br>2 js端在wasm的memory arraybuffer上，按指针位置和数据量建立view，把数据写入<br>3 调用wasm方法完成计算， 返回计算好的批量结果的指针位置和大小<br>4 js端在wasm的memory arraybuffer上，按指针位置和数据量建立view，把数据读出</p><p>主要情况是： wasm模块会有一个线性的内存，js端看就是一个arraybuffer，js端可以自由的读写。所以批量的数据写入可以通过直接在这个memory的arraybuffer上建立view来实现。甚至说，<strong>我们可以直接将wasm的memory当作js部分的紧凑数据容器</strong>，某些批量的数据处理和计算，可以直接调用wasm的方法来实现，js端可以直接在结果的读容器中获得。</p><p>在 rust 的webassembly的官方 game of life 的例子中我们可以看到这个<a href="https://rustwasm.github.io/docs/book/game-of-life/implementing.html" target="_blank" rel="noopener">实现</a>, 直接访问wasm memory的数据</p><p>我自己测试了一下这种使用模式，似乎没有什么问题</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[wasm_bindgen]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Batcher</span></span> &#123;</span><br><span class="line">    data: <span class="built_in">Vec</span>&lt;<span class="built_in">f32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[wasm_bindgen]</span></span><br><span class="line"><span class="keyword">impl</span> Batcher &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; Batcher&#123;</span><br><span class="line">        Batcher &#123;</span><br><span class="line">            data:<span class="built_in">Vec</span>::with_capacity(<span class="number">100</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">allocate</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, capacity: <span class="built_in">u32</span>) -&gt; *<span class="keyword">const</span> <span class="built_in">f32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.data = <span class="built_in">vec!</span>[<span class="number">0.0</span>; capacity <span class="keyword">as</span> <span class="built_in">usize</span>];</span><br><span class="line">        <span class="keyword">self</span>.data.as_ptr()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">batch</span></span>(&amp;<span class="keyword">self</span>, batchLength: <span class="built_in">u32</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> &amp;<span class="keyword">self</span>.data &#123;</span><br><span class="line">            log_f32(*d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dataLength = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> batcher = wasm.Batcher.new();</span><br><span class="line"><span class="built_in">console</span>.log(batcher)</span><br><span class="line"><span class="keyword">const</span> ptr = batcher.allocate(dataLength);</span><br><span class="line"><span class="keyword">const</span> dataview = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(memory.buffer, ptr, dataLength);</span><br><span class="line"></span><br><span class="line">dataview[<span class="number">0</span>] = <span class="number">1.5</span>;</span><br><span class="line">dataview[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">dataview[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">dataview[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">batcher.batch(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>这个原型大致可以推测出一种使用wasm memory作为数据容器以实现前端零拷贝高性能计算的模式： 将wasm的memory直接存储js数据。当然，我们在不考虑性能的情况下可以wrap一群js对象，通过getter setter，或者其他数据同步的设施，使得用户可以直接操作普通对象的方式操作wasm中的数据。在某些情况下，wasm可以直接对存储的数据进行重计算的操作，然后零拷贝的暴露出计算结果。这可能是wasm用法的一个比较好的实践。</p><p>实际的应用其实渲染引擎的确可以作为不错的尝试的例子，场景树，节点的js对象直接读写数据到wasm中，在每一帧渲染时，wasm模块自身负责高性能的渲染数据生成／同步，包括优化，排序，最后的renderlist直接暴露在memory中，js外层再一个batch读结果，完成gl调用。 在这个过程中js和wasm之间0数据拷贝，最小化直接交互调用，似乎没什么问题。</p><p>by the way, rust相关的wasm工具链包括rust自身的使用体验非常优秀。值得推荐。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在尝试将wasm用以webgl渲染引擎加速，有2个问题比较担心，1是据说js call wasm overhead很高，难以做函数级别的优化，最好批量处理，虽然mozila后来优化了相关问题，但是目前还没有bench过，包括其他浏览器也不是很确定，2是担心批量处理，需要
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Artgl，a webgl framework</title>
    <link href="http://yoursite.com/2019/03/12/artgl-about/"/>
    <id>http://yoursite.com/2019/03/12/artgl-about/</id>
    <published>2019-03-11T16:00:00.000Z</published>
    <updated>2020-08-23T07:00:50.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于ARTGL"><a href="#关于ARTGL" class="headerlink" title="关于ARTGL"></a>关于ARTGL</h1><p>自2018四月以来从事web端图形渲染的相关工作以来，ARTGL一直作为我个人学习webgl渲染的side project，一直作为一个实践想法和探索的平台。今日，项目整体的设计已经初具雏形，在渲染引擎的整体设计方面也有了一些自己的积累。借此稍作整理。</p><h2 id="想要解决的问题和创新？"><a href="#想要解决的问题和创新？" class="headerlink" title="想要解决的问题和创新？"></a>想要解决的问题和创新？</h2><p>最早我在我的个人网站的主页想做一个很简单的3d特效，使用threejs导致前端的js文件尺寸暴涨，而three内部据说由于大量使用 Object.defineproperties 等方法修改和扩展对象，导致无论对编译配置做出怎样的调整都无法实现tree shaking优化。而我也没有意愿寻找其他简单的webgl库。这反映一个问题是，three类型的webgl库，默认包含了过多我们根本不需要的东西，数学库可以全一点，这个没有问题，但那么多其他的Geometry， Material，Loader，等等我根本不需要，很多像动画/压缩纹理支持 等等，我都不需要，但是我却很难搞掉它们。</p><p>所以我希望一个好的webgl封装， 应该只提供最小最核心的实现，而那些各种各样的material ，light， geometry，应该能够非常方便的让用户自己扩展实现，或者引入独立的外部资源库，不会有多余的东西。我不希望我的项目里有一大堆的code是根本没有用的，虽然理论上我可以不care这些。</p><p>所以： <strong>要充分隔离资源类型的支持和资源实现本身，一方面要做到用户能够清楚的方便的自己扩展和实现</strong>， 另一方面，应当<strong>仅提供最小化的核心实现， 并能够将资源的实现以最小粒度library化，</strong> 说的简单一点就是，material ，light， geometry这种东西，也不说其他更高级的，应当做成独立的库，并且用户很容易扩展出自己的东西，不要一堆的都塞到我手里。</p><p>关于资源的library化，还很好做，主要的挑战在于：用户能够清楚的方便的自己扩展和实现。一方面这是引擎定位的考虑，比如three这个库，易于使用却不易扩展：当你的需求超出了他能支持的范围一点点，你就要开始看上万行源码，投身到webgl渲染的学习中来，然后fork改代码。库的作者并没有很好的整理封装了这么哪些概念，以及更重要的如何自由的扩展和实现你自己的东西，然后在已有的体系下完美运作。但如果真的能做到这样那岂不是更好。</p><p>另一方面，我想尝试的是诸多架构上的改进： <strong>目前市面上大多数的webgl封装， 都是webgl库，并不是框架。 使用库，我可以完成我的工作我的目的，但是这个世界上每一个人每一家企业，每一个项目，都有不同的需求。</strong> 当然，如果你不得不说要仅仅完成任务，那么大可不必如此追求。但我认为是时候要在架构上做出反思，打造出更好的东西出来。</p><p>关于framework， 一个是要<strong>做好分层的设计，webgl渲染层，webgl数据层，渲染数据层， 场景数据层，渲染策略层，各个层面要做好充分的隔离</strong>，甚至使得用户可以做到替换自定义实现，去除顶层抽象简化项目等目的。</p><p>为什么要自定义实现？ 举例说，场景数据层面，有的项目，场景树的设计完全是多余的，那么场景数据的组织是不是可以换成其他更简单的实现？ 或者另一个极端的例子，如果层与层之间的接口设计的很清楚，那么我理论上可以用canvas2d作为我的renderapi。</p><p>去除顶层抽象则是简化实现的考虑，举例说假设用户只要用webgl做一个shader的特效，那么用户其实只要引入webgl渲染层一个层的实现，gl的数据就几个自己处理，就非常的简洁轻量高效。或者仅仅单纯就是渲染一堆的东西，不想添加任何复杂的后处理，或者优化逻辑，那么渲染策略层也是可以忽略的东西。</p><p>关于framework， 另一个设计主要关于最顶层的渲染策略层。我们绝大多数看到的webgl库，都是把整个渲染流程，包括后处理的流程，全部用代码hardcode出来的，对外只暴露若干接口用以配置。这其实是极度缺乏设计和抽象的。正确的设计是<strong>暴露一套描述渲染流程，优化策略的接口，使得用户可以使用这些轻松的构建自己的动态渲染管线</strong> ，用户再以此封装出自己的配置项。或者说，用户可以使用此接口，设计出多种渲染管线，封装出多种viewer， 以支持不同场景的优化和使用需求。</p><p>关于这一点，是我非常兴奋的一处创新，在我公司项目的实践中，真的是深深感受到，渲染流程缺乏合理抽象的巨大缺陷。无论是代码质量，调试难度，创新原型，效果调优，通过合理的架构设计其实可以通过好的框架设计，全方位的解决问题并提高效率。而目前基于rendergraph的方案，已经经过TAA多pass的实践，取得了很好的成果。</p><p>总结下来，<strong>ARTGL将提供 清晰的多层的webgl渲染基础设施，每一层都会针对具体的资源高度支持用户的定制和扩展，以最合理的方式，配合高度定制化的可扩展性，支持最广泛用户群体的不同应用场景。</strong></p><h2 id="milestone-和-release-计划？"><a href="#milestone-和-release-计划？" class="headerlink" title="milestone 和 release 计划？"></a>milestone 和 release 计划？</h2><p>受制于我的业余时间，和考虑到接口稳定性，我预计会在今年年底完成第一个稳定api的release版本，其中包含：基本webgl底层支持， 基本的资源抽象定义，场景树，rendergraph， 并基于此架构实现一个包含复杂后处理和复杂优化逻辑的viewer。由于使用了typescript 所以代码的重构和优化非常频繁和自信，api的接口变动非常频繁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于ARTGL&quot;&gt;&lt;a href=&quot;#关于ARTGL&quot; class=&quot;headerlink&quot; title=&quot;关于ARTGL&quot;&gt;&lt;/a&gt;关于ARTGL&lt;/h1&gt;&lt;p&gt;自2018四月以来从事web端图形渲染的相关工作以来，ARTGL一直作为我个人学习webgl渲染的s
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>台湾之旅</title>
    <link href="http://yoursite.com/2019/03/10/taiwan-travel-first/"/>
    <id>http://yoursite.com/2019/03/10/taiwan-travel-first/</id>
    <published>2019-03-09T16:00:00.000Z</published>
    <updated>2020-08-23T07:00:50.629Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/taiwan-travel-first/building.png" style="max-height:100vh"></p><p>台湾可能是我业余之时了解相对多的地方，读书的时候有大把的空闲时间却没有去，而工作以后忙于工作，抽不开身。但机会总归来了，也有幸能比我想的早的多的时间来到这方土地。我对台湾自小就充满好奇和好感，早些年晚上在电视上很喜欢看一档节目叫海峡两岸，无论是阿扁入狱，各种案发，还是蓝绿两营争执打架，选战局势分析，都非常精彩和有趣，各种人慷慨激昂妙语成珠，非常有观赏价值，很多情景都显得浮夸和不可思议。台湾的作家我主要阅读过龙应台，首当一提的是《野火集》，让我对台湾的政治，文化有些入迷，事实上是我对台湾人，对台湾地区，甚至包括香港啊之类的华人社会的兴趣，使得我看了她其他的一些作品包括《目送》《安德烈》《大江大海一九四九》等，台湾的风土人情，人们如何生活，这片土地上发生的故事，与故土的羁绊等等等等，都让我觉得向往。关于观光景点，在很久我也有些了解，主要是一些杂志，《中国国家地理》《往来》，我也有些地理类的书籍，多有介绍，简而言之，中华文化在台湾有了很好的保存，形成了一个独立的成熟的华人社会文化生态，甚至我感到庆幸。此去台湾，行程五日四晚，台北台南越两日，虽不能尽兴，但如此富有魅力之地想必以后也会再来观光和体验。</p><p><img src="/images/taiwan-travel-first/101.png" style="max-height:100vh"></p><p>读书时喜欢建筑，台北壹零壹在我看来是工程和美学结合的典范，多部纪录片都印象深刻，今日终于登塔，可惜天公不美难以领略台北全景。</p><p><img src="/images/taiwan-travel-first/city.png" style="max-height:100vh"></p><p>台北故宫，也有些许遗憾，两件镇馆之宝都在外展出。不过论宝物文物富集程度，大大超过大陆的博物馆，老蒋把好东西几乎都带走了。购书一册收录藏品一百件供收藏学习</p><p><img src="/images/taiwan-travel-first/book.png" style="max-height:100vh"></p><p>台北街景，还有若干夜市照，手机曝光时间过长手抖成色不是很理想，就从简挑选几张</p><p><img src="/images/taiwan-travel-first/street.png" style="width:100%"></p><p><img src="/images/taiwan-travel-first/taibei.png" style="width:100%"></p><p>此时我正在台湾的垦丁，垦丁在台湾的最最南方，宾馆对面一家7-11上写了国境之南，让我突然想起多年之前看过的《海角七号》，里边《国境之南》这歌我喜欢，而此地就是国境之南，也是海角七号的取景地。</p><p><img src="/images/taiwan-travel-first/kendin.png" style="width:100%"></p><p><img src="/images/taiwan-travel-first/cave.png" style="max-height:100vh"></p><p><img src="/images/taiwan-travel-first/sea.png" style="width:100%"></p><p><img src="/images/taiwan-travel-first/wave.png" style="width:100%"></p><p>从台北到台南的高铁上， 途径台湾西海岸诸城市，城市乡村，平原山脉风光都尽收眼底。高速公路，农田，工厂，输电塔，以及天边的阿里山，构成了台湾相间的主要意象。台湾之旅给了我非常好的体验，无论是风光景色，还是每一个接触到的好客的有趣的台湾人，都让我对这里感到流连忘返。</p><p><img src="/images/taiwan-travel-first/highway.png" style="width:100%"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/taiwan-travel-first/building.png&quot; style=&quot;max-height:100vh&quot;&gt;&lt;/p&gt;&lt;p&gt;台湾可能是我业余之时了解相对多的地方，读书的时候有大把的空闲时间却没有去，而工作以后忙于工作，抽不开身。但
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Build 3dmax scene from vrscene</title>
    <link href="http://yoursite.com/2019/03/06/vrscene-in-3dsmax/"/>
    <id>http://yoursite.com/2019/03/06/vrscene-in-3dsmax/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2020-08-23T07:00:50.630Z</updated>
    
    <content type="html"><![CDATA[<p>最近因业务需求需要将vrscene格式的文件导入到3dmax中。 3dsmax是广泛应用的建模软件， vrscene是 VRay 渲染器的场景描述文件，而 VRay 是当下最流行的离线渲染器。3dmax在安装了vray渲染器的插件之后，是支持vrsene文件的导入的，但是导入之后，在3dmax中是以vray的proxy形式存在，无法进行任何编辑操作。 根据vray的官方文档，vrscene仅仅是作为vray渲染器在不同建模平台进行数据交换的格式，并不支持反向导入到各个平台，形成可编辑的场景数据。我在maya上的测试结果也显示，vrscene是不支持反向导入成为可编辑数据的。而公司的业务要求后续的工作流需要vrscene的导入结果是正常的3dmax场景图对象，如何支持vrscene在3dmax中导入成可编辑对象，是我们主要讨论和解决的问题。</p><h2 id="关于vrscene格式"><a href="#关于vrscene格式" class="headerlink" title="关于vrscene格式"></a>关于vrscene格式</h2><p>即便vray非常流行，但是vrscene这个格式鲜有人知道，以至于网上这方面的资料很少。vrscene是VRay渲染引擎用来进行渲染的专用文件格式，本质上是一个字符串文本。这个文件格式包含了所有渲染所必须的信息，包括模型三维空间信息、材质信息、相机视角、渲染设置等。</p><p>我们的业务需要，只提取了部分关心的数据，其中，最主要最的部分如下图所示：</p><p><img src="/images/vrscene-in-3dsmax/hierachy.png" style="width:80%"></p><p>(2019/6/6补充： 后续支持了更多的plugin，比这个图复杂一倍。。)</p><h2 id="为什么vrscene不支持导入成为可编辑对象"><a href="#为什么vrscene不支持导入成为可编辑对象" class="headerlink" title="为什么vrscene不支持导入成为可编辑对象?"></a>为什么vrscene不支持导入成为可编辑对象?</h2><p>vrscene不支持这样的特性，我认为是有一定原因的。vray以插件形式支持了非常多种类的建模软件，每一种建模软件，都有自己的场景系统，材质系统，vray对渲染的支持，其实是将每一种不同的描述体系，映射到自己的体系中，vrscene的材质／场景描述体系，包括扩展能力，一般都比具体一种建模软件大，所以vrscene的描述体系，事实上几乎是各个建模软件的超集。 从软件的体系，导出到vrscene的体系，是没什么问题的，但是反过来，就是从超集回到子集的过程，不同的建模软件，子集是不同的，所以势必是有一些数据，vrscne可以描述，但是建模软件不行，所以就会丢失数据。 索性这部分都不做了。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>vrscene 本身场景格式易于解析，我调研了一些具体的文件，以及3dmax的api，最后的解决方案是，<strong>直接在3dmax中解析vrscene，并使用相关api进行构建</strong>。除此之外没有太多其他可行的做法。毕竟根据我们的需求，性能并不重要, 正确性只要基本满足就可以。</p><p>正确性理论上是无法满足的，正如上文提到的，我举几个例子。3dmax的blendmaterial和vraymaterial导出的vrscene，plugin object 都是BRDFLayered，但是他们无论是用法和效果都有很大不同。又比如你画一个几何体，这时候3dmax里它是一个无材质的东西，不过在viewport里是有颜色的，这个无材质的东西导出却是有材质的BRDFDiffuse。。 所以很多东西事实上只能模拟, 不必强求。</p><h2 id="主要解析流程"><a href="#主要解析流程" class="headerlink" title="主要解析流程"></a>主要解析流程</h2><p>1 从字符串解析出数据结构，这部分使用基于pyparing单文件的parser combinator库，构建vrscene文法，然后直接解析到嵌套的字典结构。 这部分主要参考了<a href="https://github.com/ChaosGroup/blender_with_vray_additions" target="_blank" rel="noopener">vb30</a>（一个python的blender插件，也是导入vrscene，不过不是用来构建场景）的解析部分， 这部分在它的 <a href="https://github.com/ChaosGroup/vray_for_blender_python_utils" target="_blank" rel="noopener">submodule</a> 里， 主要是这个<a href="https://github.com/ChaosGroup/vray_for_blender_python_utils/blob/master/VRaySceneParser.py" target="_blank" rel="noopener">文件</a>, 不过有一些bug，而且不支持include指令，不支持中文（3dmax的python执行环境是2.7），不过这些都不难解决。</p><p>2 遍历字典提取几何数据，和关心的plugin object 到集中的map。</p><p>3 针对关心的plugin object，以自底向上的顺序，构建贴图，材质，xx等中间资源。<strong>因为缺乏python api，具体的创建使用拼接maxscript字符串并执行实现</strong>。材质名，vrscene字段名，mapName，等通过查表批量生成，特殊情况特殊对待。plugin之间的依赖以vrscene中的name为uuid。</p><p>针对每一种pluginObject，lookuptable的构造和流程基本如下图所示。</p><p><img src="/images/vrscene-in-3dsmax/lookuptable.png" style="width:100%"></p><p>自底向上构建，是为了防止资源重复创建。在子plugin的构建中，使用 <a href="http://help.autodesk.com/view/3DSMAX/2017/ENU/?guid=__files_GUID_D10CEFAB_E451_4A63_968E_01AEDEFCE928_htm" target="_blank" rel="noopener">currentMaterialLibrary</a> 来存储创建的对象，虽然这个东西是materiallib，但实测是可以作为通用的map来存储贴图，dirt和falloff等plugin的</p><p>4 最后遍历node map， 使用3dmax python api构建场景节点，并解压和去编码几何数据，创建几何对象，材质部分直接assign之前构建的中间对象。完成场景的构建。</p><p>这部分最坑的是，算是3dmax的python api了，3dmax主要支持三种语言，c++写lib插件，python或者maxscript写脚本，其中c++的sdk，算是一等公民的支持， maxscript作为平台独占的脚本，也是一等支持，但是python真的是不行，无论是文档，还是开发体验，都特别垃圾。文档只有接口列表，使用全部靠猜，至今还没有找到正确实现mesh的normal导入方法。开发调试时，代码有改动需要重启整个应用才能生效，似乎是因为在某个地方缓存了pyc文件。每当看着3dmax重启，界面巨卡无比，老态龙钟的样子，非常无奈。 并不要因为3dmax是多么的著名而认为它是一个好的软件，在很多地方上，我觉得充斥着糟粕。很多功能，就比如python的支持，根本就是为了支持而支持，就是完成任务，根本没有考虑用户怎么使用，好不好用，也事实上鲜有用户在使用这些功能。</p><h3 id="其他参考资料"><a href="#其他参考资料" class="headerlink" title="其他参考资料"></a>其他参考资料</h3><p><a href="http://docs.autodesk.com/3DSMAX/16/ENU/3ds-Max-Python-API-Documentation/index.html" target="_blank" rel="noopener">3dmax python API 2014</a></p><p><a href="http://help.autodesk.com/view/3DSMAX/2018/ENU/?guid=__developer_maxplus_python_api_introduction_working_with_objects_html" target="_blank" rel="noopener">build geometry use python</a></p><p><a href="https://clara.io/learn/user-guide/data_exchange/vrscene_import" target="_blank" rel="noopener">clara.io vrscene</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近因业务需求需要将vrscene格式的文件导入到3dmax中。 3dsmax是广泛应用的建模软件， vrscene是 VRay 渲染器的场景描述文件，而 VRay 是当下最流行的离线渲染器。3dmax在安装了vray渲染器的插件之后，是支持vrsene文件的导入的，但是导
      
    
    </summary>
    
      <category term="techology" scheme="http://yoursite.com/categories/techology/"/>
    
    
      <category term="3dsmax, vrscene" scheme="http://yoursite.com/tags/3dsmax-vrscene/"/>
    
  </entry>
  
  <entry>
    <title>New clean land for posting</title>
    <link href="http://yoursite.com/2019/03/04/from-mkalex-to-next/"/>
    <id>http://yoursite.com/2019/03/04/from-mkalex-to-next/</id>
    <published>2019-03-03T16:00:00.000Z</published>
    <updated>2020-08-23T07:00:50.627Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于-mkalex-com"><a href="#关于-mkalex-com" class="headerlink" title="关于 mkalex.com"></a>关于 mkalex.com</h2><p>认识我的朋友可能知道我有一个个人网站 mkalex.com， 今天我决定将不再维护该站点的开发迭代，包括内容的更新。原有的内容将在后续几月经过筛选迁移于此，很遗憾部分内容将不再公开。 mkalex.com的域名目前将暂时不迁移使用。</p><p>这么做出于这么一些因素考虑： 原有的站点主要是一个基于 Vue 的 SPA 应用 (<a href="https://github.com/mikialex/mkalex-spa" target="_blank" rel="noopener">mkalex-spa</a>)， 前后端分离， 后端使用nodejs， 数据持久化在mysql中 ((<a href="https://github.com/mikialex/mkalex-rest-backend" target="_blank" rel="noopener">mkalex-rest-backend</a>))。这些都是我在业余时间实现并开源的，样式和交互精心设计，称得上作品。 放弃原有的站点主要是因为维护的时间精力成本较大，我其实并不需要一个完整的带后端的动态网站， 原有的站点完全没有利用到后端的特性，甚至连一个评论系统都没有实现，而没有实现的原因是我的业余时间实在有限，我也不想在宝贵的业余时间里写一些枯燥的 CURD，不仅没有什么乐趣，也没有太大价值。 原有的站点，较为复杂的部分不是提供给用户的前端，而是写给自己的管理端，实话说这部分做的并不令人满意，而这部分的开发和设计都多有欠缺，要是做好，需要投入更大的经历。 在过去一年中，我有很多好的想法，好的idea， 很多想尝试的原型，都需要业余时间，而时间不可能再被分给 CURD 上了。 所以 我一直在考虑将站点的架构更改为纯静态的形式，不仅能够大大减少代码维护的心智负担，也能让我把时间投入到更多有趣的事情上，毕竟我已经不会看到自己写的开发的东西出现在互联网上而感到兴奋了。</p><p>其二的原因， 除了开发的心智负担就是运维心智负担，静态的server真的省心太多了，随便什么地方都可以轻松部署。 比起在数据库里的文章，我更觉得躺在磁盘上的文件更有安全感和可读性可操作性。并不是折腾不来，总之就是懒得折腾吧。 其三的原因还在于，由于使用了 SPA 的模式，所以 SEO 就完全不复存在了，我觉得有些东西写出来，给自己看其实意义不大，我还是希望更多人能够看到，特别是技术方面的，能够帮助到一些，交流一些，认识一些朋友。 当然，我也考虑说整体迁移到nuxt， 做同构渲染，但是依然是原因1，没有太大精力和推动力做这件事情。</p><p>其四的原因，是国内备案的繁琐和不快。这就是除了技术之外的另一个麻烦之处了，工信部的备案我很早就做了，手续还不算太过麻烦，体验还不算差。但前两个月，阿里云突然告诉我说要去做上海公安局的备案，然后去一个什么网一搞搞很久，那个破网站竟然还是使用同步的ajax请求，这种垃圾是如何上线来祸害我们这些开发者呢？然后很搞笑的是，还要让我提供最高权限的管理员账户来做审核。 我是真的有点被国内的网络环境所恶心到了，我也不想再国内搞下去了，索性整站静态化，迁到github page上算了。 于是就有了现在你所看到的 new clean land。</p><h2 id="New-clean-land-for-posting"><a href="#New-clean-land-for-posting" class="headerlink" title="New clean land for posting"></a>New clean land for posting</h2><p>总之，算是一个全新的开始吧。 很多时候，过于追求强大和自由，但是自己真的需要吗，未必见得。我希望能把事情做的简单和纯粹，这也是我自认为智慧的生活信条。我也希望自己能够更加重视内容本身的产出，回归写作思考交流的本质。</p><p><img src="/images/from-mkalex-to-next/land.png" style="width:100%"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于-mkalex-com&quot;&gt;&lt;a href=&quot;#关于-mkalex-com&quot; class=&quot;headerlink&quot; title=&quot;关于 mkalex.com&quot;&gt;&lt;/a&gt;关于 mkalex.com&lt;/h2&gt;&lt;p&gt;认识我的朋友可能知道我有一个个人网站 mkalex.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>移动设备 WebGL 优化</title>
    <link href="http://yoursite.com/2018/11/17/mobile-device-webgl-optimization/"/>
    <id>http://yoursite.com/2018/11/17/mobile-device-webgl-optimization/</id>
    <published>2018-11-16T16:00:00.000Z</published>
    <updated>2020-08-23T07:00:50.628Z</updated>
    
    <content type="html"><![CDATA[<p>移动设备的GPU性能限制主要体现在两个方面：着色器计算和带宽，所以移动设备的 webgl 优化也主要围绕这两个方面进行。</p><h4 id="减少带宽使用"><a href="#减少带宽使用" class="headerlink" title="减少带宽使用"></a>减少带宽使用</h4><p>关于带宽的问题，我的理解是，为了让设备发挥最大性能，肯定是需要处理器满载的，满载需要有源源不断的数据从存储运进去，同时把结果运回存储，如果你的处理器很强，但是带宽不够，那就无法发挥性能，或者说如果你的程序需要大量的访问数据，那么在带宽上就很容易形成瓶颈。带宽的瓶颈在桌面平台还好，移动设备就非常明显。距离来说带宽最大的，是独立显卡，独立的显存和图形处理器之间的数据交换可以达到几百GB每秒，然后是核显，会弱一些，最弱的是移动设备，显示数据是共享设备的内存的，高带宽的使用甚至会影响整个soc的性能表现。</p><p>在webgl应用中可以通过不同方法减少带宽使用。</p><p>1 在webgl canvas合成期间保证没有额外的副本和操作存在，context的获取设置中。preserveDrawingBuffer总是false。alpha不需要就不开。</p><p>2 尽可能减少材质和帧缓存的分辨率。如果材质都是一些低频的内容，降低分辨率并不会在视觉上造成显著影响。现在移动设备，屏幕分辨率都非常高，小小的手机屏幕的像素数量甚至超过桌面屏幕， 所以牺牲显示效果，减少帧缓存的分辨率也能起到作用。</p><p>3尽可能的减少后处理的步骤，最好压缩成一个，最好没有后处理。</p><p>关于 preserveDrawingBuffer：webgl 的canvas使用双缓冲区进行工作，preserveDrawingBuffer 默认是关的，就是正常的双缓冲工作模式： 一个用来显示，一个用来绘制，下一帧这两个buffer会交换，显示上一帧绘制的，画上一帧用来显示的。如果 preserveDrawingBuffer 设置为 true，那么就不会发生交换，而是把上一帧绘制的buffer，复制到显示的buffer一遍，在带宽上具有很大开销。 preserveDrawingBuffer也并不是没用的东西，比如如果需要读取像素，或者复用绘制到主屏幕上的图像，比如实现脏矩形渲染优化，那么就非开不可。</p><h4 id="优化着色器执行"><a href="#优化着色器执行" class="headerlink" title="优化着色器执行"></a>优化着色器执行</h4><p>通过将shader替换成最简单的shader，可以立刻确认webgl应用的性能瓶颈是否在shader执行上。具体的shader优化是一门大学问，这里只提几个通用的点。关于着色器优化我想我会在其他文中集中总结。</p><p>1.退而求其次，使用简单的着色和光照模型。这一点就不多说了，就是牺牲效果换取性能。</p><p>2.在 CPU 端对drawcall进行深度排序，缓解 overdraw。 但是要注意的是，这可能将渲染的瓶颈转移到CPU端，除了排序本身的成本，另外主要是不恰当的排序会导致gl状态不必要的切换。drawcall 排序也是一门学问，关于drawcall排序的内容应该也需要单独总结。</p><p>3.降低shader精度，但是有没有效果，完全取决于具体硬件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;移动设备的GPU性能限制主要体现在两个方面：着色器计算和带宽，所以移动设备的 webgl 优化也主要围绕这两个方面进行。&lt;/p&gt;&lt;h4 id=&quot;减少带宽使用&quot;&gt;&lt;a href=&quot;#减少带宽使用&quot; class=&quot;headerlink&quot; title=&quot;减少带宽使用&quot;&gt;&lt;/a&gt;减
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>根据ANGLE 实现原理的 WebGL优化建议</title>
    <link href="http://yoursite.com/2018/11/17/webgl-opti-guide/"/>
    <id>http://yoursite.com/2018/11/17/webgl-opti-guide/</id>
    <published>2018-11-16T16:00:00.000Z</published>
    <updated>2020-08-23T07:00:50.631Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/webgl-opti-guide/anglelayer.png" style="width:100%;max-width:300px"></p><blockquote><p>本文来自 webGL insights 的第一章节阅读整理</p></blockquote><p>chrome 浏览器目前在使用份额上表现出统治性的地位，而 windows 则是最常用的个人桌面操作系统，所以 windows 平台下 chrome 的一些 webgl 的优化知识需要被重点关注。在windows平台下，chrome 和 firefox 的 webgl 后端支持是 ANGLE 。ANGLE 是 Google 发起的开源项目，最初是为了使用 D3D 9 来实现 OpenGL es 2.0，而 WebGL 正是基于前者。当然， chrome不仅把 ANGLE 作为 webGL 的后端，还用来支持整个浏览器的渲染加速。现在 ANGLE 不仅拥有 D3D 9的后端， 还有 D3D 11 以及 OpenGL的后端，可以说是将 opengl es 的 API 移植到桌面的首选支持。</p><p>ANGLE 会将 webgl 使用的 glsl 翻译成 d3d 的 hlsl， 并且运行时验证 gl 的调用是否合法。所有的基于状态机的光栅化 API，都无非是设置状态，和执行渲染命令。ANGLE 会将等价的状态设置和等价的渲染调用进行翻译，直接使用底层 API，所以只有很小的性能损失。ANGLE 并不是一个模拟器。</p><p>因为 OpenGL 和 D3D 在本身的设计和支持上存在差异，所以一些 OpenGL 原先轻而易举可以做的事情，不一定能很好的映射到对应的高效的 D3D 实现， 所以在 ANGLE 的基础上，我们可以总结出一些最佳实践。归纳如下。</p><h5 id="避免使用LINE-LOOP-和-TRIANGLE-FAN"><a href="#避免使用LINE-LOOP-和-TRIANGLE-FAN" class="headerlink" title="避免使用LINE_LOOP 和 TRIANGLE_FAN"></a>避免使用LINE_LOOP 和 TRIANGLE_FAN</h5><p>D3D 里没有 LINE_LOOP 这种 DrawMode，TRIANGLE_FAN 在 D3D 11 里不被支持。ANGLE 需要重写 index buffer来支持。</p><h5 id="总是使用新的纹理，而不是对旧的做出修改"><a href="#总是使用新的纹理，而不是对旧的做出修改" class="headerlink" title="总是使用新的纹理，而不是对旧的做出修改"></a>总是使用新的纹理，而不是对旧的做出修改</h5><p>D3D 的纹理 API 需要在创建纹理的时候，就确定所有参数。而为了支持纹理属性的修改，ANGLE 需要维护多份纹理拷贝，并且在绘制时产生额外的延迟。</p><h5 id="在剪切和蒙板开启时，不要-执行Clear操作"><a href="#在剪切和蒙板开启时，不要-执行Clear操作" class="headerlink" title="在剪切和蒙板开启时，不要 执行Clear操作"></a>在剪切和蒙板开启时，不要 执行Clear操作</h5><p>D3D 的 clear 操作会无视剪切和蒙板，而 GL clear 时会考虑剪切和蒙板。 ANGLE 需要绘制一个四边形来支持剪切效果，并且产生额外的状态切换成本。</p><h5 id="使用多边形来实现带宽度的线"><a href="#使用多边形来实现带宽度的线" class="headerlink" title="使用多边形来实现带宽度的线"></a>使用多边形来实现带宽度的线</h5><p>chrome 的 webgl 线宽不被支持时一个很经典的事情，甚至在汇报 chrome bug 的网站，chrome 的开发者直接回应说，“线的宽度是个没有意义的概念” 这个事情想想真的比较搞笑。不过从数学的意义上讲，线的宽度的确还真的没有什么意义。</p><p>任何现代图形硬件上，带宽度的线都不是原生的基本图元。所以需要模拟实现，这个模拟，要么应用层来做，要么驱动层来做。带宽度的线其实很复杂，joint style各种各样，今天支持了这种，明天还会有人问为什么不支持那一种，所以其实我也是认同 chrome 的做法的，这个事情就应该放在应用层实现。</p><h5 id="在顶点-Buffer-中，避免使用三通道的-Uint8Array／Uint16Array"><a href="#在顶点-Buffer-中，避免使用三通道的-Uint8Array／Uint16Array" class="headerlink" title="在顶点 Buffer 中，避免使用三通道的 Uint8Array／Uint16Array"></a>在顶点 Buffer 中，避免使用三通道的 Uint8Array／Uint16Array</h5><p>主要是 D3D 底层对三通道的数据支持有限， ANGLE 会自己转成四通道的数据。如果是 dynamic 的， 甚至每次画之前都会转换。</p><h5 id="在索引-Buffer-中，-避免使用-Uint8Array"><a href="#在索引-Buffer-中，-避免使用-Uint8Array" class="headerlink" title="在索引 Buffer 中， 避免使用 Uint8Array"></a>在索引 Buffer 中， 避免使用 Uint8Array</h5><p>D3D 不支持在索引 Buffer 中使用 8位的数据。ANGLE 会转化回 16 位格式。</p><h5 id="避免在-16位索引-Buffer-中，使用-0xFFFF-值"><a href="#避免在-16位索引-Buffer-中，使用-0xFFFF-值" class="headerlink" title="避免在 16位索引 Buffer 中，使用 0xFFFF 值"></a>避免在 16位索引 Buffer 中，使用 0xFFFF 值</h5><p>在 D3D 11 中， 这个值具有特殊意义，代表三角形 strip-cut， 当是，这个是个 bug 被发现才被改正的。 ANGLE 一旦发现有这个值，会直接转化使用 32 位的数据。</p><h5 id="正确使用-buffer-标记"><a href="#正确使用-buffer-标记" class="headerlink" title="正确使用 buffer 标记"></a>正确使用 buffer 标记</h5><p>需要 STATIC_DRAW , 就指明。不然，ANGLE 会反复在内部执行数据转换。</p><h5 id="总是指明片元着色器浮点精度"><a href="#总是指明片元着色器浮点精度" class="headerlink" title="总是指明片元着色器浮点精度"></a>总是指明片元着色器浮点精度</h5><p>之前据说写不写无所谓，后来强制必须要写了。。</p><h5 id="不要使用-Rendering-Feedback-Loops"><a href="#不要使用-Rendering-Feedback-Loops" class="headerlink" title="不要使用 Rendering Feedback Loops"></a>不要使用 Rendering Feedback Loops</h5><p>Rendering Feedback Loops 是指同时在同一个纹理上进行渲染和采样，／／我都不知道可以这样？？ 总之 只有D3D 9 支持，现在一定都不支持。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/webgl-opti-guide/anglelayer.png&quot; style=&quot;width:100%;max-width:300px&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;本文来自 webGL insights 的第一章节阅读整理&lt;/p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基础的片元着色器技巧</title>
    <link href="http://yoursite.com/2018/11/06/simple-frag-shader/"/>
    <id>http://yoursite.com/2018/11/06/simple-frag-shader/</id>
    <published>2018-11-05T16:00:00.000Z</published>
    <updated>2020-08-23T07:00:50.629Z</updated>
    
    <content type="html"><![CDATA[<p>整理一些通用的非常非常基础的片元着色器技巧。</p><p>从来没有接触过片元着色器的朋友可以去看看thebookofshaders这个网站，非常不错//。顺便，它有一个交互的编辑器日常可以玩玩。 <a href="http://editor.thebookofshaders.com/SLWRZ/" target="_blank" rel="noopener">http://editor.thebookofshaders.com/SLWRZ/</a> (maybe需要科学上网). 。</p><h3 id="随机性"><a href="#随机性" class="headerlink" title="随机性"></a>随机性</h3><p>一般来说shader里高效的生成随机数，这个随机性一般来自对一个超高频的函数进行采样。创造一个超高频的函数很简单，首先需要有周期性，所以三角函数一般是需要的，你可以把一个sin，振幅给的非常大，然后取小数，这就是一般shader里随机数生成的常用做法，我自己尝试了直接用一个超高频的sin，效果也不错，但可能再结合其他函数还是会暴露周期性，所以可能有时候不适用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">rand</span><span class="params">(<span class="keyword">float</span> n)</span></span>&#123;<span class="keyword">return</span> fract(<span class="built_in">sin</span>(n) * <span class="number">43758.5453123</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">rand</span><span class="params">(<span class="keyword">float</span> n)</span></span>&#123;<span class="keyword">return</span> (<span class="built_in">sin</span>(n * <span class="number">1234567.0</span>));&#125;</span><br></pre></td></tr></table></figure><p>二维随机数: 和一维的一样，需要把二维降到一维，这里可以用一个点积。因为点积的结果，在xy两个轴分别看上去，其实线性的，另外一个维度就是截距的不同，所以可以直接用一维的方法，并不会在某个方向产生不均匀的问题（假设你一维的方法能够保证随机性）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">rand</span><span class="params">(vec2 n)</span> </span>&#123; </span><br><span class="line"><span class="keyword">return</span> fract(<span class="built_in">sin</span>(dot(n, vec2(<span class="number">12.9898</span>, <span class="number">4.1414</span>))) * <span class="number">43758.5453</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时候为了更好的质量，可以再乘一个dot过的sin在里边。</p><h3 id="简单噪声"><a href="#简单噪声" class="headerlink" title="简单噪声"></a>简单噪声</h3><p>噪声同时包含了随机性的连续性。纯粹的随机是完全离散的，除了概率毫无规律的，跳跃的，当我们试图在一个规整的，几何的形态上，引入随机性的因素，可以创造出有机的自然的形态。下面这个basic的noise，是在整数位上做随机，然后中间直接插值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">noise</span><span class="params">(<span class="keyword">float</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">float</span> fl = <span class="built_in">floor</span>(p);</span><br><span class="line">    <span class="keyword">float</span> fc = fract(p);</span><br><span class="line"><span class="keyword">return</span> mix(rand(fl), rand(fl + <span class="number">1.0</span>), smoothstep(<span class="number">0.</span>,<span class="number">1.</span>,fc));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">noise</span><span class="params">(vec2 n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">const</span> vec2 d = vec2(<span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    vec2 b = <span class="built_in">floor</span>(n);</span><br><span class="line">    vec2 f = smoothstep(vec2(<span class="number">0.0</span>), vec2(<span class="number">1.0</span>), fract(n));</span><br><span class="line"><span class="keyword">return</span> mix(mix(rand(b), rand(b + d.yx), f.x), </span><br><span class="line">               mix(rand(b + d.xy), rand(b + d.yy), f.x)</span><br><span class="line">               , f.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">noise</span><span class="params">(vec2 p)</span></span>&#123;</span><br><span class="line">vec2 ip = <span class="built_in">floor</span>(p);</span><br><span class="line">vec2 u = fract(p);</span><br><span class="line">u = u*u*(<span class="number">3.0</span><span class="number">-2.0</span>*u);</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> res = mix(</span><br><span class="line">mix(rand(ip),rand(ip+vec2(<span class="number">1.0</span>,<span class="number">0.0</span>)),u.x),</span><br><span class="line">mix(rand(ip+vec2(<span class="number">0.0</span>,<span class="number">1.0</span>)),rand(ip+vec2(<span class="number">1.0</span>,<span class="number">1.0</span>)),u.x),u.y);</span><br><span class="line"><span class="keyword">return</span> res*res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般这种simple value noise的patten是，floor你的变量，拿到离散的整数位，fract你的变量，拿到一个单位跨度的连续增长，在离散的整数位上做随机，然后用这个整数位间的连续量做插值，插值的效果，比如过渡的方法，通过影射插值连续量实现，比如smooth，比如上面第二个noise的多项式。</p><blockquote><p>value noise一般非常块状，为了消除这种块状的效果，在 1985 年 <a href="https://mrl.nyu.edu/~perlin/" target="_blank" rel="noopener">Ken Perlin</a> 开发了另一种 noise 算法 Gradient Noise。Ken 解决了如何插入随机的 gradients（梯度、渐变）而不是一个固定值。这些梯度值来自于一个二维的随机函数，返回一个方向（vec2 格式的向量），而不仅是一个值（float格式）。</p></blockquote><p>各种高级的noise可以参考 <a href="https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83" target="_blank" rel="noopener">https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83</a></p><h3 id="平移旋转缩放"><a href="#平移旋转缩放" class="headerlink" title="平移旋转缩放"></a>平移旋转缩放</h3><p>这个没有什么好说的，把matrix乘到归一化的coord上就可以, 比如旋转。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">mat2 <span class="title">rotate2d</span><span class="params">(<span class="keyword">float</span> _angle)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mat2(<span class="built_in">cos</span>(_angle),-<span class="built_in">sin</span>(_angle),</span><br><span class="line">                <span class="built_in">sin</span>(_angle),<span class="built_in">cos</span>(_angle));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vec2 st = gl_FragCoord.xy/u_resolution.xy;</span><br><span class="line">st = rotate2d( PI ) * st;</span><br></pre></td></tr></table></figure><h3 id="硬边缘和重复性"><a href="#硬边缘和重复性" class="headerlink" title="硬边缘和重复性"></a>硬边缘和重复性</h3><p>典型的重复例如平铺，可以通过放大，然后取小数，重新映射回1-0的技巧实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vec2 st = gl_FragCoord.xy/u_resolution;</span><br><span class="line">   vec3 color = vec3(<span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">   st *= <span class="number">3.0</span>;      <span class="comment">// Scale up the space by 3</span></span><br><span class="line">   st = fract(st); <span class="comment">// Wrap arround 1.0</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Now we have 3 spaces that goes from 0-1</span></span><br></pre></td></tr></table></figure><p>提取奇偶项或者整数倍项的做法：利用取余</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fract(x) === mod(x,<span class="number">1.0</span>) <span class="comment">// 事实上可以替代的</span></span><br><span class="line">mod(x,<span class="number">2.0</span>) &lt; <span class="number">1.0</span> ? <span class="number">0.</span> : <span class="number">1.</span> ; <span class="comment">//偶数项</span></span><br></pre></td></tr></table></figure><p>一般如果需要生成几何类型的patten，往往是利用step或者mod判断来做出分段，patten上的任何分段，分块之类的硬边缘，几乎都是shader里的条件判断产生的。如何设计出通用的shader函数，和组合的模式，来总结出一套patten的生成方法，似乎是有趣而充满挑战的事情。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;整理一些通用的非常非常基础的片元着色器技巧。&lt;/p&gt;&lt;p&gt;从来没有接触过片元着色器的朋友可以去看看thebookofshaders这个网站，非常不错//。顺便，它有一个交互的编辑器日常可以玩玩。 &lt;a href=&quot;http://editor.thebookofshaders
      
    
    </summary>
    
    
  </entry>
  
</feed>
