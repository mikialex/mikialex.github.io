<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><title>Another approach to declarative incremental UI in Rust | mikialex</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="Recently I have had some new(maybe not at all) but simple(possibly flawed) ideas about how we architect the UI framework in an incremental and declarative way in Rust.The reason why declarative is imp"><meta property="og:type" content="article"><meta property="og:title" content="Another approach to declarative incremental UI in Rust"><meta property="og:url" content="http://mikialex.github.io/2022/11/16/incremental-ui/index.html"><meta property="og:site_name" content="mikialex"><meta property="og:description" content="Recently I have had some new(maybe not at all) but simple(possibly flawed) ideas about how we architect the UI framework in an incremental and declarative way in Rust.The reason why declarative is imp"><meta property="og:locale" content="default"><meta property="og:image" content="http://mikialex.github.io/images/incremental-ui/27.png"><meta property="og:image" content="http://mikialex.github.io/images/incremental-ui/06.png"><meta property="og:image" content="http://mikialex.github.io/images/incremental-ui/01.png"><meta property="og:updated_time" content="2023-01-08T06:04:05.493Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Another approach to declarative incremental UI in Rust"><meta name="twitter:description" content="Recently I have had some new(maybe not at all) but simple(possibly flawed) ideas about how we architect the UI framework in an incremental and declarative way in Rust.The reason why declarative is imp"><meta name="twitter:image" content="http://mikialex.github.io/images/incremental-ui/27.png"><link rel="icon" href="/favicon.png"><link href="https://fonts.googleapis.com/css?family=Crimson+Text:400,700|Inconsolata|Oswald" rel="stylesheet"><link rel="stylesheet" href="/icomoon/style.css"><link rel="stylesheet" href="/style.css"></head><body><div class="site-wrapper is_post_page"><div id="loading-bar-wrapper"><div id="loading-bar"></div></div><script>document.getElementById("loading-bar").style.width="20%"</script><header id="header" class="site-header clearfix"><a class="logo square clearfix" href="/"><span class="b">A</span> <span class="b">R</span> <span class="b">T</span> <span class="w">I</span> <span class="w">F</span> <span class="b">A</span> <span class="b">C</span> <span class="b">T</span> </a><a class="me square site-nav-switch clearfix"><span class="b"><span class="icon icon-menu"></span></span></a></header><script>document.getElementById("loading-bar").style.width="40%"</script><main id="main" class="clearfix"><article id="post-incremental-ui" class="article white-box article-type-post" itemscope itemprop="blogPost"><header class="article-header"><h1 class="article-title" itemprop="name">Another approach to declarative incremental UI in Rust</h1><div class="article-meta">Posted on <time class="article-time" datetime="2022-11-15T16:00:00.000Z" itemprop="datePublished">Nov 16, 2022</time></div></header><div class="article-entry" itemprop="articleBody"><p>Recently I have had some new(maybe not at all) but simple(possibly flawed) ideas about how we architect the UI framework in an incremental and declarative way in Rust.</p><p>The reason why declarative is important is we developers do not want to write imperative and manual view updating or create code to sync the state change with our view. So we all agreed in the industry nowadays we could use View = F(State) to directly express their relationship in a functional way.</p><p>The reason why incremental is essential is performance matters. View = F(State). is nice, but 99% time in runtime, our view receives events from the platform and modifies the application state in a very incremental behavior. The state change is super small. Rerun the view create function is wasteful and impossible(because we may lose the local state stored on view).</p><p>View = F(State) is the hardest part to be performant. So obviously, working with View-delta = F(State-delta) seems a better choice, we just apply the delta-view to the view and apply the delta-state to the state.</p><p>The question here is how could we get the delta of the state.</p><ul><li>depend on a powerful language runtime like js. watch the state change directly. (getter setter patch, proxy, GC).<ul><li>It’s hard to do in rust, not ergonomic I suppose.</li></ul></li><li>diffing the state every time when updating.<ul><li>Most rust frameworks do this but I do not favor it.<ul><li>To get reasonable performance when the state scales, the immutable data structure is a must, which means:<ul><li>Intrusive modification to the application state and how you mutate them</li></ul></li><li>Unavoidable performance overhead. (diff cost, cache locality? allocation pressure?)</li></ul></li></ul></li><li>compiler magic recognizes the state writes and triggers a reaction.<ul><li>I don’t think it’s possible in practice</li></ul></li><li>..</li></ul><p>I have to ask myself. I mutated the states, why can not I know what I have mutated? Why do I have to pay the runtime cost to know it?</p><p>My answer to this question is simple. <strong>We could just direct record the state change in an explicit way.</strong> This sounds like cheating, but reasonable. The cost we have to pay is we can not directly use the assigning operators or just call mutate function to mutate the states but create another data structure to express what mutation I will apply.</p><hr><p>In rust let’s see how we abstract this concept:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">IncrementAble</span></span> &#123;</span><br><span class="line">  <span class="comment">/// `Delta` should be strictly the smallest atomic modification unit of `Self`</span></span><br><span class="line">  <span class="comment">/// atomic means no invalid states between the modification</span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Delta</span></span>;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Error</span></span>: <span class="built_in">Debug</span>; <span class="comment">// apply delta may be failed due to invalid inputs</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// apply the mutations to the data</span></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">apply</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, delta: Self::Delta) -&gt; <span class="built_in">Result</span>&lt;(), Self::Error&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// generate a sequence of the delta. use this we could </span></span><br><span class="line">  <span class="comment">/// fully copy the Self</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">	<span class="comment">/// This method is crucial</span></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">expand</span></span>(&amp;<span class="keyword">self</span>, cb: <span class="keyword">impl</span> <span class="built_in">FnMut</span>(Self::Delta));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// type alias for convenience</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">type</span> <span class="title">DeltaOf</span></span>&lt;T&gt; = &lt;T <span class="keyword">as</span> IncrementAble&gt;::Delta;</span><br></pre></td></tr></table></figure><p>To implement this for primitive types we could just:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> IncrementAble <span class="keyword">for</span> <span class="built_in">u32</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Delta</span></span> = <span class="keyword">Self</span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Error</span></span> = ();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">apply</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, delta: Self::Delta) -&gt; <span class="built_in">Result</span>&lt;(), Self::Error&gt; &#123;</span><br><span class="line">    *<span class="keyword">self</span> = delta;</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">expand</span></span>(&amp;<span class="keyword">self</span>, <span class="keyword">mut</span> cb: <span class="keyword">impl</span> <span class="built_in">FnMut</span>(Self::Delta)) &#123;</span><br><span class="line">    cb(<span class="keyword">self</span>.clone())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>To implement this for container types we could:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">VecDelta</span></span>&lt;T: IncrementAble&gt; &#123;</span><br><span class="line">  Push(T),</span><br><span class="line">  Remove(<span class="built_in">usize</span>),</span><br><span class="line">  Insert(<span class="built_in">usize</span>, T),</span><br><span class="line">  Mutate(<span class="built_in">usize</span>, DeltaOf&lt;T&gt;), <span class="comment">// note this: how we composing inner delta type</span></span><br><span class="line">  Pop,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: IncrementAble + <span class="built_in">Default</span>&gt; IncrementAble <span class="keyword">for</span> <span class="built_in">Vec</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Delta</span></span> = VecDelta&lt;T&gt;;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Error</span></span> = (); <span class="comment">// omit</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">apply</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, delta: Self::Delta) -&gt; <span class="built_in">Result</span>&lt;(), Self::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> delta &#123;</span><br><span class="line">      VecDelta::Push(value) =&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.push(value);</span><br><span class="line">      &#125;</span><br><span class="line">      VecDelta::Remove(index) =&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.remove(index);</span><br><span class="line">      &#125;</span><br><span class="line">      VecDelta::Insert(index, item) =&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.insert(index, item);</span><br><span class="line">      &#125;</span><br><span class="line">      VecDelta::Pop =&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.pop().unwrap();</span><br><span class="line">      &#125;</span><br><span class="line">      VecDelta::Mutate(index, delta) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> inner = <span class="keyword">self</span>.get_mut(index).unwrap();</span><br><span class="line">        inner.apply(delta).unwrap();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="literal">Ok</span>(()) </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// note here we call every vec item recursively</span></span><br><span class="line"><span class="comment">// to fully expand the vec (actually virtually rebuild from empty default)</span></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">expand</span></span>(&amp;<span class="keyword">self</span>, <span class="keyword">mut</span> cb: <span class="keyword">impl</span> <span class="built_in">FnMut</span>(Self::Delta)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i, v) <span class="keyword">in</span> <span class="keyword">self</span>.iter().enumerate() &#123;</span><br><span class="line">      cb(VecDelta::Push(T::default()));</span><br><span class="line">      v.expand(|d| &#123; </span><br><span class="line">        cb(VecDelta::Mutate(i, d));</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Compose type(the type we define in our apps usually)</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TodoItem</span></span> &#123;</span><br><span class="line">  name: <span class="built_in">String</span>,</span><br><span class="line">  finished: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// actually convert the product type to sum type.</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TodoItemChange</span></span> &#123;</span><br><span class="line">  Finished(<span class="built_in">bool</span>),</span><br><span class="line">  Name(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> IncrementAble <span class="keyword">for</span> TodoItem &#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Delta</span></span> = TodoItemChange;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Error</span></span> = ();</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">apply</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, delta: Self::Delta) -&gt; <span class="built_in">Result</span>&lt;(), Self::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> delta &#123;</span><br><span class="line">      TodoItemChange::Finished(v) =&gt; <span class="keyword">self</span>.finished.apply(v)?,</span><br><span class="line">      TodoItemChange::Name(v) =&gt; <span class="keyword">self</span>.name.apply(v)?,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">expand</span></span>(&amp;<span class="keyword">self</span>, <span class="keyword">mut</span> cb: <span class="keyword">impl</span> <span class="built_in">FnMut</span>(Self::Delta)) &#123;</span><br><span class="line">    cb(TodoItemChange::Name(<span class="keyword">self</span>.name.clone()));</span><br><span class="line">    cb(TodoItemChange::Finished(<span class="keyword">self</span>.finished.clone()));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This could be directly derived by macros:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Incremental)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TodoList</span></span> &#123;</span><br><span class="line">  list: <span class="built_in">Vec</span>&lt;TodoItem&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Incremental, Default)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TodoItem</span></span> &#123;</span><br><span class="line">  name: <span class="built_in">String</span>,</span><br><span class="line">  finished: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Your app state is the composition of these types. By trait work, we could simply implement incrementable to any(almost) T automatically.</p><p>The T::Delta is a strict complex sum type. Let’s reason about it from a low-level perspective.</p><ul><li>Memory cost<ul><li>almost as same as the delta except for the enum tags which map the hierarchy of your app states hierarchy. I suppose it’s not a big problem. For tree-like states, you could just use the flattened tree container to avoid the recursive behavior in the type level.</li></ul></li><li>Delta constructing cost<ul><li>user should usually only construct sub-delta because the user only works with sub-state. For example, the user modifies a sub-state by creating a sub-delta, then the sub-delta pop up to the parent wrapping type and is wrapped in the parent delta type. Pop and pop until it converts into the root app state delta type.</li><li>Stack data move trivial cost exists but should be optimized by the compiler as long as the call inlines. I suppose.</li></ul></li><li>Apply cost<ul><li>The complex root state delta is used to consume in actual mutation apply or checked by the other code(like when we do view state update). This boil down to how pattern matching works in rust, which is zero abstraction cost.</li></ul></li><li>App state expand all delta cost<ul><li>this is as same as the delta constructing cost. But this point is our expand method is passing a callback to implementation. So deltas are created one by one in a deep call stack and void any unnecessary heap allocations(if our delta type does not contain heap allocation)</li><li>Like the code above, the Vec’s implementation of Incrementable. We have to create an item default before we apply item mutations. This cost is ok and essential I think. The default value should be trivial for containers and small types</li></ul></li></ul><p><strong>My conclusion is: Working with(store, passing, using incrementable API) delta types is good(in ergonomics and performance way), even if the delta type and state type are super complex(has a deep hierarchy in type level).</strong></p><hr><p>Now let’s see how we use this delta abstraction in incremental UI:</p><p>(note, in this part, we omit super large details such as view implementations(such as rendering layout, platform event), and only focus on how state changes incremental update the view)</p><p>This trait is to express our view</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// represent the mouse keyboard, file, network events</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">PlatformEvent</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/// View type could generics over any state T, as long as the T could provide</span></span><br><span class="line"><span class="comment">/// given logic for view type.</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">View</span></span>&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">  T: IncrementAble,</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/// sepcial event type</span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Event</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// In event loop handling, view type received platform events such as mouse move keyboard events,</span></span><br><span class="line">  <span class="comment">/// and decide should react to it or not, if so, generate the mutation for state or emit</span></span><br><span class="line">  <span class="comment">/// the self::Event for further outer side handling. see ViewReaction.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// In the View hierarchy, event's mutation to state will pop up to the root, wrap the mutation to</span></span><br><span class="line">  <span class="comment">/// parent state's delta type. and in update logic, consumed from the root</span></span><br><span class="line">	<span class="comment">///</span></span><br><span class="line">	<span class="comment">/// the reaction is handled in callback</span></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">event</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, model: &amp;T, event: &amp;PlatformEvent, cb: <span class="keyword">impl</span> <span class="built_in">FnMut</span>(ViewReaction&lt;Self::Event, T&gt;));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// update is responsible for mapping the state delta to view property change</span></span><br><span class="line">  <span class="comment">/// the model here is unmodified by delta.</span></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">update</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, model: &amp;T, delta: &amp;T::Delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">ViewReaction</span></span>&lt;V, T: IncrementAble&gt; &#123;</span><br><span class="line">  <span class="comment">/// emit self-special event</span></span><br><span class="line">  ViewEvent(V),</span><br><span class="line">  <span class="comment">/// do state mutation</span></span><br><span class="line">  StateDelta(T::Delta),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>the event method is the user update logic in the below graph. Mapping the platform events to state(T) delta(T::Delta) or just emit custom ViewEvent for outer parent view(and the parent view will handle the child view event by converting to parent state change as well).</p><p><img src="/images/incremental-ui/27.png" alt="Screen Shot 2022-11-14 at 20.46.27.png"></p><p>The delta(purple below) will be poped to the app root level state and then using the view’s update method to propagate changes. The view instance, I mean any other view instance(not restricted to the one which produces the delta), could check the super complex delta type and decide if the change is useful for their own. So the property binding simply becomes pattern matching the delta and extracts the real delta.</p><p><img src="/images/incremental-ui/06.png" alt="Screen Shot 2022-11-14 at 20.47.06.png"></p><p>how state delta bind to view property: the same idea as above.</p><p><img src="/images/incremental-ui/01.png" alt="Screen Shot 2022-11-14 at 20.47.01.png"></p><hr><p>I will next demonstrate some pseudo-code for this concept.</p><p>If there is a simple Todo app. The final UI code could be like this: The style is similar to the druid, but rely on the incrementable trait to work with the state instead of the druid’s data trait. You can see how we express explicit delta and bind delta to properties here.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define the state.</span></span><br><span class="line"><span class="meta">#[derive(Incremental)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TodoList</span></span> &#123;</span><br><span class="line">  list: <span class="built_in">Vec</span>&lt;TodoItem&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Incremental, Default)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TodoItem</span></span> &#123;</span><br><span class="line">  name: <span class="built_in">String</span>,</span><br><span class="line">  finished: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">todo_list_view</span></span>() -&gt; <span class="keyword">impl</span> View&lt;TodoList, Event = ()&gt; &#123;</span><br><span class="line">  Container::wrap(</span><br><span class="line">    TextBox::placeholder(<span class="string">"what needs to be done?"</span>)</span><br><span class="line">      .on(submit(|value| &#123; <span class="comment">// handle view events</span></span><br><span class="line">        TodoListChange::List(VecDelta::Push(TodoItem &#123; </span><br><span class="line">          name: value, <span class="comment">// you can see we explicitly express delta</span></span><br><span class="line">          finished: <span class="literal">false</span>,</span><br><span class="line">        &#125;))</span><br><span class="line">      &#125;)),</span><br><span class="line">    List::for_by(todo_item_view)</span><br><span class="line">      .lens(lens!(TodoList::list)) <span class="comment">// yes we use druid lens to extract sub state</span></span><br><span class="line">      .on(inner(|event| TodoListChange::List(VecDelta::Remove(event.index)))), <span class="comment">// handle view events</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TodoItemEvent</span></span> &#123;</span><br><span class="line">  DeleteSelf,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">todo_item_view</span></span>() -&gt; <span class="keyword">impl</span> View&lt;TodoItem, Event = TodoItemEvent&gt; &#123;</span><br><span class="line">  Container::wrap(</span><br><span class="line">    Title::name(bind!(Name)), <span class="comment">// bind the name delta to name property</span></span><br><span class="line">    Toggle::status(bind!(Finished)), <span class="comment">// ditto</span></span><br><span class="line">    Button::name(<span class="string">"delete"</span>)</span><br><span class="line">      .on(click(|event, item| TodoItemEvent::Delete)),</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In the view’s building blocks, we can see how they implement the view trait:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TextBox</span></span>&lt;T: IncrementAble&gt; &#123;</span><br><span class="line">  texting: <span class="built_in">String</span>,</span><br><span class="line"><span class="comment">// this is the binding: check the delta if the delta we care and extract</span></span><br><span class="line">  text_binding: <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> <span class="built_in">Fn</span>(&amp;DeltaOf&lt;T&gt;) -&gt; <span class="built_in">Option</span>&lt;&amp;<span class="built_in">String</span>&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TextBoxEvent</span></span> &#123;</span><br><span class="line">  Submit(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: IncrementAble&gt; View&lt;T&gt; <span class="keyword">for</span> TextBox&lt;T&gt; &#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Event</span></span> = TextBoxEvent;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">event</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, model: &amp;T, event: &amp;PlatformEvent, <span class="keyword">mut</span> cb: <span class="keyword">impl</span> <span class="built_in">FnMut</span>(ViewReaction&lt;Self::Event, T&gt;)) &#123;</span><br><span class="line">    <span class="keyword">let</span> react = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// omit processing logic</span></span><br><span class="line">    <span class="keyword">if</span> react &#123;</span><br><span class="line">      cb(ViewReaction::ViewEvent(TextBoxEvent::Submit(<span class="keyword">self</span>.texting.clone())))</span><br><span class="line">    &#125; </span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">update</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, model: &amp;T, delta: &amp;T::Delta) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(new) = (<span class="keyword">self</span>.text_binding)(&amp;delta) &#123;</span><br><span class="line">      <span class="keyword">self</span>.texting = new.clone(); <span class="comment">// do the real view state sync</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The property binding: check the delta if it’s what I want:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: IncrementAble&gt; TextBox&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">with_text</span></span>(<span class="keyword">mut</span> <span class="keyword">self</span>, binder: <span class="keyword">impl</span> <span class="built_in">Fn</span>(&amp;DeltaOf&lt;T&gt;) -&gt; <span class="built_in">Option</span>&lt;&amp;<span class="built_in">String</span>&gt; + <span class="symbol">'static</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.text_binding = <span class="built_in">Box</span>::new(binder);</span><br><span class="line">    <span class="keyword">self</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">_test</span></span>(text: TextBox&lt;TodoItem&gt;) &#123;</span><br><span class="line">  text.with_text(bind!(DeltaOf::&lt;TodoItem&gt;::Name)); <span class="comment">// may be could shorter?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> bind &#123;</span><br><span class="line">  ($Variant: path) =&gt; &#123;</span><br><span class="line">    |delta| &#123;</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> $Variant(name) = delta &#123;</span><br><span class="line">        <span class="literal">Some</span>(&amp;name)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Another important one is the container type or the combinator type, which composites a complex view type to form our UI. Here we use the List as an example.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// V is Itemlist's View item type</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span></span>&lt;V&gt; &#123;</span><br><span class="line">  views: <span class="built_in">Vec</span>&lt;V&gt;,</span><br><span class="line">  build_item_view: <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> <span class="built_in">Fn</span>() -&gt; V&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;V&gt; List&lt;V&gt; &#123;</span><br><span class="line">  <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">for_by</span></span>(view_builder: <span class="keyword">impl</span> <span class="built_in">Fn</span>() -&gt; V + <span class="symbol">'static</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="keyword">Self</span> &#123;</span><br><span class="line">      views: <span class="built_in">Default</span>::default(),</span><br><span class="line">      build_item_view: <span class="built_in">Box</span>::new(view_builder),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wrapper for the inner view event</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EventWithIndex</span></span>&lt;T&gt; &#123;</span><br><span class="line">  event: T,</span><br><span class="line">  index: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: IncrementAble + <span class="built_in">Default</span>, V: View&lt;T&gt;&gt; View&lt;<span class="built_in">Vec</span>&lt;T&gt;&gt; <span class="keyword">for</span> List&lt;V&gt; &#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Event</span></span> = EventWithIndex&lt;V::Event&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">event</span></span>(</span><br><span class="line">    &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">    model: &amp;<span class="built_in">Vec</span>&lt;T&gt;,</span><br><span class="line">    event: &amp;PlatformEvent,</span><br><span class="line">    <span class="keyword">mut</span> cb: <span class="keyword">impl</span> <span class="built_in">FnMut</span>(ViewReaction&lt;Self::Event, <span class="built_in">Vec</span>&lt;T&gt;&gt;),</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i, view) <span class="keyword">in</span> <span class="keyword">self</span>.views.iter_mut().enumerate() &#123;</span><br><span class="line">      view.event(model.get(i).unwrap(), event, |e| &#123;</span><br><span class="line"><span class="comment">// this is so called delta pop</span></span><br><span class="line">        cb(<span class="keyword">match</span> e &#123;</span><br><span class="line">          ViewReaction::ViewEvent(e) =&gt; ViewReaction::ViewEvent(EventWithIndex &#123; index: i, event: e &#125;),</span><br><span class="line">          ViewReaction::StateDelta(delta) =&gt; ViewReaction::StateDelta(VecDelta::Mutate(i, delta)),</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">update</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, model: &amp;<span class="built_in">Vec</span>&lt;T&gt;, delta: &amp;DeltaOf&lt;<span class="built_in">Vec</span>&lt;T&gt;&gt;) &#123;</span><br><span class="line">    <span class="keyword">match</span> delta &#123;</span><br><span class="line">      VecDelta::Push(v) =&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.views.push((<span class="keyword">self</span>.build_item_view)());</span><br><span class="line">        <span class="keyword">let</span> pushed = <span class="keyword">self</span>.views.last_mut().unwrap();</span><br><span class="line">        v.expand(|d| pushed.update(v, &amp;d));</span><br><span class="line">      &#125;</span><br><span class="line">      VecDelta::Remove(_) =&gt; todo!(),<span class="comment">// omit</span></span><br><span class="line">      VecDelta::Insert(_, _) =&gt; todo!(),</span><br><span class="line">      VecDelta::Mutate(index, d) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> v = model.get(*index).unwrap();</span><br><span class="line">        <span class="keyword">let</span> view = <span class="keyword">self</span>.views.get_mut(*index).unwrap();</span><br><span class="line">        view.update(v, d)</span><br><span class="line">      &#125;</span><br><span class="line">      VecDelta::Pop =&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.views.pop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The trick part in List is the vector’s push in the update method. Imagine our todo item view type watched the delta of todo item fields, but we never watch the entire todo item create. This is also the tricky part when you hand-write view update logic: you have to both handle the creating and updating, which is not declarative. To solve this problem we use Incremtable’s expand method. <strong>Expand method provides a way to normalize all state creating to state updating. So we could only work with the update. The declarative core is not over the create but the update.</strong></p><p>The List example also shows the potential ways to support item move or swap. In other frameworks, item states should be labeled uniquely to maintain a stable identity across the list and to recognize moving action when updating. Now, if we simply support the swap or move mutation variant in delta type. this problem does even not exist.</p><p>Another question is, the state in view trait is immutable, but who should modify the state in the end? Of course the state owner. The state owner could be the root view to hold our app state. The important is, any state delta will be pop the state owner and then processed, which guaranteed any state delta dependent no matter how far they are, they could listen to the right same change. The immutable state access in the trait also guaranteed the state will not be changed accidentally, only the owner has the right to do the delta broadcast and real modification.</p><p><strong>Fundamentally, the complex-composed delta type effectively encodes the data mutation path at the type level on delta type. As long as the mutation path is unique, the mutation could be safely watched.</strong></p><p>This restriction means the interior mutable types should be ruled out for our state. Because an <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> could be shared in your state tree, which means you could modify the state by a different visit path from the root state type. It’s impractical for the view, the delta watcher side to handle all modification paths. So keep your state a clean tree. if you need to use graph data structure, simply use the arena solution but not build graph node by hand with <code>rc refcell</code>. I think this restriction also applies to immutable data structures.</p><p>I don’t know if there are mathematic tools to describe the T versus T::Delta, the state space versus state change space. Working with the T maybe should have some homotopy way to work with T::Delta? If we purely think in T::Delta space, seems a promising way to solve the reactive incremental UI problem.</p><hr><p>In summary, the data flow is entirely based on the delta, so the cost of view update strictly follows the delta quantities and how complicated we process the delta. The view trait guided strong view type composition is suitable for compiler optimization to produce efficient UI code.</p><p>Compare to other solutions, especially the diffing. Besides the better performance potential, we don’t need to change our data type intrusively and depend on the opaque immutable containers with sophisticated algorithms, just define a new mutation interface for old data, a new way to modify our state. Compare to the reactive watch solutions, this approach provides a full-detail, hierarchy app-level source of truth delta, which could be watched and react at any granularity.</p><p>The Incrementable trait could also provide encapsulation for other advance incremental compute subsystems. Bridge them all together and create complex applications with incremental performance implications.</p><hr><p>Further interesting direction: The incrementable trait could be modified to support the reversed delta. The reversed delta is the opposite of the delta, effectively canceling out the original delta. This could abstract the incremental undo-redo ability.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Not all types can impl this kind of reversible delta</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">ReverseIncrementAble</span></span>: IncrementAble &#123;</span><br><span class="line">  <span class="comment">/// return reversed delta</span></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">apply_rev</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, delta: Self::Delta) -&gt; <span class="built_in">Result</span>&lt;Self::Delta, Self::Error&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Not all types could provide an effective (not clone all(except for immutable data structure)) implementation, because information may be lost in the transformation.</p><p>This ability enables us to record all the app state history in a compact efficient way. We could use the delta to do something interesting like time traveling and debugging.</p></div><div class="article-tags"></div></article><script>document.getElementById("loading-bar").style.width="60%"</script></main><footer id="footer" class="clearfix"><div>&copy; mikialex Theme by <a href="http://artifact.me/" target="_blank">Art Chen</a>.</div><div>Powered by <a href="https://hexo.io/" rel="external">Hexo</a>.</div></footer><script>document.getElementById("loading-bar").style.width="80%"</script><div class="overlay"></div></div><div class="site-sidebar"><div class="sidebar-switch clearfix" style="display:none"><a class="dark-btn active" data-toggle="toc"><span class="icon icon-list"></span> <span class="text">Index</span> </a><a class="dark-btn" data-toggle="bio"><span class="icon icon-person"></span> <span class="text">Bio</span></a></div><div class="site-toc" style="display:none"><div class="no-index">No Index</div></div><div class="site-bio show" style="display:block"><div class="about-me clearfix"><div class="avatar"><img src="/img/avatar.png"></div><div class="info"><a class="name dark-btn" href="/about">miki alex</a></div><div class="info"><span class="item desc"></span></div></div><div class="social clearfix"><a href="/atom.xml" class="feed" target="_blank" rel="external"><span class="icon icon-feed"></span> </a><a href="https://github.com/mikialex" class="github" target="_blank" rel="external"><span class="icon icon-github"></span></a></div></div><div class="shortcuts"><a href="#header" class="top window-nav dark-btn" id="go-top"><span class="icon icon-chevron-thin-up"></span> </a><a class="close dark-btn" id="sidebar-close"><span class="icon icon-close"></span> </a><a href="#footer" class="top window-nav dark-btn" id="go-bottom"><span class="icon icon-chevron-thin-down"></span></a></div></div><script type="text/javascript">var GOOGLE_CUSTOM_SEARCH_API_KEY="",GOOGLE_CUSTOM_SEARCH_ENGINE_ID="",ALGOLIA_API_KEY="",ALGOLIA_APP_ID="",ALGOLIA_INDEX_NAME="",AZURE_SERVICE_NAME="",AZURE_INDEX_NAME="",AZURE_QUERY_KEY="",BAIDU_API_ID="",SEARCH_SERVICE="google",universalSearchConfig={};"google"===SEARCH_SERVICE?universalSearchConfig={searchService:SEARCH_SERVICE,apiKey:GOOGLE_CUSTOM_SEARCH_API_KEY,engineId:GOOGLE_CUSTOM_SEARCH_ENGINE_ID,imagePath:"/img/"}:"algolia"===SEARCH_SERVICE?universalSearchConfig={searchService:SEARCH_SERVICE,apiKey:ALGOLIA_API_KEY,appId:ALGOLIA_APP_ID,indexName:ALGOLIA_INDEX_NAME,imagePath:"/img/"}:"azure"===SEARCH_SERVICE&&(universalSearchConfig={searchService:SEARCH_SERVICE,serviceName:AZURE_SERVICE_NAME,indexName:AZURE_INDEX_NAME,apiKey:AZURE_QUERY_KEY,imagePath:"/img/"})</script><script src="https://code.jquery.com/jquery-2.1.4.min.js"></script><script>window.jQuery||document.write('<script src="/js/jquery.js"><\/script>')</script><script src="/js/search.js"></script><script src="/js/app.js"></script><script>document.getElementById("loading-bar").style.width="100%"</script></body></html>