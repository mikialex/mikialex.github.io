<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><title>wgpu read notes | mikialex</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="长期以来，各个操作系统，平台，厂商的发展出了多套现代的图形API，使得跨平台图形开发存在巨大的开发成本和兼容性问题。成熟的渲染引擎，一般都实现了一套跨平台的渲染抽象层用以封装和抹平不同图形API接口和使用的差异。但这样一套成体系的抽象层并没有一个公认的实现标准。web graphics，作为跨平台渲染最重要的应用场景，长期以来使用老旧的opengl es标准，无法满足未来图形应用的发展需求，web"><meta name="keywords" content="webgpu, wgpu, graphics"><meta property="og:type" content="article"><meta property="og:title" content="wgpu read notes"><meta property="og:url" content="http://mikialex.github.io/2022/04/21/wgpu-read-notes/index.html"><meta property="og:site_name" content="mikialex"><meta property="og:description" content="长期以来，各个操作系统，平台，厂商的发展出了多套现代的图形API，使得跨平台图形开发存在巨大的开发成本和兼容性问题。成熟的渲染引擎，一般都实现了一套跨平台的渲染抽象层用以封装和抹平不同图形API接口和使用的差异。但这样一套成体系的抽象层并没有一个公认的实现标准。web graphics，作为跨平台渲染最重要的应用场景，长期以来使用老旧的opengl es标准，无法满足未来图形应用的发展需求，web"><meta property="og:locale" content="default"><meta property="og:image" content="http://mikialex.github.io/images/wgpu-read-notes/big-picture.png"><meta property="og:updated_time" content="2022-04-21T14:40:43.366Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="wgpu read notes"><meta name="twitter:description" content="长期以来，各个操作系统，平台，厂商的发展出了多套现代的图形API，使得跨平台图形开发存在巨大的开发成本和兼容性问题。成熟的渲染引擎，一般都实现了一套跨平台的渲染抽象层用以封装和抹平不同图形API接口和使用的差异。但这样一套成体系的抽象层并没有一个公认的实现标准。web graphics，作为跨平台渲染最重要的应用场景，长期以来使用老旧的opengl es标准，无法满足未来图形应用的发展需求，web"><meta name="twitter:image" content="http://mikialex.github.io/images/wgpu-read-notes/big-picture.png"><link rel="icon" href="/favicon.png"><link href="https://fonts.googleapis.com/css?family=Crimson+Text:400,700|Inconsolata|Oswald" rel="stylesheet"><link rel="stylesheet" href="/icomoon/style.css"><link rel="stylesheet" href="/style.css"></head><body><div class="site-wrapper is_post_page"><div id="loading-bar-wrapper"><div id="loading-bar"></div></div><script>document.getElementById("loading-bar").style.width="20%"</script><header id="header" class="site-header clearfix"><a class="logo square clearfix" href="/"><span class="b">A</span> <span class="b">R</span> <span class="b">T</span> <span class="w">I</span> <span class="w">F</span> <span class="b">A</span> <span class="b">C</span> <span class="b">T</span> </a><a class="me square site-nav-switch clearfix"><span class="b"><span class="icon icon-menu"></span></span></a></header><script>document.getElementById("loading-bar").style.width="40%"</script><main id="main" class="clearfix"><article id="post-wgpu-read-notes" class="article white-box article-type-post" itemscope itemprop="blogPost"><header class="article-header"><h1 class="article-title" itemprop="name">wgpu read notes</h1><div class="article-meta">Posted on <time class="article-time" datetime="2022-04-20T16:00:00.000Z" itemprop="datePublished">Apr 21, 2022</time></div></header><div class="article-entry" itemprop="articleBody"><p>长期以来，各个操作系统，平台，厂商的发展出了多套现代的图形API，使得跨平台图形开发存在巨大的开发成本和兼容性问题。成熟的渲染引擎，一般都实现了一套跨平台的渲染抽象层用以封装和抹平不同图形API接口和使用的差异。但这样一套成体系的抽象层并没有一个公认的实现标准。web graphics，作为跨平台渲染最重要的应用场景，长期以来使用老旧的opengl es标准，无法满足未来图形应用的发展需求，webgpu成为大家的众望所归，不仅解决了web上下一代图形api的形态问题，更重要的是为桌面端跨平台渲染提供了一个最稳固的标准实现。</p><p>wgpu是rust的webgpu实现，目前被应用在firefox，deno等项目中实现webgpu支持。本文将介绍一下wgpu体系的整体架构，并针对性的对核心模块实现进行分析和摘录。此文基于wgpu 0.12.0的实现。</p><p>整个wgpu体系是较为复杂的(core 2w，hal 2w)，无论其核心模块还是hal实现都包含大量的细节，本文不会面面俱到指出所有细节。仅仅是从笔者自己关心的方向，进行探索性的阅读，重点将放在wgpu-core的资源管理上，不保证分析完全的正确性或是是否符合作者的本意。</p><p><img src="/images/wgpu-read-notes/big-picture.png" alt="big-picture"></p><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>根据上图：整个体系最重要的有3个crate组成：wgpu-hal：设计和实现了渲染抽象层：同时支持vk，metal，dx，opengl，多个后端。向外暴露出一组unsafe的需要手工管理资源的接口。wgpu-core：wgpu的核心实现，主要完成对标准的实现以及资源管理。对外暴露出真正的native版本的webgpu接口。wgpu：为rust应用提供的上层webgpu接口，完成native，web多实现的封装。</p><p>使用wgpu，可以使得你的rust程序编译为native的应用程序（使用wgpu-core的native实现），或是wasm版本的web应用程序（使用浏览器接口，如果是firefox，firefox底层还是会使用wgpu-core）或是native版的其他语言实现（比如chrome的dawn，这一点通过wgpu-native/wgpu headers完成）wgpu不仅承担了选择native还是web的逻辑，还有具体使用哪个图形api的逻辑，如果不加指定，wgpu会根据你的编译平台自行选择。</p><p>naga是个重要的模块，其完成的职责是shader的转换翻译和validation，webgpu可以使用wgsl，spirv等shader格式，但对于各个后端支持而言，需要进行shader翻译工作。同时webgpu作为safe的api，需要对shader和相关shader绑定的声明进行运行时验证，甚至对shader内部逻辑进行调整以满足安全性需求。naga的内部架构主要是一套树形的IR，支持多个shader语言的前后端，来完成转译工作。naga会基于IR执行一些分析和验证工作，但不会涉及到优化。</p><p>对于有更高性能要求，不希望wgpu-core做任何验证和资源管理的，可以直接使用wgpu-hal unsafe的api，wgpu-hal其实就是gfx-rs的简约版</p><h2 id="抽象层"><a href="#抽象层" class="headerlink" title="抽象层"></a>抽象层</h2><h3 id="web-native抽象层"><a href="#web-native抽象层" class="headerlink" title="web/native抽象层"></a>web/native抽象层</h3><p>这一层是wgpu rust api的主要内容。我们日常使用的对象如buffer，texture，device等就是该层提供的。可以看到，这一层的实现其实都是一些不透明的handle对象。实际的实现通过Context这个trait的抽象层进行转发。ctx定义了若干关联类型和操作的方法。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Buffer</span></span> &#123;</span><br><span class="line">    context: Arc&lt;C&gt;,</span><br><span class="line">    id: &lt;C <span class="keyword">as</span> Context&gt;::BufferId,</span><br><span class="line">    map_context: Mutex&lt;MapContext&gt;,</span><br><span class="line">    usage: BufferUsages,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Texture</span></span> &#123;</span><br><span class="line">    context: Arc&lt;C&gt;,</span><br><span class="line">    id: &lt;C <span class="keyword">as</span> Context&gt;::TextureId,</span><br><span class="line">    owned: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Context</span></span>: <span class="built_in">Debug</span> + <span class="built_in">Send</span> + <span class="built_in">Sized</span> + <span class="built_in">Sync</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">AdapterId</span></span>: <span class="built_in">Debug</span> + <span class="built_in">Send</span> + <span class="built_in">Sync</span> + <span class="symbol">'static</span>;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">DeviceId</span></span>: <span class="built_in">Debug</span> + <span class="built_in">Send</span> + <span class="built_in">Sync</span> + <span class="symbol">'static</span>;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">QueueId</span></span>: <span class="built_in">Debug</span> + <span class="built_in">Send</span> + <span class="built_in">Sync</span> + <span class="symbol">'static</span>;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">ShaderModuleId</span></span>: <span class="built_in">Debug</span> + <span class="built_in">Send</span> + <span class="built_in">Sync</span> + <span class="symbol">'static</span>;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">BindGroupLayoutId</span></span>: <span class="built_in">Debug</span> + <span class="built_in">Send</span> + <span class="built_in">Sync</span> + <span class="symbol">'static</span>;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">init</span></span>(backends: Backends) -&gt; <span class="keyword">Self</span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">instance_create_surface</span></span>(</span><br><span class="line">        &amp;<span class="keyword">self</span>,</span><br><span class="line">        handle: &amp;<span class="keyword">impl</span> raw_window_handle::HasRawWindowHandle,</span><br><span class="line">    ) -&gt; Self::SurfaceId;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">instance_request_adapter</span></span>(</span><br><span class="line">        &amp;<span class="keyword">self</span>,</span><br><span class="line">        options: &amp;RequestAdapterOptions&lt;<span class="symbol">'_</span>&gt;,</span><br><span class="line">    ) -&gt; Self::RequestAdapterFuture;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">adapter_request_device</span></span>(</span><br><span class="line">        &amp;<span class="keyword">self</span>,</span><br><span class="line">        adapter: &amp;Self::AdapterId,</span><br><span class="line">        desc: &amp;DeviceDescriptor,</span><br><span class="line">        trace_dir: <span class="built_in">Option</span>&lt;&amp;std::path::Path&gt;,</span><br><span class="line">    ) -&gt; Self::RequestDeviceFuture;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">instance_poll_all_devices</span></span>(&amp;<span class="keyword">self</span>, force_wait: <span class="built_in">bool</span>);</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">adapter_is_surface_supported</span></span>(</span><br><span class="line">        &amp;<span class="keyword">self</span>,</span><br><span class="line">        adapter: &amp;Self::AdapterId,</span><br><span class="line">        surface: &amp;Self::SurfaceId,</span><br><span class="line">    ) -&gt; <span class="built_in">bool</span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">adapter_features</span></span>(&amp;<span class="keyword">self</span>, adapter: &amp;Self::AdapterId) -&gt; Features;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在wgpu/src/backend下可以找到direct和web版本的实现。</p><p>对于direct的实现，会直接使用wgpu-core的类型，对于web的实现，会直接使用web sys提供的类型（其实就是js对象）。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Context</span></span>(wgc::hub::Global&lt;wgc::hub::IdentityManagerFactory&gt;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> crate::Context <span class="keyword">for</span> Context &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">AdapterId</span></span> = wgc::id::AdapterId;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">DeviceId</span></span> = Device;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">QueueId</span></span> = wgc::id::QueueId;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">ShaderModuleId</span></span> = wgc::id::ShaderModuleId;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">BindGroupLayoutId</span></span> = wgc::id::Bi</span><br><span class="line">	...</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span>(<span class="keyword">crate</span>) <span class="class"><span class="keyword">struct</span> <span class="title">Context</span></span>(web_sys::Gpu);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> crate::Context <span class="keyword">for</span> Context &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">AdapterId</span></span> = Sendable&lt;web_sys::GpuAdapter&gt;;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">DeviceId</span></span> = Sendable&lt;web_sys::GpuDevice&gt;;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">QueueId</span></span> = Sendable&lt;web_sys::GpuQueue&gt;;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">ShaderModuleId</span></span> = Sendable&lt;web_sys::GpuShaderModule&gt;;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">BindGroupLayoutId</span></span> = Sendable&lt;web_sys::GpuBindGroupLayout&gt;;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">BindGroupId</span></span> = Sendable&lt;web_sys::GpuBindGroup&gt;;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">TextureViewId</span></span> = Sendable&lt;web_sys::GpuTextureView&gt;;</span><br></pre></td></tr></table></figure><h3 id="渲染抽象层"><a href="#渲染抽象层" class="headerlink" title="渲染抽象层"></a>渲染抽象层</h3><p>另一套抽象层就是wgpu-core要使用的wgpu-hal，这其实是多套trait,定义了很多类型和他们之间需要交互的protocal。其后端实现在wgpu-hal下可以找到。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Api</span></span>: <span class="built_in">Clone</span> + <span class="built_in">Sized</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Instance</span></span>: Instance&lt;<span class="keyword">Self</span>&gt;;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Surface</span></span>: Surface&lt;<span class="keyword">Self</span>&gt;;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Adapter</span></span>: Adapter&lt;<span class="keyword">Self</span>&gt;;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Device</span></span>: Device&lt;<span class="keyword">Self</span>&gt;;</span><br><span class="line">		...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Instance</span></span>&lt;A: Api&gt;: <span class="built_in">Sized</span> + <span class="built_in">Send</span> + <span class="built_in">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">init</span></span>(desc: &amp;InstanceDescriptor) -&gt; <span class="built_in">Result</span>&lt;<span class="keyword">Self</span>, InstanceError&gt;;</span><br><span class="line">    <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">create_surface</span></span>(</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Surface</span></span>&lt;A: Api&gt;: <span class="built_in">Send</span> + <span class="built_in">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">configure</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        device: &amp;A::Device,</span><br><span class="line">        config: &amp;SurfaceConfiguration,</span><br><span class="line">    ) -&gt; <span class="built_in">Result</span>&lt;(), SurfaceError&gt;;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Adapter</span></span>&lt;A: Api&gt;: <span class="built_in">Send</span> + <span class="built_in">Sync</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如何在上层做类型擦除？</strong></p><p>wgpu的前身的gfx-rs，这个项目是将所有api封装成一套unsafe的vulkan like api。这个项目如果使用不当的话，可能会造成的麻烦的是，后端的类型作为泛型参数，如果不加控制，会一路pop到最上层的用户接口，比如camera。这是非常不合理的。简而言之，将这个类型进行擦除，wgpu的做法是通过cargo feature对指定的类型别名进行条件编译，除了类型别名，大量direct后端实现会直接调用接口会通过gfx_select！宏来转发，而宏展开的内部也会应用相同的feature逻辑</p><h2 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h2><p>使用webgpu，而不是其他抽象层，重要的原因，其实是安全性/便捷性。用户不需要手工管理图形资源，不用担心正在使用的资源被错误的释放，不用担心没有插入正确的同步调用，等等。自然这些职责就落在在实现者上。</p><p>理解wgpu如何做好资源管理是比较重要的，原因其一是作为上层用户的使用者，webgpu内部的资源管理显然是一个具有overhead的黑盒，通过阅读实现可以帮助理解和避免高成本的api错误用法。其二是通过阅读实现也能学习到如何高效的安全的合理的对现代unsafe图形api进行资源管理。</p><h3 id="资源管理器结构"><a href="#资源管理器结构" class="headerlink" title="资源管理器结构"></a>资源管理器结构</h3><p>从理解数据结构开始。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Global</span></span>&lt;G: GlobalIdentityHandlerFactory&gt; &#123;</span><br><span class="line"><span class="comment">// 实际渲染后端的instance类型</span></span><br><span class="line">    <span class="keyword">pub</span> instance: Instance,</span><br><span class="line"><span class="comment">// 管理swapchain相关</span></span><br><span class="line">    <span class="keyword">pub</span> surfaces: Registry&lt;Surface, id::SurfaceId, G&gt;,</span><br><span class="line">    hubs: Hubs&lt;G&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际存储后端的图形资源的容器集合</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Hub</span></span>&lt;A: hal::Api, F: GlobalIdentityHandlerFactory&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> adapters: Registry&lt;Adapter&lt;A&gt;, id::AdapterId, F&gt;,</span><br><span class="line">    <span class="keyword">pub</span> devices: Registry&lt;Device&lt;A&gt;, id::DeviceId, F&gt;,</span><br><span class="line">    <span class="keyword">pub</span> pipeline_layouts: Registry&lt;PipelineLayout&lt;A&gt;, id::PipelineLayoutId, F&gt;,</span><br><span class="line">    <span class="keyword">pub</span> shader_modules: Registry&lt;ShaderModule&lt;A&gt;, id::ShaderModuleId, F&gt;,</span><br><span class="line">    <span class="keyword">pub</span> bind_group_layouts: Registry&lt;BindGroupLayout&lt;A&gt;, id::BindGroupLayoutId, F&gt;,</span><br><span class="line">    <span class="keyword">pub</span> bind_groups: Registry&lt;BindGroup&lt;A&gt;, id::BindGroupId, F&gt;,</span><br><span class="line">    <span class="keyword">pub</span> command_buffers: Registry&lt;CommandBuffer&lt;A&gt;, id::CommandBufferId, F&gt;,</span><br><span class="line">    <span class="keyword">pub</span> render_bundles: Registry&lt;RenderBundle, id::RenderBundleId, F&gt;,</span><br><span class="line">    <span class="keyword">pub</span> render_pipelines: Registry&lt;RenderPipeline&lt;A&gt;, id::RenderPipelineId, F&gt;,</span><br><span class="line">    <span class="keyword">pub</span> compute_pipelines: Registry&lt;ComputePipeline&lt;A&gt;, id::ComputePipelineId, F&gt;,</span><br><span class="line">    <span class="keyword">pub</span> query_sets: Registry&lt;QuerySet&lt;A&gt;, id::QuerySetId, F&gt;,</span><br><span class="line">    <span class="keyword">pub</span> buffers: Registry&lt;Buffer&lt;A&gt;, id::BufferId, F&gt;,</span><br><span class="line">    <span class="keyword">pub</span> textures: Registry&lt;Texture&lt;A&gt;, id::TextureId, F&gt;,</span><br><span class="line">    <span class="keyword">pub</span> texture_views: Registry&lt;TextureView&lt;A&gt;, id::TextureViewId, F&gt;,</span><br><span class="line">    <span class="keyword">pub</span> samplers: Registry&lt;Sampler&lt;A&gt;, id::SamplerId, F&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储单个资源类型的容器</span></span><br><span class="line"><span class="comment">// 实际的F实现IdentityHandlerFactory事实上和Storage是配套的</span></span><br><span class="line"><span class="comment">// 由下面若干类型展开看到，某个类型的资源是以generational arena方式进行管理的</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Registry</span></span>&lt;T: Resource, I: id::TypedId, F: IdentityHandlerFactory&lt;I&gt;&gt; &#123;</span><br><span class="line">    identity: F::Filter,</span><br><span class="line">    data: RwLock&lt;Storage&lt;T, I&gt;&gt;,</span><br><span class="line">    backend: Backend, <span class="comment">// 后端类型的枚举</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Storage</span></span>&lt;T, I: id::TypedId&gt; &#123;</span><br><span class="line">    map: <span class="built_in">Vec</span>&lt;Element&lt;T&gt;&gt;,</span><br><span class="line">    kind: &amp;<span class="symbol">'static</span> <span class="built_in">str</span>,</span><br><span class="line">    _phantom: PhantomData&lt;I&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Element</span></span>&lt;T&gt; &#123;</span><br><span class="line">    Vacant,</span><br><span class="line">    Occupied(T, Epoch), <span class="comment">// Eopch就是generation</span></span><br><span class="line">    Error(Epoch, <span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 管理generational arena的freelist</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">IdentityManager</span></span> &#123;</span><br><span class="line">    free: <span class="built_in">Vec</span>&lt;Index&gt;,</span><br><span class="line">    epochs: <span class="built_in">Vec</span>&lt;Epoch&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的资源读写都需要从registry访问，考虑到后续多线程支持，registry本身是添加读写锁的。为了从根本上避免死锁问题，这里采用类型系统的技巧来从编译期避免死锁：即通过限制资源获取锁的顺序，如何限制呢：通过trait，为资源类型之间定义出一整套DAG的关系，每解开锁需要某个前序类型的token，并返回后序类型的token，以此来限制资源获取顺序。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有registry获取锁的都需要一个token，某个token的存在意味着当前某个类型的锁已经被打开了</span></span><br><span class="line"><span class="keyword">pub</span>(<span class="keyword">crate</span>) <span class="class"><span class="keyword">struct</span> <span class="title">Token</span></span>&lt;<span class="symbol">'a</span>, T: <span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">    level: PhantomData&lt;&amp;<span class="symbol">'a</span> T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Type system for enforcing the lock order on shared HUB structures.</span></span><br><span class="line"><span class="comment">/// If type A implements `Access&lt;B&gt;`, that means we are allowed to proceed</span></span><br><span class="line"><span class="comment">/// with locking resource `B` after we lock `A`.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// The implenentations basically describe the edges in a directed graph</span></span><br><span class="line"><span class="comment">/// of lock transitions. As long as it doesn't have loops, we can have</span></span><br><span class="line"><span class="comment">/// multiple concurrent paths on this graph (from multiple threads) without</span></span><br><span class="line"><span class="comment">/// deadlocks, i.e. there is always a path whose next resource is not locked</span></span><br><span class="line"><span class="comment">/// by some other path, at any time.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Access</span></span>&lt;A&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">Root</span></span> &#123;&#125;</span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> establish an order instead of declaring all the pairs.</span></span><br><span class="line"><span class="keyword">impl</span> Access&lt;Instance&gt; <span class="keyword">for</span> Root &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> Access&lt;Surface&gt; <span class="keyword">for</span> Root &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> Access&lt;Surface&gt; <span class="keyword">for</span> Instance &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;A: hal::Api&gt; Access&lt;Adapter&lt;A&gt;&gt; <span class="keyword">for</span> Root &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;A: hal::Api&gt; Access&lt;Adapter&lt;A&gt;&gt; <span class="keyword">for</span> Surface &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;A: hal::Api&gt; Access&lt;Device&lt;A&gt;&gt; <span class="keyword">for</span> Root &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;A: hal::Api&gt; Access&lt;Device&lt;A&gt;&gt; <span class="keyword">for</span> Surface &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;A: hal::Api&gt; Access&lt;Device&lt;A&gt;&gt; <span class="keyword">for</span> Adapter&lt;A&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;A: hal::Api&gt; Access&lt;PipelineLayout&lt;A&gt;&gt; <span class="keyword">for</span> Root &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;A: hal::Api&gt; Access&lt;PipelineLayout&lt;A&gt;&gt; <span class="keyword">for</span> Device&lt;A&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;A: hal::Api&gt; Access&lt;PipelineLayout&lt;A&gt;&gt; <span class="keyword">for</span> RenderBundle &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;A: hal::Api&gt; Access&lt;BindGroupLayout&lt;A&gt;&gt; <span class="keyword">for</span> Root &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;A: hal::Api&gt; Access&lt;BindGroupLayout&lt;A&gt;&gt; <span class="keyword">for</span> Device&lt;A&gt; &#123;&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h3 id="生命周期管理"><a href="#生命周期管理" class="headerlink" title="生命周期管理"></a>生命周期管理</h3><p>我们知道，当用户drop了某个buffer，但是如果某个buffer还继续被bindgroup或是其他资源继续引用，是不能在底层直接销毁的。为此，wgpu实现需要考虑如何管理相关资源生命周期的问题。</p><p>整个问题的不能全部使用传统的引用计数来解决，是因为，1 wgpu的资源是以arena方式进行存储的，通信和计算都使用handle类型，2 某个资源即便没有任何引用，如果还在gpu运行中被使用，也是不能删除的。 针对1 wgpu通过自己的refcount raii类型，实现了在arena基础之上提供一套refcount机制，针对2 wgpu为每个resource绑定最后一次commandbuffer submission的index，decive端通过gpu fence来获取当前command执行情况（哪些commnadbuffer已经被执行完毕了），通过比较last submission index便可以知道该资源是否还在gpu中正常运行需要使用。</p><p>数据结构上：对于所有资源都是由device创建和销毁，每个device own这些resource，每个device实例上有此 lifetime tracker，每次resource上面都有对应的LifeGuard。</p><p>引用关系建立，refcount raii clone可以在device创建资源的代码中找到，drop就是各个资源的drop。由于refcount是附加在resource上的，并不是包裹在resource外，所以refcount置空也不会直接释放资源，所以事实上有个类似垃圾回收的pass会定期的回收。实现位于device.maintain. tracker不仅管理资源清理，还管理buffer mapping。maintain的执行结果会返回实际要做的资源清理列表以及map成功的列表。</p><p>用户drop资源，会将资源加入tracker的 suspected_resources中，queue write texture / buffer，创建的临时buffer，会加入到future_suspected_buffers/texture中，用户异步map的buffer会被加入到mapped中。在maintain逻辑中，会调用triage_suspected（检查所有用户当前指定销毁的资源，检查是否被gpu还在使用，如果是的装在active submission list中）， triage_mapped（检查当然map的请求，哪些buffer是否gpu已经使用完毕，装在ready_to_map中）， triage_submissions（检查active submission list，即过去的待销毁但被gpu使用中的资源是否还在被gpu使用）</p><p>maintain的调用时机是每次queue submit command buffer时，或者用户显式的poll device。对于native实现如果没有queue submit，整个event loop是需要定期持续poll的，对于web，浏览器会自动做这件事情，不需要js进行调用。在queue submit时，会更新最新的submission index到各个resource，同时检查引用计数并尝试添加到suspected_resources以供下一波triage_suspected来检查清理资源。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A struct responsible for tracking resource lifetimes.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Here is how host mapping is handled:</span></span><br><span class="line"><span class="comment">///   1. When mapping is requested we add the buffer to the life_tracker list of `mapped` buffers.</span></span><br><span class="line"><span class="comment">///   2. When `triage_suspected` is called, it checks the last submission index associated with each of the mapped buffer,</span></span><br><span class="line"><span class="comment">/// and register the buffer with either a submission in flight, or straight into `ready_to_map` vector.</span></span><br><span class="line"><span class="comment">///   3. When `ActiveSubmission` is retired, the mapped buffers associated with it are moved to `ready_to_map` vector.</span></span><br><span class="line"><span class="comment">///   4. Finally, `handle_mapping` issues all the callbacks.</span></span><br><span class="line"><span class="keyword">pub</span>(<span class="keyword">super</span>) <span class="class"><span class="keyword">struct</span> <span class="title">LifetimeTracker</span></span>&lt;A: hal::Api&gt; &#123;</span><br><span class="line">    <span class="comment">/// Resources that the user has requested be mapped, but are still in use.</span></span><br><span class="line"><span class="comment">/// 用户请求异步map的buffer会添加至此</span></span><br><span class="line">    mapped: <span class="built_in">Vec</span>&lt;Stored&lt;id::BufferId&gt;&gt;,</span><br><span class="line">    <span class="comment">/// Buffers can be used in a submission that is yet to be made, by the</span></span><br><span class="line">    <span class="comment">/// means of `write_buffer()`, so we have a special place for them.</span></span><br><span class="line">    <span class="keyword">pub</span> future_suspected_buffers: <span class="built_in">Vec</span>&lt;Stored&lt;id::BufferId&gt;&gt;,</span><br><span class="line">    <span class="comment">/// Textures can be used in the upcoming submission by `write_texture`.</span></span><br><span class="line">    <span class="keyword">pub</span> future_suspected_textures: <span class="built_in">Vec</span>&lt;Stored&lt;id::TextureId&gt;&gt;,</span><br><span class="line">    <span class="comment">/// Resources that are suspected for destruction.</span></span><br><span class="line"><span class="comment">// 任何资源在用户侧被删除，会添加至此集合</span></span><br><span class="line">    <span class="keyword">pub</span> suspected_resources: SuspectedResources,</span><br><span class="line">    <span class="comment">/// Resources that are not referenced any more but still used by GPU.</span></span><br><span class="line">    <span class="comment">/// Grouped by submissions associated with a fence and a submission index.</span></span><br><span class="line">    <span class="comment">/// The active submissions have to be stored in FIFO order: oldest come first.</span></span><br><span class="line">    active: <span class="built_in">Vec</span>&lt;ActiveSubmission&lt;A&gt;&gt;,</span><br><span class="line">    <span class="comment">/// Resources that are neither referenced or used, just life_tracker</span></span><br><span class="line">    <span class="comment">/// actual deletion.</span></span><br><span class="line">    free_resources: NonReferencedResources&lt;A&gt;,</span><br><span class="line">    ready_to_map: <span class="built_in">Vec</span>&lt;id::Valid&lt;id::BufferId&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// resource本身会持有此lifeguard</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">LifeGuard</span></span> &#123;</span><br><span class="line">    ref_count: <span class="built_in">Option</span>&lt;RefCount&gt;,</span><br><span class="line"><span class="comment">// 记录该resource最后一次被commandbuffer submit的index</span></span><br><span class="line">    submission_index: AtomicUsize,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ActiveSubmission</span></span>&lt;A: hal::Api&gt; &#123;</span><br><span class="line">    index: SubmissionIndex,</span><br><span class="line">    last_resources: NonReferencedResources&lt;A&gt;,</span><br><span class="line">    mapped: <span class="built_in">Vec</span>&lt;id::Valid&lt;id::BufferId&gt;&gt;,</span><br><span class="line">    encoders: <span class="built_in">Vec</span>&lt;EncoderInFlight&lt;A&gt;&gt;,</span><br><span class="line">    work_done_closures: SmallVec&lt;[SubmittedWorkDoneClosure; <span class="number">1</span>]&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NonReferencedResources</span></span>&lt;A: hal::Api&gt; &#123;</span><br><span class="line">    buffers: <span class="built_in">Vec</span>&lt;A::Buffer&gt;,</span><br><span class="line">    textures: <span class="built_in">Vec</span>&lt;A::Texture&gt;,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span>(<span class="keyword">super</span>) <span class="class"><span class="keyword">struct</span> <span class="title">SuspectedResources</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span>(<span class="keyword">super</span>) buffers: <span class="built_in">Vec</span>&lt;id::Valid&lt;id::BufferId&gt;&gt;,</span><br><span class="line">    <span class="keyword">pub</span>(<span class="keyword">super</span>) textures: <span class="built_in">Vec</span>&lt;id::Valid&lt;id::TextureId&gt;&gt;,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Barrier生成"><a href="#Barrier生成" class="headerlink" title="Barrier生成"></a>Barrier生成</h3><p>webgpu和metal类似，而不是和dx12，vulkan，一样需要用户自行设置resource/execution barriar。对于使用dx12/vulkan等后端的实现而言，需要wgpu自行设置正确的barrier，这需要对所有resource有一套精细的状态管理工作。这部分的实现可以在wgpu-core下的 tracker看到。</p><p><strong>标准回顾</strong></p><p>为了能让底层实现正确的处理barrier，所有的资源都有usage属性需要在用户创建时提供，usage定义了/限制了资源的使用方式，具体的spec是： <a href="https://www.w3.org/TR/webgpu/#programming-model-resource-usages" target="_blank" rel="noopener">https://www.w3.org/TR/webgpu/#programming-model-resource-usages</a> 核心规则是：在任意<strong>usage scope</strong>中，对任意<strong>sub resource</strong>，包含的<strong>internal usage</strong>是必须要相<strong>兼容</strong>的, 满足这样的规则，实现才可能针对所有平台做好barrier，否则是validation bug。</p><p>这里边有四个概念：</p><p>scope：scope可以理解是在某一段api调用范围，标准在 <a href="https://www.w3.org/TR/webgpu/#programming-model-synchronization" target="_blank" rel="noopener">https://www.w3.org/TR/webgpu/#programming-model-synchronization</a> 这一节中定义了这些scope：</p><ul><li>在pass之外每个command独立为一个scope</li><li>在compute pass中，每个dispatch是一个scope，凡是被引用和间接引用到的资源都是被使用到的</li><li>每个render pass是一个独立的scope，以整个renderpass为单位，所有引用和间接引用到的资源都是被使用到的</li></ul><p>定义这个scope是必要的，因为在底层api的实现中，可能是无法做到在任何时刻要求资源进行状态转换（比如vulkan里barrier没法在renderpass(subpass)中途生效）</p><p>sub resource：这个主要是针对texture的处理，因为显然，某个texture可能是有多个layer和level的，某个pass是可以读一个level写另一个level。所以对于一个texture不能使用一个usage来进行区分。简单来说，对于buffer，sub resource就是buffer，对于texture，sub resource是其下的某个level，layer的组合。</p><p>internal usage: 可以理解是对usage的进一步分类，分类为 input（如vertex/index buffer） constant（如uniform/texture） storage storage-read storage-write attachment attachment-read</p><p>兼容的规则：某个resource在某个scope下，所有usage，要么只有作为一个attachment（写），要么只作为storage（写），要么只作为读（input constant storage-read）</p><p>总结一下这个限制就是<strong>resource在某些使用阶段，要求他们没法同时支持读写的同时使用。</strong></p><p>实现：</p><p><strong>state抽象：</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// The main trait that abstracts away the tracking logic of</span></span><br><span class="line"><span class="comment">/// a particular resource type, like a buffer or a texture.</span></span><br><span class="line"><span class="keyword">pub</span>(<span class="keyword">crate</span>) <span class="class"><span class="keyword">trait</span> <span class="title">ResourceState</span></span>: <span class="built_in">Clone</span> + <span class="built_in">Default</span> &#123;</span><br><span class="line">    <span class="comment">/// Corresponding `HUB` identifier.</span></span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Id</span></span>: <span class="built_in">Copy</span> + fmt::<span class="built_in">Debug</span> + TypedId;</span><br><span class="line">    <span class="comment">/// A type specifying the sub-resources.</span></span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Selector</span></span>: fmt::<span class="built_in">Debug</span>;</span><br><span class="line">    <span class="comment">/// Usage type for a `Unit` of a sub-resource.</span></span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Usage</span></span>: fmt::<span class="built_in">Debug</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Check if all the selected sub-resources have the same</span></span><br><span class="line">    <span class="comment">/// usage, and return it.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// Returns `None` if no sub-resources</span></span><br><span class="line">    <span class="comment">/// are intersecting with the selector, or their usage</span></span><br><span class="line">    <span class="comment">/// isn't consistent.</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">query</span></span>(&amp;<span class="keyword">self</span>, selector: Self::Selector) -&gt; <span class="built_in">Option</span>&lt;Self::Usage&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Change the last usage of the selected sub-resources.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// If `output` is specified, it's filled with the</span></span><br><span class="line">    <span class="comment">/// `PendingTransition` objects corresponding to smaller</span></span><br><span class="line">    <span class="comment">/// sub-resource transitions. The old usage is replaced by</span></span><br><span class="line">    <span class="comment">/// the new one.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// If `output` is `None`, the old usage is extended with</span></span><br><span class="line">    <span class="comment">/// the new usage. The error is returned if it's not possible,</span></span><br><span class="line">    <span class="comment">/// specifying the conflicting transition. Extension can only</span></span><br><span class="line">    <span class="comment">/// be done for read-only usages.</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">change</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        id: Valid&lt;Self::Id&gt;,</span><br><span class="line">        selector: Self::Selector,</span><br><span class="line">        usage: Self::Usage,</span><br><span class="line">        output: <span class="built_in">Option</span>&lt;&amp;<span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;PendingTransition&lt;<span class="keyword">Self</span>&gt;&gt;&gt;,</span><br><span class="line">    ) -&gt; <span class="built_in">Result</span>&lt;(), PendingTransition&lt;<span class="keyword">Self</span>&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Merge the state of this resource tracked by a different instance</span></span><br><span class="line">    <span class="comment">/// with the current one.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// Same rules for `output` apply as with `change()`: last usage state</span></span><br><span class="line">    <span class="comment">/// is either replaced (when `output` is provided) with a</span></span><br><span class="line">    <span class="comment">/// `PendingTransition` pushed to this vector, or extended with the</span></span><br><span class="line">    <span class="comment">/// other read-only usage, unless there is a usage conflict, and</span></span><br><span class="line">    <span class="comment">/// the error is generated (returning the conflict).</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">merge</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        id: Valid&lt;Self::Id&gt;,</span><br><span class="line">        other: &amp;<span class="keyword">Self</span>,</span><br><span class="line">        output: <span class="built_in">Option</span>&lt;&amp;<span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;PendingTransition&lt;<span class="keyword">Self</span>&gt;&gt;&gt;,</span><br><span class="line">    ) -&gt; <span class="built_in">Result</span>&lt;(), PendingTransition&lt;<span class="keyword">Self</span>&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Try to optimize the internal representation.</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">optimize</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数据结构：</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// state tracking 的基本单元</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Unit</span></span>&lt;U&gt; &#123;</span><br><span class="line">    first: <span class="built_in">Option</span>&lt;U&gt;,</span><br><span class="line">    last: U,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述某个类型的资源引用关系</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Resource</span></span>&lt;S&gt; &#123;</span><br><span class="line">    ref_count: RefCount,<span class="comment">// 引用计数clone</span></span><br><span class="line">    state: S, <span class="comment">// 实现一般是上面的unit</span></span><br><span class="line">    epoch: Epoch,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tracking 同一类型多个资源的引用关系</span></span><br><span class="line"><span class="keyword">pub</span>(<span class="keyword">crate</span>) <span class="class"><span class="keyword">struct</span> <span class="title">ResourceTracker</span></span>&lt;S: ResourceState&gt; &#123;</span><br><span class="line">    <span class="comment">/// An association of known resource indices with their tracked states.</span></span><br><span class="line">    map: FastHashMap&lt;Index, Resource&lt;S&gt;&gt;,</span><br><span class="line">    <span class="comment">/// Temporary storage for collecting transitions.</span></span><br><span class="line">    temp: <span class="built_in">Vec</span>&lt;PendingTransition&lt;S&gt;&gt;,</span><br><span class="line">    <span class="comment">/// The backend variant for all the tracked resources.</span></span><br><span class="line">    backend: wgt::Backend,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述所有类型资源的引用关系</span></span><br><span class="line"><span class="keyword">pub</span>(<span class="keyword">crate</span>) <span class="class"><span class="keyword">struct</span> <span class="title">TrackerSet</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> buffers: ResourceTracker&lt;BufferState&gt;,</span><br><span class="line">    <span class="keyword">pub</span> textures: ResourceTracker&lt;TextureState&gt;,</span><br><span class="line">    <span class="keyword">pub</span> views: ResourceTracker&lt;PhantomData&lt;id::TextureViewId&gt;&gt;,</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TrackerSet 由bindgroup，renderpassInfo，commandbuffer， bundle，device分别持有，来管理资源的状态和引用关系。</p><p><strong>流程：</strong></p><p>hal command buffer上的insert_barriers是最终的pass上主要的barrier生成（调用底层api）的方法（当然其他地方也有手工barrier设置，比如copy，clear）。从这个方法可以看到，barrier主要是由base和target的trackerset交互生成的，merge_replace会将目标的state，转移到base上，并且生成transition信息，交由底层生成barrier。insert_barriers 会在renderpass录制结束，每次compute dispatch，queue submit 时提交，正好对应spec中usage scope的定义。</p><p>以renderpass录制为例，会通过renderpassInfo上的tracker来收集当前动态提交的资源绑定命令，比如会merge_extend 来自bindgroup上trackerset缓存的usage，index/vertex buffer的usage，merge_extend bundle的trackerset缓存的usage，这个renderpassInfo上的tracker就是下面insert_barriers使用的target set。同时，当barrier被insert之后，意味着resource的state要被同步，意味着cmdbuffer上的state要被target merge。当cmdbuffer被submit时，同样的，会和device上的tracker state进行merge，并生成正确的barrier。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span>(<span class="keyword">crate</span>) <span class="function"><span class="keyword">fn</span> <span class="title">insert_barriers</span></span>(</span><br><span class="line">        raw: &amp;<span class="keyword">mut</span> A::CommandEncoder,</span><br><span class="line">        base: &amp;<span class="keyword">mut</span> TrackerSet,</span><br><span class="line">        head_buffers: &amp;ResourceTracker&lt;BufferState&gt;,</span><br><span class="line">        head_textures: &amp;ResourceTracker&lt;TextureState&gt;,</span><br><span class="line">        buffer_guard: &amp;Storage&lt;Buffer&lt;A&gt;, id::BufferId&gt;,</span><br><span class="line">        texture_guard: &amp;Storage&lt;Texture&lt;A&gt;, id::TextureId&gt;,</span><br><span class="line">    ) &#123;</span><br><span class="line">        profiling::scope!(<span class="string">"insert_barriers"</span>);</span><br><span class="line">        <span class="built_in">debug_assert_eq!</span>(A::VARIANT, base.backend());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> buffer_barriers = base.buffers.merge_replace(head_buffers).map(|pending| &#123;</span><br><span class="line">            <span class="keyword">let</span> buf = &amp;buffer_guard[pending.id];</span><br><span class="line">            pending.into_hal(buf)</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">let</span> texture_barriers = base.textures.merge_replace(head_textures).map(|pending| &#123;</span><br><span class="line">            <span class="keyword">let</span> tex = &amp;texture_guard[pending.id];</span><br><span class="line">            pending.into_hal(tex)</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            raw.transition_buffers(buffer_barriers);</span><br><span class="line">            raw.transition_textures(texture_barriers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>想法</strong></p><p>wgpu将对象引用关系和state维护建模在一起，是好的做法。可以理解整个state管理的架构是非常清晰的：同一个资源，在整个绘制流程中，可能会涉及到状态的切换，所以：</p><ul><li>在创建资源时，同步引用关系的同时，就指定好合适的目标状态</li><li>时刻都存在一个当前真实的状态记录（tracker set），开始是是device的，然后是commandbuffer的，然后真实绘制时是passinfo的</li><li>在使用资源时，凡是遇到真实的状态记录需要切换即同步的，意味着需要插入barrier</li><li>标准对资源限定的用法保证了我们总是可以在正确的时机插入barrier</li></ul><p>resource上面标记的usage仅仅是为了帮助配合spec做validation，实际usage在进行相关调用时当场决定，实际usage的存在是为了正确生成barrier调用。所以可以说根据现在的实现，如果在使用过程中，对资源标记额外的usage类型，即便没有使用，也不会有性能影响。</p><p>renderpass中收集use，并生成target的trackerset，其实是比较重的操作（可能仅次于validation）。bundle的trackerset其实是被缓存的，也是为什么使用bundle cpu的消耗较低的原因之一。</p><h3 id="buffer-texture初始化"><a href="#buffer-texture初始化" class="headerlink" title="buffer/texture初始化"></a>buffer/texture初始化</h3><p>webgpu标准要求，为了安全起见，所有的新创建的buffer/texture初始化必须是全零的（至少对于用户感知而言），但是从后端分配的资源，很可能是被重用、或是存在其他脏数据。需要实现某机制以lazy的方式控制初始化的流程来保证符合这一要求。具体的实现可以在wgpu-core下的init_tracker中看到，这里以buffer举例。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Most of the time a resource is either fully uninitialized (one element) or initialized (zero elements).</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">UninitializedRangeVec</span></span>&lt;Idx&gt; = SmallVec&lt;[Range&lt;Idx&gt;; <span class="number">1</span>]&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Tracks initialization status of a linear range from 0..size</span></span><br><span class="line"><span class="comment">// 记录需要初始化的范围</span></span><br><span class="line"><span class="keyword">pub</span>(<span class="keyword">crate</span>) <span class="class"><span class="keyword">struct</span> <span class="title">InitTracker</span></span>&lt;Idx: <span class="built_in">Ord</span> + <span class="built_in">Copy</span> + <span class="built_in">Default</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// Ordered, non overlapping list of all uninitialized ranges.</span></span><br><span class="line">    uninitialized_ranges: UninitializedRangeVec&lt;Idx&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span>(<span class="keyword">crate</span>) <span class="class"><span class="keyword">enum</span> <span class="title">MemoryInitKind</span></span> &#123;</span><br><span class="line">    <span class="comment">// The memory range is going to be written by an already initialized source, thus doesn't need extra attention other than marking as initialized.</span></span><br><span class="line">    ImplicitlyInitialized,</span><br><span class="line">    <span class="comment">// The memory range is going to be read, therefore needs to ensure prior initialization.</span></span><br><span class="line">    NeedsInitializedMemory,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span>(<span class="keyword">crate</span>) <span class="class"><span class="keyword">struct</span> <span class="title">BufferInitTrackerAction</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> id: BufferId,</span><br><span class="line">    <span class="keyword">pub</span> range: Range&lt;wgt::BufferAddress&gt;,</span><br><span class="line">    <span class="keyword">pub</span> kind: MemoryInitKind,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Buffer</span></span>&lt;A: hal::Api&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span>(<span class="keyword">crate</span>) raw: <span class="built_in">Option</span>&lt;A::Buffer&gt;,</span><br><span class="line"><span class="comment">// 每一个buffer都持有此tracker</span></span><br><span class="line">    <span class="keyword">pub</span>(<span class="keyword">crate</span>) initialization_status: BufferInitTracker,</span><br><span class="line">		...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 InitTracker记录未初始化范围并不是全部的，即所谓按需是指，在command submit阶段，会根据各个资源的使用范围，以及之前保存在tracker上未初始化的范围，收集需要手工初始化的范围，并在commandbuffer bake结束后，执行init(wgpu-core/src/command)，init会直接调用HAL encoder的clear方法，同时会处理好barrier方面的问题。</p><p>未初始化的数据也有可能被用户通过copy的方式隐式初始化，这种情况就不需要wgpu进行初始化，相关的逻辑可以从MemoryInitKind 的枚举值看出。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>wgpu-core的实现，除了资源管理，另一个重要部分就是validation，这部分比较无趣，涉及到的基本都是spec的细节，这里就不展开介绍了。我想，另一个有趣的问题可能更多的位于hal的后端实现部分，webgl2目前已经被部分支持了，考虑到我们做项目的需求，如果能直接使用那将对维护性有很大好处（不需要自行开发webgl/webgpu的抽象层），那么，支持的局限性如何？降级的成本如何？有没有可能进一步做到webgl1的支持？可能是我们下一个讨论的话题</p></div><div class="article-tags"><a class="tag-link" href="/tags/webgpu-wgpu-graphics/">webgpu, wgpu, graphics</a></div></article><script>document.getElementById("loading-bar").style.width="60%"</script></main><footer id="footer" class="clearfix"><div>&copy; mikialex Theme by <a href="http://artifact.me/" target="_blank">Art Chen</a>.</div><div>Powered by <a href="https://hexo.io/" rel="external">Hexo</a>.</div></footer><script>document.getElementById("loading-bar").style.width="80%"</script><div class="overlay"></div></div><div class="site-sidebar"><div class="sidebar-switch clearfix" style="display:none"><a class="dark-btn active" data-toggle="toc"><span class="icon icon-list"></span> <span class="text">Index</span> </a><a class="dark-btn" data-toggle="bio"><span class="icon icon-person"></span> <span class="text">Bio</span></a></div><div class="site-toc" style="display:none"><div class="no-index">No Index</div></div><div class="site-bio show" style="display:block"><div class="about-me clearfix"><div class="avatar"><img src="/img/avatar.png"></div><div class="info"><a class="name dark-btn" href="/about">miki alex</a></div><div class="info"><span class="item desc"></span></div></div><div class="social clearfix"><a href="/atom.xml" class="feed" target="_blank" rel="external"><span class="icon icon-feed"></span> </a><a href="https://github.com/mikialex" class="github" target="_blank" rel="external"><span class="icon icon-github"></span></a></div></div><div class="shortcuts"><a href="#header" class="top window-nav dark-btn" id="go-top"><span class="icon icon-chevron-thin-up"></span> </a><a class="close dark-btn" id="sidebar-close"><span class="icon icon-close"></span> </a><a href="#footer" class="top window-nav dark-btn" id="go-bottom"><span class="icon icon-chevron-thin-down"></span></a></div></div><script type="text/javascript">var GOOGLE_CUSTOM_SEARCH_API_KEY="",GOOGLE_CUSTOM_SEARCH_ENGINE_ID="",ALGOLIA_API_KEY="",ALGOLIA_APP_ID="",ALGOLIA_INDEX_NAME="",AZURE_SERVICE_NAME="",AZURE_INDEX_NAME="",AZURE_QUERY_KEY="",BAIDU_API_ID="",SEARCH_SERVICE="google",universalSearchConfig={};"google"===SEARCH_SERVICE?universalSearchConfig={searchService:SEARCH_SERVICE,apiKey:GOOGLE_CUSTOM_SEARCH_API_KEY,engineId:GOOGLE_CUSTOM_SEARCH_ENGINE_ID,imagePath:"/img/"}:"algolia"===SEARCH_SERVICE?universalSearchConfig={searchService:SEARCH_SERVICE,apiKey:ALGOLIA_API_KEY,appId:ALGOLIA_APP_ID,indexName:ALGOLIA_INDEX_NAME,imagePath:"/img/"}:"azure"===SEARCH_SERVICE&&(universalSearchConfig={searchService:SEARCH_SERVICE,serviceName:AZURE_SERVICE_NAME,indexName:AZURE_INDEX_NAME,apiKey:AZURE_QUERY_KEY,imagePath:"/img/"})</script><script src="https://code.jquery.com/jquery-2.1.4.min.js"></script><script>window.jQuery||document.write('<script src="/js/jquery.js"><\/script>')</script><script src="/js/search.js"></script><script src="/js/app.js"></script><script>document.getElementById("loading-bar").style.width="100%"</script></body></html>