<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><title>QEM 网格模型简化算法 | mikialex</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="QEM 是一种常见和流行的网格简化算法。在阅读了一些源码和文章后特此笔记。网格的简化是一个复杂的问题，与其全局的想怎么去简化不如从细节入手分而治之。从人的角度而言，手工简化其实也是针对基本图元的简单操作，即每次从网格上删除一个基本图元，一直迭代至满足要求。具体方法有：顶点删除：从网格上一次移除一个顶点。移除后，网格上该顶点相关的面被删除，形成新的洞，再重新对这个洞三角化来补面。边删除：从网格上一次"><meta property="og:type" content="article"><meta property="og:title" content="QEM 网格模型简化算法"><meta property="og:url" content="http://mikialex.github.io/2020/04/04/mesh-simplification/index.html"><meta property="og:site_name" content="mikialex"><meta property="og:description" content="QEM 是一种常见和流行的网格简化算法。在阅读了一些源码和文章后特此笔记。网格的简化是一个复杂的问题，与其全局的想怎么去简化不如从细节入手分而治之。从人的角度而言，手工简化其实也是针对基本图元的简单操作，即每次从网格上删除一个基本图元，一直迭代至满足要求。具体方法有：顶点删除：从网格上一次移除一个顶点。移除后，网格上该顶点相关的面被删除，形成新的洞，再重新对这个洞三角化来补面。边删除：从网格上一次"><meta property="og:locale" content="default"><meta property="og:image" content="http://mikialex.github.io/images/mesh-simplification/matrix.png"><meta property="og:image" content="http://mikialex.github.io/images/mesh-simplification/matrix2.png"><meta property="og:updated_time" content="2020-08-23T07:00:50.628Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="QEM 网格模型简化算法"><meta name="twitter:description" content="QEM 是一种常见和流行的网格简化算法。在阅读了一些源码和文章后特此笔记。网格的简化是一个复杂的问题，与其全局的想怎么去简化不如从细节入手分而治之。从人的角度而言，手工简化其实也是针对基本图元的简单操作，即每次从网格上删除一个基本图元，一直迭代至满足要求。具体方法有：顶点删除：从网格上一次移除一个顶点。移除后，网格上该顶点相关的面被删除，形成新的洞，再重新对这个洞三角化来补面。边删除：从网格上一次"><meta name="twitter:image" content="http://mikialex.github.io/images/mesh-simplification/matrix.png"><link rel="icon" href="/favicon.png"><link href="https://fonts.googleapis.com/css?family=Crimson+Text:400,700|Inconsolata|Oswald" rel="stylesheet"><link rel="stylesheet" href="/icomoon/style.css"><link rel="stylesheet" href="/style.css"></head><body><div class="site-wrapper is_post_page"><div id="loading-bar-wrapper"><div id="loading-bar"></div></div><script>document.getElementById("loading-bar").style.width="20%"</script><header id="header" class="site-header clearfix"><a class="logo square clearfix" href="/"><span class="b">A</span> <span class="b">R</span> <span class="b">T</span> <span class="w">I</span> <span class="w">F</span> <span class="b">A</span> <span class="b">C</span> <span class="b">T</span> </a><a class="me square site-nav-switch clearfix"><span class="b"><span class="icon icon-menu"></span></span></a></header><script>document.getElementById("loading-bar").style.width="40%"</script><main id="main" class="clearfix"><article id="post-mesh-simplification" class="article white-box article-type-post" itemscope itemprop="blogPost"><header class="article-header"><h1 class="article-title" itemprop="name">QEM 网格模型简化算法</h1><div class="article-meta">Posted on <time class="article-time" datetime="2020-04-03T16:00:00.000Z" itemprop="datePublished">Apr 4, 2020</time></div></header><div class="article-entry" itemprop="articleBody"><p>QEM 是一种常见和流行的网格简化算法。在阅读了一些源码和文章后特此笔记。</p><p>网格的简化是一个复杂的问题，与其全局的想怎么去简化不如从细节入手分而治之。从人的角度而言，手工简化其实也是针对基本图元的简单操作，即每次从网格上删除一个基本图元，一直迭代至满足要求。具体方法有：</p><p>顶点删除：从网格上一次移除一个顶点。移除后，网格上该顶点相关的面被删除，形成新的洞，再重新对这个洞三角化来补面。</p><p>边删除：从网格上一次移除一条边，塌陷这条边的两个顶点为一个。塌陷后再重新连接其他的面。</p><p>顶点合并：从网格上一次选择两个顶点进行塌陷，这两个顶点不一定需要构成边。塌陷后再重新连接其他的面。</p><p>QEM的方法适用于边删除和顶点合并的两种情况：都是把两个顶点合并成一个。后续只是连接性重建的问题。我的理解是边删除的方法能避免拓扑关系被破坏，而有些场景下，拓扑关系不是很重要，比如单纯用于渲染的mesh。而使用边删除因为拓扑的约束所以简模效果没有单纯的顶点合并来的理想。</p><h2 id="什么是QEM"><a href="#什么是QEM" class="headerlink" title="什么是QEM"></a>什么是QEM</h2><p>QEM是 Quadric Error Metrics的缩写。我先不直接解释这个东西是什么，先回归我们面对的具体问题：我们现在要从一个mesh上删除一条边。我们要选择哪一条边？我们选择的这条边，合并后的新顶点位置是什么？</p><p>我们其实只需要考虑后一个问题，因为我们在某个边上能找到的最佳点的质量就决定了这条边的质量，有了所有边的质量我们只需找到最好的就可以了，这就是边的选择的解法。</p><p>既然是网格简化，所以我们要尽可能保证每一步简化和原网格形状差别不大。考虑我们具体的操作是一个图元，所以这是个非常局部性的问题：当我们把一条边从网格上塌陷掉，在形状上的影响就是这条边原先所在的几个面的换成了新的几个面。具体而言就是：当合并前，我们有原先的两个顶点的位置，以及这些顶点周围的若干三角面。当合并后，我们有新的顶点位置，以及新的顶点周围若干三角面。</p><p>QEM方法的原则：<strong>就是合并后的这个顶点，应当到原先合并前两个顶点周围若干三角形所在平面的距离的平方和最小</strong>。有了这个原则，我们就可以计算给定网格上一条边，这个最优点在哪里，以及它有多优秀。</p><p>“到原先合并前两个顶点周围若干三角形所在平面的距离的平方和”，其实就是个函数 <code>d = f(x, y, z)</code>。这个函数在哪个xyz坐标取到最小值，这个坐标就是最优点的位置，这个最小值就是优秀的程度。</p><p>相信讲到这里，网格简化问题已经被说透彻了。而QEM本质上只是解决上面这个问题的数学工具。</p><p>对于一个三角面，其所在平面的方程有 <code>ax + by + cz + d = 0</code>。不难记得高中的几何知识：对于这种平面方程, 空间中任意一点到这个平面的距离就是直接把xyz代入就是，那么距离的平方的函数就是 <code>d = (ax + by + cz + d)^2</code>。那么所有平面的距离平方和就是把所有三角面的这个函数相加就是。然后再求个最小值就ok了。</p><p>Quadric 在数学上叫<a href="https://www.zhihu.com/question/38902714" target="_blank" rel="noopener">二次型</a>。 <code>d = (ax + by + cz + d)^2</code>就是个二次型，所以我们就有展开后写成二次型矩阵的版本：</p><p><img src="/images/mesh-simplification/matrix.png" alt></p><p>一旦这么写了以后，我们原先的这些平方和的函数，就变成的一堆矩阵的和，所以，对于某个顶点周围的三角面，我们只要用这个二次型矩阵就能表达空间中任一点到这些三角面距离平方和的函数。而这个矩阵，就是这个顶点的QEM。而对于我们上面讲到的“到原先合并前两个顶点周围若干三角形所在平面的距离的平方和”，那就是两个顶点的QEM矩阵和。</p><p>我的理解是用QEM存粹是工程上的考量，即便我不懂什么Quadric，我实际上也会实现上把平方和展开然后逐项存储，逐项求和。更有种用矩阵是为了简化运算的表示的意味。</p><p>不过在求最小值方面的确是不清楚不用二次型矩阵有什么更好的办法。</p><p><img src="/images/mesh-simplification/matrix2.png" alt></p><p>我不是很懂矩阵的微积分, 这个求导的推导需要再看看其他资料。只不过这么搞答案立刻就有。</p><h2 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a>流程梳理</h2><p>1计算mesh上每一顶点的QEM。</p><p>2对于每一个可以合法坍缩的顶点对/边，根据QEM计算最佳坍缩位置和最佳坍缩位置下的平方和最小值作为error</p><p>3通过error最小堆来维护可以合法坍缩的顶点对/边</p><p>4反复迭代从堆中pop出最小的error边进行坍缩，并更新所有收影响边/点/新边的QEM和error以及堆，直到符合简化量预期</p><h2 id="Links"><a href="#Links" class="headerlink" title="Links"></a>Links</h2><p>Paper</p><p><a href="https://www.cs.cmu.edu/~./garland/Papers/quadrics.pdf" target="_blank" rel="noopener">https://www.cs.cmu.edu/~./garland/Papers/quadrics.pdf</a></p><p>开源参考实现：</p><p><a href="https://github.com/sp4cerat/Fast-Quadric-Mesh-Simplification/blob/master/src.cmd/Simplify.h" target="_blank" rel="noopener">https://github.com/sp4cerat/Fast-Quadric-Mesh-Simplification/blob/master/src.cmd/Simplify.h</a></p><p><a href="https://github.com/hhoppe/Mesh-processing-library/blob/master/MeshSimplify/MeshSimplify.cpp" target="_blank" rel="noopener">https://github.com/hhoppe/Mesh-processing-library/blob/master/MeshSimplify/MeshSimplify.cpp</a></p><p>二次型，数学相关</p><p><a href="https://www.zhihu.com/question/38902714" target="_blank" rel="noopener">https://www.zhihu.com/question/38902714</a></p><p><a href="https://www.zhihu.com/question/22455493" target="_blank" rel="noopener">https://www.zhihu.com/question/22455493</a></p></div><div class="article-tags"></div></article><script>document.getElementById("loading-bar").style.width="60%"</script></main><footer id="footer" class="clearfix"><div>&copy; mikialex Theme by <a href="http://artifact.me/" target="_blank">Art Chen</a>.</div><div>Powered by <a href="https://hexo.io/" rel="external">Hexo</a>.</div></footer><script>document.getElementById("loading-bar").style.width="80%"</script><div class="overlay"></div></div><div class="site-sidebar"><div class="sidebar-switch clearfix" style="display:none"><a class="dark-btn active" data-toggle="toc"><span class="icon icon-list"></span> <span class="text">Index</span> </a><a class="dark-btn" data-toggle="bio"><span class="icon icon-person"></span> <span class="text">Bio</span></a></div><div class="site-toc" style="display:none"><div class="no-index">No Index</div></div><div class="site-bio show" style="display:block"><div class="about-me clearfix"><div class="avatar"><img src="/img/avatar.png"></div><div class="info"><a class="name dark-btn" href="/about">miki alex</a></div><div class="info"><span class="item desc"></span></div></div><div class="social clearfix"><a href="/atom.xml" class="feed" target="_blank" rel="external"><span class="icon icon-feed"></span> </a><a href="https://github.com/mikialex" class="github" target="_blank" rel="external"><span class="icon icon-github"></span></a></div></div><div class="shortcuts"><a href="#header" class="top window-nav dark-btn" id="go-top"><span class="icon icon-chevron-thin-up"></span> </a><a class="close dark-btn" id="sidebar-close"><span class="icon icon-close"></span> </a><a href="#footer" class="top window-nav dark-btn" id="go-bottom"><span class="icon icon-chevron-thin-down"></span></a></div></div><script type="text/javascript">var GOOGLE_CUSTOM_SEARCH_API_KEY="",GOOGLE_CUSTOM_SEARCH_ENGINE_ID="",ALGOLIA_API_KEY="",ALGOLIA_APP_ID="",ALGOLIA_INDEX_NAME="",AZURE_SERVICE_NAME="",AZURE_INDEX_NAME="",AZURE_QUERY_KEY="",BAIDU_API_ID="",SEARCH_SERVICE="google",universalSearchConfig={};"google"===SEARCH_SERVICE?universalSearchConfig={searchService:SEARCH_SERVICE,apiKey:GOOGLE_CUSTOM_SEARCH_API_KEY,engineId:GOOGLE_CUSTOM_SEARCH_ENGINE_ID,imagePath:"/img/"}:"algolia"===SEARCH_SERVICE?universalSearchConfig={searchService:SEARCH_SERVICE,apiKey:ALGOLIA_API_KEY,appId:ALGOLIA_APP_ID,indexName:ALGOLIA_INDEX_NAME,imagePath:"/img/"}:"azure"===SEARCH_SERVICE&&(universalSearchConfig={searchService:SEARCH_SERVICE,serviceName:AZURE_SERVICE_NAME,indexName:AZURE_INDEX_NAME,apiKey:AZURE_QUERY_KEY,imagePath:"/img/"})</script><script src="https://code.jquery.com/jquery-2.1.4.min.js"></script><script>window.jQuery||document.write('<script src="/js/jquery.js"><\/script>')</script><script src="/js/search.js"></script><script src="/js/app.js"></script><script>document.getElementById("loading-bar").style.width="100%"</script></body></html>