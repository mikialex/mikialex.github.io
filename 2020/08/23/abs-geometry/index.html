<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><title>使用Rust trait 抽象三维几何数据类型 | mikialex</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="在对rust的trait， generics等概念有了一定理解后，我尝试集中编写一些三维几何数据的容器类作为渲染引擎的基础库。如果你对three.js比较了解的话，我这里做的，其实就是使用rust编写Geometry，BufferGeometry等容器类，three的geometry写的是很挫的，寄希望于rust这门优秀的语言，我试图提升一下自我要求，比如：尝试将拓扑信息编码在类型之中，这样假设我"><meta property="og:type" content="article"><meta property="og:title" content="使用Rust trait 抽象三维几何数据类型"><meta property="og:url" content="http://mikialex.github.io/2020/08/23/abs-geometry/index.html"><meta property="og:site_name" content="mikialex"><meta property="og:description" content="在对rust的trait， generics等概念有了一定理解后，我尝试集中编写一些三维几何数据的容器类作为渲染引擎的基础库。如果你对three.js比较了解的话，我这里做的，其实就是使用rust编写Geometry，BufferGeometry等容器类，three的geometry写的是很挫的，寄希望于rust这门优秀的语言，我试图提升一下自我要求，比如：尝试将拓扑信息编码在类型之中，这样假设我"><meta property="og:locale" content="default"><meta property="og:updated_time" content="2020-08-23T07:02:29.757Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="使用Rust trait 抽象三维几何数据类型"><meta name="twitter:description" content="在对rust的trait， generics等概念有了一定理解后，我尝试集中编写一些三维几何数据的容器类作为渲染引擎的基础库。如果你对three.js比较了解的话，我这里做的，其实就是使用rust编写Geometry，BufferGeometry等容器类，three的geometry写的是很挫的，寄希望于rust这门优秀的语言，我试图提升一下自我要求，比如：尝试将拓扑信息编码在类型之中，这样假设我"><link rel="icon" href="/favicon.png"><link href="https://fonts.googleapis.com/css?family=Crimson+Text:400,700|Inconsolata|Oswald" rel="stylesheet"><link rel="stylesheet" href="/icomoon/style.css"><link rel="stylesheet" href="/style.css"></head><body><div class="site-wrapper is_post_page"><div id="loading-bar-wrapper"><div id="loading-bar"></div></div><script>document.getElementById("loading-bar").style.width="20%"</script><header id="header" class="site-header clearfix"><a class="logo square clearfix" href="/"><span class="b">A</span> <span class="b">R</span> <span class="b">T</span> <span class="w">I</span> <span class="w">F</span> <span class="b">A</span> <span class="b">C</span> <span class="b">T</span> </a><a class="me square site-nav-switch clearfix"><span class="b"><span class="icon icon-menu"></span></span></a></header><script>document.getElementById("loading-bar").style.width="40%"</script><main id="main" class="clearfix"><article id="post-abs-geometry" class="article white-box article-type-post" itemscope itemprop="blogPost"><header class="article-header"><h1 class="article-title" itemprop="name">使用Rust trait 抽象三维几何数据类型</h1><div class="article-meta">Posted on <time class="article-time" datetime="2020-08-22T16:00:00.000Z" itemprop="datePublished">Aug 23, 2020</time></div></header><div class="article-entry" itemprop="articleBody"><p>在对rust的trait， generics等概念有了一定理解后，我尝试集中编写一些三维几何数据的容器类作为渲染引擎的基础库。</p><p>如果你对three.js比较了解的话，我这里做的，其实就是使用rust编写Geometry，BufferGeometry等容器类，three的geometry写的是很挫的，寄希望于rust这门优秀的语言，我试图提升一下自我要求，比如：</p><ul><li>尝试将拓扑信息编码在类型之中，这样假设我有一个描述以triangleList为布局的几何数据，不应该赋值给一个以trianglestrip为布局的几何数据。</li><li>可以使用任何用户自定义的顶点数据结构</li><li>提供一个统一的图元迭代器，图元的类型由拓扑类型决定</li><li>同时支持index/无index， interleaved/非interleaved的buffer数据</li></ul><h2 id="统一interleaved和非interleaved的数据"><a href="#统一interleaved和非interleaved的数据" class="headerlink" title="统一interleaved和非interleaved的数据"></a>统一interleaved和非interleaved的数据</h2><p>我们正常在opengl/webgl中使用的数据都是非interleaved的，比如一般来说position是一个单独的buffer，normal也是一个单独的buffer，uv也是。而interleaved版本是position + normal + uv交替存储，只使用一个buffer。</p><p>虽然我一般都是使用非interleave版本，但事实上interleaved才是较为原始的数据存储，假设你如下定义一个struct，标记内存布局使用C语言标准。对于一个<code>Vec&lt;Vertex&gt;</code>, 它的内存事实上完全就是interleaving的，你可以直接transmute一下上传，没有多余的拷贝。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="meta">#[derive(Clone, Copy, soa_derive::StructOfArray)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span></span> &#123;</span><br><span class="line">  <span class="keyword">pub</span> position: Vec3&lt;<span class="built_in">f32</span>&gt;,</span><br><span class="line">  <span class="keyword">pub</span> normal: Vec3&lt;<span class="built_in">f32</span>&gt;,</span><br><span class="line">  <span class="keyword">pub</span> uv: Vec2&lt;<span class="built_in">f32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> my_geometry_data: <span class="built_in">Vec</span>&lt;Vertex&gt;;</span><br></pre></td></tr></table></figure><p>而我们常用的非interleave版本本质上是这个：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">VertexArray</span></span> &#123;</span><br><span class="line">  <span class="keyword">pub</span> position: <span class="built_in">Vec</span>&lt;Vec3&lt;<span class="built_in">f32</span>&gt;&gt;,</span><br><span class="line">  <span class="keyword">pub</span> normal: <span class="built_in">Vec</span>&lt;Vec3&lt;<span class="built_in">f32</span>&gt;&gt;,</span><br><span class="line">  <span class="keyword">pub</span> uv: <span class="built_in">Vec</span>&lt;Vec2&lt;<span class="built_in">f32</span>&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> my_geometry_data: VertexArray;</span><br></pre></td></tr></table></figure><p>本质上就是struct of array 和 array of struct 的区别。你也看到，我在Vertex上标记<code>soa_derive::StructOfArray</code>, 这个库可以为我们自动生成 struct of array版本的类型，并实现<code>As&lt;[T]&gt; + Index&lt;usize&gt;</code>这两个trait, 这使得两种容器类型在使用上一模一样。</p><p>所以和这个抹平差异的思想一致。实际数据的存储上，容器要满足的trait是：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">GeometryDataContainer</span></span>&lt;T&gt;:</span><br><span class="line">  <span class="built_in">AsRef</span>&lt;[T]&gt; + <span class="built_in">Clone</span> + Index&lt;<span class="built_in">usize</span>, Output = T&gt; + FromIterator&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为普通vec实现</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: <span class="built_in">Clone</span>&gt; GeometryDataContainer&lt;T&gt; <span class="keyword">for</span> <span class="built_in">Vec</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="comment">// 为自动的soa derive实现</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: StructOfArray, A: T::ArrayType&gt; GeometryDataContainer&lt;T&gt; <span class="keyword">for</span> A &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="顶点，拓扑，和图元的trait约束"><a href="#顶点，拓扑，和图元的trait约束" class="headerlink" title="顶点，拓扑，和图元的trait约束"></a>顶点，拓扑，和图元的trait约束</h2><p>一个几何由很多顶点构成，先不考虑有没有index，这些顶点每一个/两个/三个 形成一个三角形/线段/点，如果再考虑是list还是strip，又可分为每过一个图元步进几个顶点数据。这些如何使用trait来抽象呢？</p><p>先看顶点，这里我们把问题再放窄一点，要求顶点必须是能提供3d空间点的信息， 3d空间点也不再加一层泛型，就f32吧，所以所有顶点应该实现这个trait：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Positioned3D</span></span>: <span class="built_in">Copy</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">position</span></span>(&amp;<span class="keyword">self</span>) -&gt; Vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顶点构成图元， 图元的约束可以是这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">PrimitiveData</span></span>&lt;T: Positioned3D&gt; &#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">IndexIndicator</span></span>;</span><br><span class="line">  <span class="keyword">const</span> DATA_STRIDE: <span class="built_in">usize</span>;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">from_indexed_data</span></span>(index: &amp;[<span class="built_in">u16</span>], data: &amp;[T], offset: <span class="built_in">usize</span>) -&gt; <span class="keyword">Self</span>;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">create_index_indicator</span></span>(index: &amp;[<span class="built_in">u16</span>], offset: <span class="built_in">usize</span>) -&gt; Self::IndexIndicator;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">from_data</span></span>(data: &amp;[T], offset: <span class="built_in">usize</span>) -&gt; <span class="keyword">Self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看几个impl可能会更清楚：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: Positioned3D&gt; PrimitiveData&lt;T&gt; <span class="keyword">for</span> Triangle&lt;T&gt; &#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">IndexIndicator</span></span> = Triangle&lt;<span class="built_in">u16</span>&gt;;</span><br><span class="line">  <span class="keyword">const</span> DATA_STRIDE: <span class="built_in">usize</span> = <span class="number">3</span>;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">from_indexed_data</span></span>(index: &amp;[<span class="built_in">u16</span>], data: &amp;[T], offset: <span class="built_in">usize</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> a = data[index[offset] <span class="keyword">as</span> <span class="built_in">usize</span>];</span><br><span class="line">    <span class="keyword">let</span> b = data[index[offset + <span class="number">1</span>] <span class="keyword">as</span> <span class="built_in">usize</span>];</span><br><span class="line">    <span class="keyword">let</span> c = data[index[offset + <span class="number">2</span>] <span class="keyword">as</span> <span class="built_in">usize</span>];</span><br><span class="line">    Triangle &#123; a, b, c &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">create_index_indicator</span></span>(index: &amp;[<span class="built_in">u16</span>], offset: <span class="built_in">usize</span>) -&gt; Self::IndexIndicator &#123;</span><br><span class="line">    <span class="keyword">let</span> a = index[offset];</span><br><span class="line">    <span class="keyword">let</span> b = index[offset + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> c = index[offset + <span class="number">2</span>];</span><br><span class="line">    Triangle &#123; a, b, c &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">from_data</span></span>(data: &amp;[T], offset: <span class="built_in">usize</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> a = data[offset];</span><br><span class="line">    <span class="keyword">let</span> b = data[offset + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> c = data[offset + <span class="number">2</span>];</span><br><span class="line">    Triangle &#123; a, b, c &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Positioned3D&gt; PrimitiveData&lt;T&gt; <span class="keyword">for</span> LineSegment&lt;T&gt; &#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">IndexIndicator</span></span> = LineSegment&lt;<span class="built_in">u16</span>&gt;;</span><br><span class="line">  <span class="keyword">const</span> DATA_STRIDE: <span class="built_in">usize</span> = <span class="number">2</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DATA_STRIDE</code>就是上文提到的数据宽度，三个方法就是具体从一个slice里读取并构造出图元的实现，IndexIndicator辅助支持indexgeometry。这个trait配合上面的容器抽象，我们就可以在容器的指定位置读取图元。</p><p>基于顶点和图元，我们还需要描述拓扑的信息，显然，拓扑可以使用零尺寸类型表达</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">PrimitiveTopology</span></span>&lt;T: Positioned3D&gt; &#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Primitive</span></span>: PrimitiveData&lt;T&gt;;</span><br><span class="line">  <span class="keyword">const</span> STRIDE: <span class="built_in">usize</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里不多举例，可以看到拓扑这个trait同时link了对顶点的约束，以及对应的图元类型，和步进长度</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TriangleList</span></span>;</span><br><span class="line"><span class="keyword">impl</span>&lt;T: Positioned3D&gt; PrimitiveTopology&lt;T&gt; <span class="keyword">for</span> TriangleList &#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Primitive</span></span> = Triangle&lt;T&gt;;</span><br><span class="line">  <span class="keyword">const</span> STRIDE: <span class="built_in">usize</span> = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TriangleStrip</span></span>;</span><br><span class="line"><span class="keyword">impl</span>&lt;T: Positioned3D&gt; PrimitiveTopology&lt;T&gt; <span class="keyword">for</span> TriangleStrip &#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Primitive</span></span> = Triangle&lt;T&gt;;</span><br><span class="line">  <span class="keyword">const</span> STRIDE: <span class="built_in">usize</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造我们的几何类型"><a href="#构造我们的几何类型" class="headerlink" title="构造我们的几何类型"></a>构造我们的几何类型</h2><p>Index和非Index版本的数据结构如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">IndexedGeometry</span></span>&lt;</span><br><span class="line">  V: Positioned3D = Vertex,</span><br><span class="line">  T: PrimitiveTopology&lt;V&gt; = TriangleList,</span><br><span class="line">  U: GeometryDataContainer&lt;V&gt; = <span class="built_in">Vec</span>&lt;V&gt;,</span><br><span class="line">&gt; &#123;</span><br><span class="line">  <span class="keyword">pub</span> data: U,</span><br><span class="line">  <span class="keyword">pub</span> index: <span class="built_in">Vec</span>&lt;<span class="built_in">u16</span>&gt;,</span><br><span class="line">  _v_phantom: PhantomData&lt;V&gt;,</span><br><span class="line">  _phantom: PhantomData&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">NoneIndexedGeometry</span></span>&lt;</span><br><span class="line">  V: Positioned3D = Vertex,</span><br><span class="line">  T: PrimitiveTopology&lt;V&gt; = TriangleList,</span><br><span class="line">  U: GeometryDataContainer&lt;V&gt; = <span class="built_in">Vec</span>&lt;V&gt;,</span><br><span class="line">&gt; &#123;</span><br><span class="line">  <span class="keyword">pub</span> data: U,</span><br><span class="line">  _v_phantom: PhantomData&lt;V&gt;,</span><br><span class="line">  _phantom: PhantomData&lt;T&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于这两种geometry，配合上面的一些内容，可以直接实现出图元的迭代器，包括ExactSizeIterator。很简单，这里就不放出实现了。</p><p>可以看到我们有两个geometry，有index的和无index的，这应该需要统一一下。他们应该要实现同一个trait，这个trait应该是几何数据最基础的trait。 从抽象的角度来看，我们只关心图元，应该是要能返回图元的ExactSizeIterator，以及图元的随机访问能力。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">AbstractGeometry</span></span>: <span class="built_in">Sized</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Vertex</span></span>: Positioned3D;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Topology</span></span>: PrimitiveTopology&lt;Self::Vertex&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">wrap</span></span>&lt;<span class="symbol">'a</span>&gt;(&amp;<span class="symbol">'a</span> <span class="keyword">self</span>) -&gt; AbstractGeometryRef&lt;<span class="symbol">'a</span>, <span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">    AbstractGeometryRef &#123; wrapped: <span class="keyword">self</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">primitive_iter</span></span>&lt;<span class="symbol">'a</span>&gt;(&amp;<span class="symbol">'a</span> <span class="keyword">self</span>) -&gt; AbstractPrimitiveIter&lt;<span class="symbol">'a</span>, <span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">    AbstractPrimitiveIter(<span class="keyword">self</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">primitive_at</span></span>(</span><br><span class="line">    &amp;<span class="keyword">self</span>,</span><br><span class="line">    primitive_index: <span class="built_in">usize</span>,</span><br><span class="line">  ) -&gt; <span class="built_in">Option</span>&lt;&lt;Self::Topology <span class="keyword">as</span> PrimitiveTopology&lt;Self::Vertex&gt;&gt;::Primitive&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为返回的迭代器势必要对源数据保持一个借用关系，如果我要把这个迭代器的类型写进AbstractGeometry的关联类型的话，会有个生命周期参数要填。为了解决这个问题我参考了一些做法做了一些尝试，最后做法是再间接return中间的迭代器结构，让这个中间的迭代器实现IntoIterator，而这个实现我们在为AbstractGeometry实现一些通用方法的时候加上这个trait约束即可，其中生命周期参数通过HRTB注入。比如下面这个为<strong>所有几何类型实现获得光线相交点的列表</strong>的实现：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">'a</span>, V, P, T, G&gt; IntersectAble&lt;AbstractGeometryRef&lt;<span class="symbol">'a</span>, G&gt;, IntersectionList3D, Config&gt; <span class="keyword">for</span> Ray3</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">  V: Positioned3D,</span><br><span class="line">  P: IntersectAble&lt;Ray3, NearestPoint3D, Config&gt; + PrimitiveData&lt;V&gt;,</span><br><span class="line">  T: PrimitiveTopology&lt;V, Primitive = P&gt;,</span><br><span class="line">  G: AbstractGeometry&lt;Vertex = V, Topology = T&gt;,</span><br><span class="line">  <span class="keyword">for</span>&lt;<span class="symbol">'b</span>&gt; AbstractPrimitiveIter&lt;<span class="symbol">'b</span>, G&gt;: <span class="built_in">IntoIterator</span>&lt;Item = T::Primitive&gt;,</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">intersect</span></span>(&amp;<span class="keyword">self</span>, geometry: &amp;AbstractGeometryRef&lt;<span class="symbol">'a</span>, G&gt;, conf: &amp;Config) -&gt; IntersectionList3D &#123;</span><br><span class="line">    IntersectionList3D(</span><br><span class="line">      geometry</span><br><span class="line">        .primitive_iter()</span><br><span class="line">        .into_iter()</span><br><span class="line">        .filter_map(|p| p.intersect(<span class="keyword">self</span>, conf).<span class="number">0</span>)</span><br><span class="line">        .collect(),</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个实现等价于threejs分散在各个class内的raycast方法，在我们的抽象体系下只有短短这么一点。从类型上可以看到，除了为了支持AbstractGeometry的trait约束，我只要要求图元实现了和光线相交的trait，那么任意满足这组约束的几何就可以直接支持这个行为。而由于完全是静态的trait的分发，编译时rust会根据你实际使用到的所有可能的图元/顶点/拓扑/几何/类型的组合生成代码，然后再层层内联高度优化，而这些代码原先都是手写的，科学技术真是第一生产力。</p><p>通用渲染用的mesh几何数据的实现还在开发中，实际实现可参考：<br><a href="https://github.com/mikialex/rendiation/tree/master/mesh-buffer/src/geometry" target="_blank" rel="noopener">https://github.com/mikialex/rendiation/tree/master/mesh-buffer/src/geometry</a></p></div><div class="article-tags"></div></article><script>document.getElementById("loading-bar").style.width="60%"</script></main><footer id="footer" class="clearfix"><div>&copy; mikialex Theme by <a href="http://artifact.me/" target="_blank">Art Chen</a>.</div><div>Powered by <a href="https://hexo.io/" rel="external">Hexo</a>.</div></footer><script>document.getElementById("loading-bar").style.width="80%"</script><div class="overlay"></div></div><div class="site-sidebar"><div class="sidebar-switch clearfix" style="display:none"><a class="dark-btn active" data-toggle="toc"><span class="icon icon-list"></span> <span class="text">Index</span> </a><a class="dark-btn" data-toggle="bio"><span class="icon icon-person"></span> <span class="text">Bio</span></a></div><div class="site-toc" style="display:none"><div class="no-index">No Index</div></div><div class="site-bio show" style="display:block"><div class="about-me clearfix"><div class="avatar"><img src="/img/avatar.png"></div><div class="info"><a class="name dark-btn" href="/about">miki alex</a></div><div class="info"><span class="item desc"></span></div></div><div class="social clearfix"><a href="/atom.xml" class="feed" target="_blank" rel="external"><span class="icon icon-feed"></span> </a><a href="https://github.com/mikialex" class="github" target="_blank" rel="external"><span class="icon icon-github"></span></a></div></div><div class="shortcuts"><a href="#header" class="top window-nav dark-btn" id="go-top"><span class="icon icon-chevron-thin-up"></span> </a><a class="close dark-btn" id="sidebar-close"><span class="icon icon-close"></span> </a><a href="#footer" class="top window-nav dark-btn" id="go-bottom"><span class="icon icon-chevron-thin-down"></span></a></div></div><script type="text/javascript">var GOOGLE_CUSTOM_SEARCH_API_KEY="",GOOGLE_CUSTOM_SEARCH_ENGINE_ID="",ALGOLIA_API_KEY="",ALGOLIA_APP_ID="",ALGOLIA_INDEX_NAME="",AZURE_SERVICE_NAME="",AZURE_INDEX_NAME="",AZURE_QUERY_KEY="",BAIDU_API_ID="",SEARCH_SERVICE="google",universalSearchConfig={};"google"===SEARCH_SERVICE?universalSearchConfig={searchService:SEARCH_SERVICE,apiKey:GOOGLE_CUSTOM_SEARCH_API_KEY,engineId:GOOGLE_CUSTOM_SEARCH_ENGINE_ID,imagePath:"/img/"}:"algolia"===SEARCH_SERVICE?universalSearchConfig={searchService:SEARCH_SERVICE,apiKey:ALGOLIA_API_KEY,appId:ALGOLIA_APP_ID,indexName:ALGOLIA_INDEX_NAME,imagePath:"/img/"}:"azure"===SEARCH_SERVICE&&(universalSearchConfig={searchService:SEARCH_SERVICE,serviceName:AZURE_SERVICE_NAME,indexName:AZURE_INDEX_NAME,apiKey:AZURE_QUERY_KEY,imagePath:"/img/"})</script><script src="https://code.jquery.com/jquery-2.1.4.min.js"></script><script>window.jQuery||document.write('<script src="/js/jquery.js"><\/script>')</script><script src="/js/search.js"></script><script src="/js/app.js"></script><script>document.getElementById("loading-bar").style.width="100%"</script></body></html>