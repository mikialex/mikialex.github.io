# GUI framework research



最近在rendiation内学习编写图形用户界面框架，整理一些思考。

GUI 事实上是个超级复杂的巨大的topic，对于不同的人，在不同的语境下有着完全不一样的意思。对于web前端开发者，这可能是讨论react、vue之类框架实现方面的内容。但事实上没有了浏览器的帮助，让你使用rust一样底层的语言，从头撸一个带用户界面的程序。顿时变成了很有难度的事情。

## design

实现复杂native的桌面程序非常困难，因为做的完善的话，你事实上就是在写浏览器。但这是不可能的。但浏览器是一个好的比喻，因为我们要解决的一些问题其实是差不多的。

简单而言，典型结构分为三层：

底层部分：需要搞定windowing：窗体管理，作为呈现的容器。基于这个容器做 输入：来自窗体或者设备的事件。和输出：UI渲染的结果。这一层需要完成windowing，events，presentation的跨平台封装（这些工作主要是调用操作系统的API），可以理解是一个类似提供shell的能力。具体实现细节可以简单也可以非常复杂，比如支持多窗体？子窗体？全屏？不同系统任务栏？系统内置的menu？drag and drop？多显示器？，dpi？文件选择（不会让上层实现自己画一个file explorer吧），奇怪的设备（游戏手柄）？系统提供的合成器（compositor）？硬件视频加速（是的这个和渲染没关系，是操作系统的api）？web支持？

视图层部分：提供一个界面的描述方式的视图数据结构view，接受底层的事件，转化成界面上逻辑的事件（比如这个按钮被点击了） 触发对应的业务逻辑回调。以及将view渲染到窗体上。这部分实现内部也会分为多层实现，最上层是设计一套描述view的API，一般来说是树结构，比如DOM tree，widget tree。这套tree描述了样式和结构方面的原始信息，第二层会根据这些信息计算layout，生成displaylist显示列表，其中可能会有大量的优化实现，大量的中间数据结构和缓存（比如额外的layout tree、render tree），第三层是渲染实现，会翻译displaylist成不同图形后端的GPU渲染命令并提交，同时实现纹理，字体，几何缓存，渲染调度，使用系统合成器等。这里每一层可以说内部由分了好几块，每一块都有海量的细节。

应用部分：构建和维护view：监听事件，触发业务逻辑，修改业务数据，再反向更新view。

在游戏开发领域，更多的会推崇另一种Immediate mode的架构方案，与之相对的上面这种则称之为retain mode。游戏中UI只是配角，因为优化UI的性能一般没有收益，而界面风格可能高度定制化，一个高度优化非常复杂，扩展能力差的view层就完全没有存在的价值，更重要的是不像web开发领域，view和应用部分没有成熟好用的双向绑定机制，所以不如没有view。immediate mode就是这种1 不在乎性能（每一帧几乎不缓存什么计算，暴力全刷，像画游戏一样画UI），2 full declarative（直接traverse 应用state生成渲染命令，由于是每一帧都绘制，事件处理的代码直接被封装进渲染里了）。非常适合并且容易集成在游戏引擎中。但是缺点也显而易见，因为stateless，比如复杂的animation，layout，这些功能难以实现（某些具有内部state的UI实现，其state还是需要交给业务，等于说上层还是要完成view的工作），因为stateless，所以优化很难搞（所谓优化本质是维护cache，增量计算，本质是由大量state）。

我个人并不认可immediate mode这种方式， 

GUI的底层支持是个复杂的事情，我不认为我们需要一个大而全的解决方案，一步到位像浏览器一样做一个巨大的runtime，而是可以将这个逐个的功能支持点独立成一个个可组合的crate，各取所需。在开发框架时也要充分考虑到这些部件的替换扩展能力。根据上述的分层架构，事实上结合rust现有的生态，搭建一个minial，但是扩展性不错的框架是可以做到的。





所谓declarative，就是诸多现代流行的框架核心提供的能力，也是众所周知的概念：用户通过声明式的代码，直接指出数据与界面之间的绑定关系，由框架负责同步工作，由此避免大量繁琐的数据和视图手工同步实现，巨幅提升界面编写效率和维护性。相关的概念可以说是深入人心的，也是vue、react等框架成功之处。甚至可以确定的说，现在没有人会再去使用没有双向绑定支持的UI框架了。双向绑定的支持对于用户是否能高效的编写业务是至关重要的。

要实现双向绑定的机制，意味着需要一套自动的机制，将数据的变化同步到视图，将视图的事件触发数据的修改。



## 简单的实践

## druid case study

整体架构上，可以说完全是照抄[druid](https://github.com/linebender/druid) ，这个UI框架在rust的GUI社区生态方面还是有一定影响力。这个库我在去年年初还集中研究过一段时间，但当时看的不是很明白，但现在可以说大致上是了解清楚了。





当然，我也在我的实现中尝试加入了一些自己的想法，这些想法可能是一些改进，但我还不确定是不是真正的改进，因为我还并没有编写更多的用户代码来进一步衡量和检验我的想法。





## RFP meet GUI ？



参考资料

https://www.cmyr.net/blog/gui-framework-ingredients.html

