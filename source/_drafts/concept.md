# 关于渲染的概念模型

当我们认真做一件事情的时候，一开始就有必要好好的系统的了解这件事情到底是如何发生的，整个流程，体系是如何work的，而不是稀里糊涂的盲目尝试和做设计，这样总是事倍功半。

## 我们要做哪些封装和抽象？

原始的webgl是一个状态机，所以api的使用是不直观的，甚至说奇怪的。因为实际执行的效果，取决于状态机的状态，而这些状态，对于上层用户而言，过于晦涩和底层，非常易错，非常繁琐，因而需要封装和抽象，以有效的隔离复杂度。

当你bindbuffer， bufferdata， enablexxxarray， drawelement， 调用了一堆命令画一个东西，流程显得复杂，只要其中任何一个步骤不对，就不能完成正确的绘制。所以封装的直观意义在于，我只要调用1个命令，1个动作，就能完成之前很多行才能完成的画一个东西，另一个方面，至于这个东西画成什么样子，这个东西是什么样子，我应该把这个东西本身做一个封装，而不是散落在gl的一堆命令之中。对应起来：我们抽象封装的主要对象是**渲染的功能/命令**，和**渲染的资源**。

在web的环境下，用户能够创建多个canvas，创建多个不同的webglcontext， 所以framwwork，应该能做到一份数据能够在多个context下进行渲染。所以这就使得我们存在一个假设，用以创建context绑定的gl资源的数据， 不会在创建完gl资源结束后被释放，而是能够创建其他context的gl资源。用户本身持有这个数据，作为渲染内容的描述，而webgl引擎，负责资源的处理工作，这样的设计，能够向用户屏蔽gl资源创建和维护的流程，屏蔽多context的额外流程。

由上面的例子可以看出，渲染的资源/数据，具有一些区别的。我们讨论的资源，分为如下三种，第一种是所谓的**场景数据**，就是上文提到的用户本身持有的数据。第二种，是所谓的**gl资源**，gl资源的重要特点是context相关的，属于某一个context，由场景数据生成。第三种，是所谓**渲染数据**。关于渲染数据，可以理解为为了渲染而存在的中间数据，和gl没有关系，但是和渲染或者渲染的优化有直接的关系，对顶层用户是透明的。场景数据是描述了这个东西是什么，但是这个描述对应到实际的绘制命令，还有相当的距离。引擎会根据用户提供的场景数据，创建或者同步gl资源和渲染数据的更新，并使用它们进行实际的gl调用完成绘制过程。

## 用户场景数据

对于用户来说，关心的数据是场景的数据。 用户只能持有和访问场景数据。 场景数据是要么描述画什么，要么描述怎么画，场景数据结构，几乎等同于图形系统的API。如何设计场景数据，等于如何设计图形系统API。

理想的API应该是声明式的一个纯数据对象，图形系统直接从这个数据上确定怎么画和画什么的信息，用户修改场景数据，即产生效果。 糟糕的API是，用户可能不仅仅需要构造数据描述，还需要显式的调用图形系统的命令式接口，数据的构造，修改，和下层接口调用相互耦合和依赖。这种糟糕的设计会直接导致用户业务层代码的混乱，需要尽力避免。

### 关于描述画什么的场景数据

从用户的角度而言，一个最直观的接口就是一个数组，按绘制顺序描述了drawcall。用户每一帧都修改这个数组，或者不用改，丢给renderer就可以工作了。这种模式类似于display list，可以认为是最最基本的用户场景描述结构。 如果用户想要画一堆东西，他就需要构造renderList就可以了。这样设计的好处在于，整个用户数据的描述方式和渲染引擎是解耦的，用户可以自己构造，也可以使用另外的组件，例如场景树，场景图，来生成renderList， 总之，renderer只认识renderList。至于如何高效的生成和维护renderlist，那不是渲染引擎的任务。

更加自由一点的设计，也是我们真正支持的设计： 是一个称之为rendersource的抽象。rendersouce，是一个迭代器，renderer会一直调用next方法来获取下一个drawcall的信息。这样做的好处是，我们不用依赖一个中间的静态的list的数据结构，减少了内存和gc上的开销，同时也能灵活支持动态的特性。

所以我们暂且不讨论例如场景树之类的上层结构，还是围绕renderlist，为了保持自上而下的一致性，renderlist就是drawcalllist， 我们应该怎么描述每一个drawcall呢？ 在我们每画一个有意义的东西，而言，对于底层的工作，需要： 一堆attributes buffer来描述画的具体内容，一个program以及一堆uniform参数包括一堆gl参数描述如何去画。还有一堆uniform参数用来指定另一种画的内容（贴图）。 在artgl中，我们针对这三种底层资源设计了三种上层场景数据，Geometry， Technique， 和 Material。


#### 场景树

artgl提供了一套场景树的实现。场景树以树的形式组织场景结构，主要是为了提供层次结构的信息，是一个非常基础和通用的做法。

如何高效的生成renderlist？

高效的生成和维护renderlist的问题，本质上是一个树结构如何和一个array结构同步的的问题。tree结构的特点是，对某一个属性的修改，能够影响所有后代节点。事实上如果用户实现和场景树一样的功能，也是需要手工的去批量在renderlist中做修改，场景树其实就是封装了这样的功能。

一般而言，树结构维护到array并不是一件很简单的事情，对于像threejs之类的实现，是每一帧都全量的遍历场景节点，全量的生成renderlist。对于节点数不多的场景，这个开销不是很高，但对于节点数上万的情况，这种全量的遍历生成就有些浪费了。

  我们为什么要关心场景变动？

  如何得知场景发生变动？ 

  很简单，对于我们关心的属性，使用getter和setter捕获变动。对于数组属性，处于性能考虑，提供额外的接口通知变动，并不建议用户直接进行数组操作。
  
  关心的场景变动类型：

      和renderlist结构相关的场景变动：

      节点的添加和移除

      能够通过父子关系扩散的场景变动：

      visible， 世界矩阵， 包围数据，等

  这些其实就是我们之前提到的渲染数据。上层的场景数据描述系统，不仅要实现场景的描述，不仅需要向下层提供renderlist， 还需要提供与之相关的配套逐个drawcall的渲染数据，以实现渲染优化。 在每次实际渲染之前，需要完成场景数据到渲染数据的更新。

  目前我的实践以及一些想法是： 通过getter setter和额外接口，细粒度的提供变动信息。 使用两个set来记录一帧之间用户对场景树节点的增删情况，并同步到renderlist。实际的renderlist并不简简单单是一个array，而是一系列提供了标记删除自动扩容功能的typedarray。drawcall以及配套的渲染信息以非常紧凑的形式记录在typedarray中， 对其他资源的依赖以索引的形式存储。 

  使用typedarray存储渲染数据至少有以下的好处 

  1 方便实现renderlist排序， 在typedArray中的数据经过组合可以天然作为 radix sort的 sortkey，可以避免快速排序的开销， 例如对program的依赖事实上反映在了shader的index上，对于状态的依赖事实上反映在状态的key上。我们直接评估各种状态切换的成本，来调整array中数据存储的布局，直接影响排序的结果，以及渲染的性能。

  2 typedArray实现了标记删除和扩容，可以非常确定的保证GC。而普通的js array做不到这一点。数据在typedArray存储非常紧凑，不会有js引擎优化实现带来的心智负担

  3 方便直接传递到webworker中。即便有些数据不可避免还是需要复制，直接slice进行复制，比浏览器的自己的复制要快。 在某些地方我们可以实现typedArray双缓冲的机制，主线程写，worker用，worker用完结束transfer回来主线程立刻把新的transfer过去，同时使用workertransfer回来的来覆盖写，同时避免数据复制和GC。

  4 方便直接发送给webAssembly模块进行重计算





