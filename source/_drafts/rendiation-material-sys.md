# Rendiation 材质系统设计和实现

Rendiation是我业余长期开发维护的一个图形渲染引擎，自去年年底12月提出了这个新的宏伟计划之后，我的今年大部分的业余编码时间全部投入这个项目之中。Rendiation在渲染抽象层之上核心作出了的一套材质系统的框架性的实现。经过实践，相关的想法已经成形，虽然具体的实现依然在开发之中，但我自认为这套体系浓缩了我今年对材质框架新的独立思考，那么于此我做一些介绍和输出。

## About the dirty works we knew

长期以来，我们编写渲染引擎的特效实现，遵从的模式是：写shader字符串，import/include 其他可用的shader的片段。然后将完整的shader拼接出来，配合一些其他信息交由图形API生成对应的pipeline。这种模式其实是一种四分五裂的状态，带来诸多不便：

* 构建于字符串拼接之上的抽象
* 跨平台困难
* 实现冗余

## 构建于字符串拼接之上的抽象

因为着色器语言静态强类型，其表达能力是强烈限制的，所以我们可以理解编程语言的割裂这个问题。

所谓构建于字符串拼接之上的抽象，举例说我们一般会上层封装出很多概念和抽象，比如光源，材质等，这些抽象的运作过程是通过在底层拼接shader字符串完成的。在我第一次学习图形学，看到这种字符串拼接的通用做法，是比较诧异的，我以为有更高级的做法，但事实上并没有。写web的会手工拼接html吗，过去的确是会，但现在我们不是有更好的做法吗？

我认为web是一个好的比喻，html比于glsl：浏览器提供了直接解析显示html字符串为页面的能力，浏览器也提供了将glsl变为一个可以执行图形绘制的shader的能力。
html是dom tree，浏览器提供了一整套API用以操作dom树节点，构建于dom API的那些前端框架再进一步为前端开发者提供了真正好用的抽象能力。但是我们看到glsl这边就完全没有了。我们畅想一下对应的是，**我们需要一套用以操作shader的控制流/数据流图节点的API，然后构建于这套流图的API之上，封装出材质框架，提供真正好用的抽象能力。**

html描述了一个tree的结构，所以重要的是tree，tree才是核心，html只是这个tree的一种输入方式而已，如果我高兴我可以用json同样来表述tree。 glsl描述了一个程序的执行逻辑，从程序的表达方式而言，显然这里match tree的就是流图了，tree毕竟也是graph的子集，graph才是核心，glsl只是这个这个graph的一种方式而已，我完全可以使用其他的着色器语言，来对应到这一个graph。

我们不断通过调整拼接字符串的逻辑来进行dom操作吗，显然是不可能的。但是我们在shader的处理上做的事情恰恰如此。低效，易错，dirty。而构建于字符串之上的抽象是如此的不足，直接造成了下面的核心问题：

### 跨平台

跨平台指的是跨图形API的问题，我们有如此多的target要支持，每个target又有不同的版本，每个版本都会给shader添加一些新的能力，甚至每个target又有一堆extension，每个extension又给shader添加了一些新的能力。这就变成了一个工程上的难题。

理智的说，我大概需要知道这么两件事情，1 针对某一个shader module，或者是逻辑上的着色单元。对于每个target，对于每个version，能不能支持的了，2 如果不能，有没有extension可以支持，如果没有extension，那么有没有可能做一些性能上的牺牲，框架层面自动生成polyfill，有没有可能提供一种工程上漂亮的优雅降级的能力？

我想如果框架是运行在字符串拼接上，那么恐怕1都搞不定，因为我们都给不出一个严谨的shader的feature set的描述。有了这个描述，我们才能和各个target/version去match 他们的feature set。我们不能指望用户给标记这些东西。

第二个目标就更加困难了，因为这本质上要让我们对shader的程序进行变换和改写。讲道理我shader能靠字符串操作自动展开for循环已经不容易了，基于字符串，真的不能做更多事情。

**字符串是没有结构的东西**，没有结构是问题的核心。材质系统是编译器技术和图形学技术融合的地方，做的好真的比较难，是逃不掉写compiler的，只有搞定编译器前端，你才能真正的获得完整的结构化的着色逻辑，才能真正开始搞事情。

设计一门新的着色语言，然后compile到其他target，我现在认为不是一个好的做法，或者说不是问题的核心。我认为核心是要作出着色逻辑的结构化描述出来，就是IR，针对这个IR，去为你要支持的target建模feature set，feature set的识别和降级算法。然后为你想支持的语言写前端，来compile到IR上。你可以同时支持glsl和hlsl，一个着色组件用glsl，另一个用hlsl，大家share 着色组件的实现，做成库，再也不care shader是什么语言的问题。当然你也可以设计自己的语言。 另外我推崇直接将框架语言的子集作为前端，这样，同一份语言可以同时跑在CPU和GPU上，完全没有跨语言的问题。

## 冗余

pipeline layout descriptor类型的信息和shader内的信息是冗余的



## 其他能力


#### 为什么使用流图，而不是AST？




