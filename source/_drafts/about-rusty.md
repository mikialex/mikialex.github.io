# Rust的安利水文

业余集中写rust半年左右，差不多删了写有3-4w行了。此文一方面特安利编程语言Rust，这是**水文**。另一部分会结合实际工作的参照，谈一些非语言性质的提升。

在2018年h2我在公司的工作是修复令人头疼的内存释放不掉的问题。（我这里不再说内存泄漏了，因为脚本语言就没有内存泄漏的的概念。）但是即便有devtools的堆快照神助，依然是非常令人恶心。具体而言就是某些操作前后截取快照，compare，看看那些对象多了，为什么多了，是被谁持有释放不掉？然后修复问题。这个话说是轻巧，但是这个引用链看起来真的是头晕目眩，各种闭包，各种浏览器内置的对象，甚至编译工具，React本身就是有问题的。但这不是令我恶心的重点。我恶心的重点很简单，就是项目写的太烂了。又卡又慢，，

我现在觉得那段时间对我的提升是巨大的，包括在那年的h2retro中总结的一样，具体来说，就是当我们实现一个功能，不能说看到那个对象有我们要的东西，就直接引用过来，直接搞。整个项目里全是引用乱指，对象之间相互依赖，没有职责能力划分，一团麻花。所以后来我写代码是会比较关注对象引用结构的。我总结下来一个比较重要的实践是：当一个对象持有另一个的时候却仅仅是为了messaging，他们没有依赖上的关系时，我们应该将另一个对象作为方法参数来引入，而不是直接持有这个对象。等等，有一系列诸如此类的感想吧。

在19年业余我着重做我的artgl，作为框架作者的角度来思考事情，这些事情包括但不仅限与上述的引用关系，状态的划分，逻辑的组织，接口的设计，。而在19年下半年开始，我着重使用rust进行业余项目的开发。顿时觉得解决了我很多的困扰。其实最早听说rust是在17年左右，主要是知乎和 hacker news。 开始业余使用是在18年末。主要原因一方面是看得多了，有了兴趣，想尝试一下。而这尝试的确给了我很多眼前一亮的看法。如果一门编程语言仅仅是语法语法糖上的进化是没有学习的必要的而使用rust真的让我学习到了很多很多的东西。假设你和我一样是一名web开发者，如果你没有编译型语言基础，没有底层知识和专业背景，或者更进一步，是一名框架类库的开发者，想要在优秀设计，严谨缜密，高性能的代码上有所追求，那么真的推荐这一门语言。几个感受：

因为所有权的存在，所以在设计状态/数据的分部时，真的要结合可能的逻辑，流程好好考虑清楚，数据结构设计合理了，就成功一半了。如果强行使用垃圾的设计，在后续写逻辑的时候编译器会非常抱怨，然后你又如果强行用rc refcell绕过，那么最后代码会写的很丑陋。每当编译器抱怨，不要立刻一通操作，而是结合你的逻辑，想一想代码的数据流是什么，不要总是想控制流，一定要想清楚数据流是什么，想清楚到底数据应该分成几部分，每一部分在每一个环节的可变性如何，rust不是那种铅笔，可以边想边写，而是要有个全局的，数据流上的思考，这样编译才不会又问题，而经过我的实践，每次经过这样的思考，我就能立刻将数据以更合理的方式组织，整个实现的质量也会提升。所以我的感受是编译器始终强迫你思考并写出更合理的设计。

又因为所有权和一整个RAII的存在，所以我的程序里的状态是非常放心的，这对于library的作者是利好。在js里，只要用户能接触到的东西，都可以被他引用起来，然后搞出事情，而现在这种事情是不存在的了，我要是不move给你，你是没法持有我的数据的。另一个放心的点是我可以很好的控制可变性，只读的就是只读的。这真的是另一种约束自由但是提升质量的感受，你不能干一些事情，不仅是不允许，更是不应该。

trait系统真的太棒了，一套语法同时统一静态和动态的多态，这才是真正的大道至简好不好。关联类型，也是绝妙，泛型trait允许类型注入进trait， 关联类型允许trait的实现者输出类型。我记得我在artgl里想要解耦rendergraph和renderer，然后用ts泛型做，然后所有类上面都是5个类型注入进来，太丑陋了，而有了关联类型，你完全可以注入一个。泛型trait又可以有很好的玩法，我记得我用这个抽象任意两个几何体相交的结果这个逻辑。一些综合的玩法我觉得可以另写文了。trait真的太好用了，还能用来约束泛型参数，这个功能我觉得是非非常基础和必要的功能，竟然c++20才有类似的语法。

另一大爽点还是属于类型系统，ADT！，ZST！，包装类型，有了这些东西你真的可以把程序写的无比严谨，甚至你就应该这么做，表示弧度的数字和表示角度的数字不应该用一个类型，表示mesh的几何和表示wireframe的几何不应该用一个几何类型，所以这样，很多额外的知识被类型系统所表达，很多额外的检查被编译期完成，正所谓严谨。越idiomatic越严谨，越能体会到逻辑的快乐。

宏真的太棒了，卫生宏可靠，过程宏无敌。有了过程宏就可以为所欲为，君不见有ui框架直接再rust里写html双向绑定吗？

对于lifetime标记，真的没必要害怕，习惯就好。一般写着写着遇到这种显示依赖外部引用的struct，基本上有可能你就要给编译器做证明题了。我觉得比较坑的是，这种情况下，默认的lifetime elision往往是误导的，一定要想清楚到底这些引用谁依赖谁谁长过谁，谁的数据要跑到谁上面，然后才能写显式约束，正所谓向编译器做证明题。万不可两眼一抹黑，上来胡乱标记一通，指望编译器救你。

对于UI，场景树，图结构，动态的eventhub， 或者自引用的东西，这种东西搞生命周期啥的，是不可能的，静态分析不出来的，只能走动态方案。动态的有两种，一种就是标准做法，rc refcell，另一种我觉得也是标准做法，自己搞一个arena的分配器，做的合理应该考虑generational标记，用index代替指针/引用，表示引用关系，这种也是万能的，本质也是将检查变成运行时。我比较喜欢第二种，一方面第二种是典型的面向数据的设计，DOD，好的缓存命中率带来好的性能，第二是runtime check可以全局关，第三是数据化的引用关系可以直接用于结构的序列化，毕竟是数据，就是buffer，就是整齐的好东西。第四是DOD了以后可以进一步搞ECS，搞更多面向数据的东西，很多引擎内部都是这么搞的，只不过他们把这种index叫句柄。而且特别流行的一个原因就是他们c++不这么搞，不用句柄代替引用非常危险，句柄真的是万能的东西。第五点，有了句柄就可以搞跨语言甚至是跨设备的调用。我曾经写的wasm的scenegraph和js端的通信就是使用句柄。像浏览器api，比如webglBuffer，本质也是一个句柄而已。

unsafe是真的难写，真的太难了，我指的是给别人造轮子的那种。变性到现在都搞不清楚，我真的太菜了。再我看来最麻烦的是要严格避免有两个active的可变引用指向一块内存，什么叫active，有个专门的paper来描述的，违反了也不会炸，是UB。看的我头都大了，好在官方出了个解释器你敢信，专门一个pass可以检查unsafe逻辑在这规则下有没有UB。。如果要日常写unsafe，也不是不行，一般这么几种情况，要零copy的翻译数据，就是类型reinterpret。另一种比如vec上要同时方便的拿两个mut的位置，心不够大最好里边还是要写位置的check。再另一种是手工延长生命周期，这个事情干之前最好想清楚你要干嘛，有时候还真的得这样。

包管理世界一流，令人泪流满面。我真的不指望现在有多nb的库，至少能像npm一样去加一行依赖配置就能用真的太爽了，你敢想象c++有这种好事，还没有node-modules这种东西。cargo做的是真的好。lint format，静态检查，compile check，全部都开箱即用， debugger，language server一应俱全。wasm一等公民支持，wasm-bindgen泪流满面。也零开销抽象是真的，release O3默认开，LTO，PGO全都有，llvm大法好。啥迭代器，闭包，future随便用，毫无心智负担。性能理论上限是比c还要快的，因为所有mut的引用和c的restrict关键字是一样的，这个可以有很多额外优化空间。

很遗憾最大的吹点，我没法吹内存安全，因为我没这么写过c++，没有玩过火，没有被烧过。我的代码再rustc的守护下无比健壮。还有个遗憾是我几乎没写多线程/网络的代码，所以线程安全这个吹点我现在还没法说，以后再说吧！

最后总结一下，我对rust这门语言非常满意，满足了我对于编译型语言，系统性语言，所有的期望。如果你追求极致的性能（再见了GC，再见了脚本，甚至再见了RC），如果你追求完美的抽象（再见了继承多继承），如果你追求安全严谨和质量（再见了shit project）。rust是唯一的选择。
